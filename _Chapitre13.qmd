# Gestion par groupe

## Numéroter les lignes
::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
data donnees_sas;
  set donnees_sas;
  Num_observation = _n_;
run;

/* Autre solution */
proc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;
data numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;
data _NULL_;
  set donnees_sas nobs = n;
  call symputx('nbLignes', n);
run;
%put Nombre de lignes : &nbLignes.;

/* Le merge "simple" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */
data donnees_sas;
  merge donnees_sas numLigne;
run;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_rbase$num_observation <- row.names(donnees_rbase)
donnees_rbase$num_observation <- seq(1 : nrow(donnees_rbase))

# Numéro du contrat de chaque individu, contrat trié par date d'entrée
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$un <- 1
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)
donnees_rbase$un <- NULL

# Autre solution
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase$numero_contrat <- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))

# Autre solution : order pour éviter le as.numeric
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase$numero_contrat <- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)
#https://stackoverflow.com/questions/11996135/create-a-sequential-number-counter-for-rows-within-each-group-of-a-dataframe
#https://stackoverflow.com/questions/13732062/what-are-examples-of-when-seq-along-works-but-seq-produces-unintended-results
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  mutate(num_observation = row_number())

# Numéro du contrat de chaque individu, contrat trié par date d'entrée
# arrange() va permettre de trier les observations par identifiant et date d'entrée 
donnees_tidyverse <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  mutate(numero_contrat = row_number()) %>% 
  ungroup()
# À FAIRE : Dans group_by, à quoi sert le drop ?
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_datatable[, num_observation := .I]
donnees_datatable[, num_observation := seq_len(.N)]

# Numéro du contrat de chaque individu, contrat trié par date d'entrée
setorder(donnees_datatable, "identifiant", "date_entree", na.last = FALSE)
donnees_datatable[, numero_contrat := rowid(identifiant)]
donnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Première et dernière ligne par identifiant

### Première ligne par identifiant
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */
options dkricond=nowarn dkrocond=nowarn;
data donnees_sas;
  set donnees_sas (drop = numero_contrat);
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

options dkricond=warn dkrocond=warn;
/* Pour trier les colonnes */
data donnees_sas;
  retain identifiant date_entree numero_contrat numero_contrat;
  set donnees_sas;
run;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[!duplicated(donnees_rbase$identifiant), , drop = FALSE]
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == 1) %>% 
  ungroup()

# Autres solutions
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice(1) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice_head(n = 1) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == nth(row_number(), 1)) %>%
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[1], by = identifiant]

# On peut aussi utiliser keyby si l'on souhaite que les résultats soient triés par la variable de groupement (ici identifiant)
donnees_datatable[, .SD[1], keyby = identifiant]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### Dernière ligne par identifiant
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */
options dkricond=nowarn dkrocond=nowarn;
data donnees_sas;
  set donnees_sas (drop = numero_contrat);
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

options dkricond=warn dkrocond=warn;
/* Pour trier les colonnes */
data donnees_sas;
  retain identifiant date_entree numero_contrat numero_contrat;
  set donnees_sas;
run;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == n()) %>% 
  ungroup()

# Autres solutions
donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice(n()) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == nth(row_number(), -1)) %>%
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[.N], by = identifiant]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu

### Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  Premier_Contrat = (first.identifiant = 1);
  Dernier_Contrat = (last.identifiant = 1);
  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);
run;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$premier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = FALSE), 1, 0)
donnees_rbase$dernier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = TRUE), 1, 0)
donnees_rbase$ni_prem_ni_der  <- ifelse(! c(!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 1, 0)
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Premier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %>% 
  ungroup()

# Dernier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %>% 
  ungroup()

# Ni le premier, ni le dernier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %>% 
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
donnees_datatable[, premier_contrat := fifelse(!duplicated(identifiant, fromLast = FALSE), 1, 0)]
donnees_datatable[, dernier_contrat := fifelse(!duplicated(identifiant, fromLast = TRUE), 1, 0)]
donnees_datatable[, ni_prem_ni_der := fifelse(! c(!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), 1, 0)]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
/* Création de 2 bases en une seule étape */
data Premier_Contrat Dernier_Contrat;
  set donnees_sas;
  by identifiant date_entree;
  if first.identifiant then output Premier_Contrat;
  if last.identifiant then output Dernier_Contrat;
run;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
premier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]
dernier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]
ni_prem_ni_der  <- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Premier contrat
premier_contrat <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  filter(row_number() == 1) %>% 
  ungroup()

# Dernier contrat
dernier_contrat <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  filter(row_number() == n()) %>% 
  ungroup()

# Ni le premier, ni le dernier contrat
ni_prem_ni_der <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  filter(! (row_number() == n() | row_number() == 1)) %>% 
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
premier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = FALSE), ]
dernier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = TRUE), ]
ni_prem_ni_der  <- donnees_datatable[! (!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), ]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Sélection de lignes par identifiant

### Les 2 premières lignes de chaque identifiant
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
/* Les 2 premières lignes de chaque identifiant */
proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat <= 2;
quit;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# 2 premières lignes par identifiant (le premier si une seule ligne)
# Peut-on le faire en moins d'étapes ??? Avec head ?
donnees_rbase$a <- 1L
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase$numero_contrat <- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)
deux_premieres_lignes <- donnees_rbase[which(donnees_rbase$numero_contrat <= 2), ]
donnees_rbase$a <- NULL

# REVOIR
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]
#ind <- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]

# Version en R Base
#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Les deux premières lignes
deux_premieres_lignes <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  slice(1:2) %>% 
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_premieres_lignes <- donnees_datatable[, .SD[1:2], by = identifiant]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### Les 2 dernières lignes de chaque identifiant
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
/* Les 2 dernières lignes de chaque identifiant */
proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat >= count(*) - 1;
quit;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# 2 premières lignes par identifiant (le premier si une seule ligne)
# Peut-on le faire en moins d'étapes ??? Avec head ?
donnees_rbase$a <- 1L
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase$numero_contrat <- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)
deux_premieres_lignes <- donnees_rbase[which(donnees_rbase$numero_contrat <= 2), ]
donnees_rbase$a <- NULL

# REVOIR
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]
#ind <- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]

# Version en R Base
#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Les deux dernières lignes
deux_dernieres_lignes <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  slice(n() - 2) %>% 
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_dernieres_lignes <- donnees_datatable[, .SD[.N-2:.N], by = identifiant]

# À REVOIR : ne fait pas exactement pareil
# donnees_datatable[, tail(.SD, 2), by = identifiant]
# Par ailleurs, utiliser rowid ???
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### 2e ligne de l'individu (et rien si l'individu a 1 seule ligne)
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

/* 2 stratégies possibles */
data Deuxieme_Contrat;
  set donnees_sas;
  if numero_contrat = 2;
run;

data Deuxieme_Contrat;
  set donnees_sas (where = (numero_contrat = 2));
run;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Avec le numéro de contrat
deuxieme_ligne <- donnees_rbase[donnees_rbase$numero_contrat == 2, ]
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
# Autre solution
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-(length(x)-1)])), ]
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  filter(row_number() == 2) %>% 
  ungroup()
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deuxieme_ligne <- donnees_datatable[, .SD[2], by = identifiant]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### L'avant-dernière ligne de l'individu (et rien si l'individu a 1 seul contrat)
::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}
``` sas
/* Nécessite d'avoir le numéro du contrat */
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat = count(*) - 1;
quit;
```

### `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]
```

### `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  filter(row_number() == nth(row_number(), -2))
```

### `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[.N-1], by = identifiant]
```

### `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Sélection par groupement

### Personnes qui ont eu au moins une entrée en 2022

::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
/* Personnes qui ont eu au moins une entrée en 2022 */
proc sql;
  select *
  from donnees_sas
  group by identifiant
  having sum(year(date_entree) = 2022) >= 1;
quit;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
auMoins2022 <- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))

# Autre solution : ne semble possible que pour une seule variable
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
auMoins2022 <- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
auMoins2022 <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(any(lubridate::year(date_entree) == 2022)) %>% 
  ungroup()

# Ou plus simplement
auMoins2022 <- donnees_tidyverse %>% 
  filter(any(lubridate::year(date_entree) == 2022), .by = identifiant)
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
auMoins2022 <- donnees_datatable[, if(any(lubridate::year(date_entree) %in% 2022)) .SD, by = identifiant]

# Autre solution
auMoins2022 <- donnees_datatable[, if (sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) > 0) .SD, by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée

::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
proc sql;
  create table Qualif_Non_Qualif as
  select *
  from donnees_sas
  group by identifiant
  having sum(Niveau = "Non qualifie") >= 1 and sum(Niveau = "Non qualifie") >= 1;
quit;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
qualif_non_qualif <- subset(
  transform(donnees_rbase, 
            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == "Qualifié", 1, 0), na.rm = TRUE)), 
            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == "Non Qualifié", 1, 0), na.rm = TRUE))),
  qualif >= 1 & non_qualif >= 1)
# https://stackoverflow.com/questions/49669862/how-to-group-by-in-base-r
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
qualif_non_qualif <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(any(niveau == "Qualifié") & any(niveau == "Non qualifié")) %>% 
  ungroup()

# Ou plus simplement
qualif_non_qualif <- donnees_tidyverse %>% 
  filter(any(niveau == "Qualifié") & any(niveau == "Non qualifié"), .by = identifiant)
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée

# Méthode la plus simple
donnees_datatable[, if (sum(niveau == "Qualifié", na.rm = TRUE) > 0 & sum(niveau == "Non qualifié", na.rm = TRUE) > 0) .SD, by = identifiant]

# Autre méthode
donnees_datatable[, `:=` (qualif = sum(fifelse(niveau == "Qualifié", 1, 0), na.rm = TRUE),
                          non_qualif = sum(fifelse(niveau == "Non qualifié", 1, 0), na.rm = TRUE)),
                by = identifiant][qualif > 0 & non_qualif > 0]

# Autre méthode
donnees_datatable[, `:=` (qualif = sum(niveau == "Qualifié", na.rm = TRUE), non_qualif = sum(niveau == "Non qualifié", na.rm = TRUE)), by = identifiant][qualif > 0 & non_qualif > 0]

# Group by et Having de SQL
# https://github.com/Rdatatable/data.table/issues/788
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

### Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022

::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022 */
proc sql;
  create table Deux_Contrats as
  select *
  from donnees_sas
  group by identifiant
  having count(*) = 2 and sum(year(date_entree) = 2022) >= 1;
quit;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
deux_contrats <- subset(
  transform(donnees_rbase, 
            nb = ave(identifiant, identifiant, FUN = length), 
            an = ave(date_entree, identifiant, 
                     FUN = function(x) 
                       sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),
  nb == 2 & an >= 1)
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022
deux_contrats <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(n() == 2) %>% 
  filter(any(lubridate::year(date_entree) == 2022)) %>%
  ungroup()

# Ou plus simplement
deux_contrats <- donnees_tidyverse %>% 
  filter(any(lubridate::year(date_entree) == 2022 & n() == 2), .by = identifiant)
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022
donnees_datatable[, if (.N == 2 & sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) >= 1) .SD, by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Ajouter le nombre d'observations par CSP
::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
proc sql;
  create table donnees_sas as
  select a.*, b.n
  from donnees_sas a left join
       (select CSPF, count(*) as n from donnees_sas group by CSPF) b on CSPF = CSPF
  order by identifiant;
quit;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase <- transform(donnees_rbase, 
                           n = ave(cspf, cspf, FUN = length))
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% add_count(cspf)

# Autre solution
donnees_tidyverse <- donnees_tidyverse %>%
  group_by(cspf) %>%
  mutate(n = n()) %>% 
  ungroup()
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, n := .N, by = cspf]
donnees_datatable[, n := length(identifiant), by = cspf]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Ajouter deux colonnes désignant la note moyenne et la somme de Note_Contenu, par individu
::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
/* 1ère solution */
proc sort data = donnees_sas;by identifiant;run;
proc means data = donnees_sas mean noprint;
  var Note_Contenu;
  by identifiant;
  output out = Temp;
run;
data Temp;
  set Temp (where = (_STAT_ = "MEAN"));
  keep identifiant Note_Contenu;
  rename Note_Contenu = Note_Contenu_Moyenne;
run;
data donnees_sas;
  merge donnees_sas (in = a) Temp (in = b);
  by identifiant;
  if a;
run;

/* 2e solution : plus souple */
/* Pour supprimer la variable ajoutée lors de la 1ère solution */
data donnees_sas;
  set donnees_sas (drop = Note_Contenu_Moyenne Note_Contenu_Somme);
run;
proc sql;
  create table donnees_sas as
  select *
  from donnees_sas a left join
       (select identifiant,
               mean(Note_Contenu) as Note_Contenu_Moyenne,
               sum(Note_Contenu) as Note_Contenu_Somme
        from donnees_sas group by identifiant) b
       on a.identifiant = b.identifiant
  order by identifiant;
quit;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase <- transform(donnees_rbase, 
                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), 
                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%
  group_by(identifiant) %>%
  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),
         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %>% 
  ungroup()
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),
                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]
# Moyenne de chaque note par individu
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
donnees_datatable[, paste0(notes, "_m") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Ajouter une variable d'entrée initiale par individu
::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by Identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by Identifiant date_entree;
  format premiere_entree ddmmyy10.;
  retain premiere_entree;
  if first.Identifiant then premiere_entree = date_entree;
  else                      premiere_entree = premiere_entree;
run;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN !
donnees_rbase <- transform(donnees_rbase,
                           premiere_entree = ave(date_entree, identifiant, FUN = function(x) head(x, 1)))
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  mutate(premiere_entree = head(date_entree, 1), .by = identifiant)

# Autre solution
donnees_tidyverse <- donnees_tidyverse %>%
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  group_by(identifiant) %>%
  mutate(premiere_entree = case_when(row_number() == 1 ~ date_entree,
                                     TRUE              ~ NA)) %>%
  fill(premiere_entree, .direction = c("down")) %>% 
  ungroup()
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
setorderv(donnees_datatable, c("identifiant", "date_entree"), na.last = FALSE)
donnees_datatable[, premiere_entree := head(date_entree, 1), by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Ligne où se trouve une valeur maximale pour un individu (À REVOIR)

On cherche, pour chaque individu, la ligne où se trouve la valeur maximale de Note_contenu.

<https://stackoverflow.com/questions/24558328/select-the-row-with-the-maximum-value-in-each-group>

::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas
/* On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R */

/* Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo */
proc sort data = donnees_sas;by identifiant descending note_contenu;run;
data ligne_max_note_contenu;
  set donnees_sas;
  by identifiant descending note_contenu;
  if first.note_contenu;
run;

/* Renvoie seulement la première ligne en cas d'ex-aequo */
proc sort data = donnees_sas;by identifiant descending note_contenu;run;
data ligne_max_note_contenu;
  set donnees_sas;
  by identifiant descending note_contenu;
  if first.identifiant;
run;
```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R
# PAS AVEC LA STRATEGIE DU GROUP ET FIRST. !!! DISTINGUER LES DEUX CAS !!!

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- merge(aggregate(note_contenu ~ identifiant, max, data = donnees_rbase), donnees_rbase)

# Autre solution
donnees_rbase[with(donnees_rbase, note_contenu == ave(note_contenu, identifiant, FUN = max)),]

# Renvoie seulement la première ligne en cas d'ex-aequo
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$note_contenu), ]
ligne_max_note_contenu <- donnees_rbase[! duplicated(donnees_rbase$identifiant), ]

# Autre solution
ligne_max_note_contenu <- do.call(rbind, lapply(split(donnees_rbase, as.factor(donnees_rbase$identifiant)), function(x) {return(x[which.max(x$note_contenu),])}))
```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  slice_max(note_contenu)

# Renvoie seulement la première ligne en cas d'ex-aequo
ligne_max_note_contenu <- donnees_tidyverse %>%
     group_by(identifiant) %>%
     slice(which.max(note_contenu))
```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- donnees_datatable[donnees_datatable[, .I[note_contenu == max(note_contenu)], by = identifiant]$V1]

# Renvoie seulement la première ligne en cas d'ex-aequo
ligne_max_note_contenu <- donnees_datatable[, .SD[which.max(note_contenu)], by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::

## Changement d'état (rleid) À FAIRE

Exemple à trouver avec Financement public / privé / mixte

::: {.panel-tabset group="language"}

## `SAS` {.unnumbered .unlisted}
``` sas

```

## `R base` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}

```

## `tidyverse` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}

```

## `data.table` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}

```

## `arrow/duckdb` {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

:::