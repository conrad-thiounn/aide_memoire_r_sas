{
  "hash": "bbf2d91d7d0bc452acd32f7ac68fcb6e",
  "result": {
    "markdown": "---\ntitle: \"Trucs et astuces en `R`\"\nlang : fr\nauthor:\n  - name: Nassab ABDALLAH\n    affiliation: Dares/SCS, <nassab.abdallah@travail.gouv.fr>\n  - name: Damien EUZENAT\n    affiliation: Dares/DIP, <damien.euzenat@travail.gouv.fr>\nformat:\n  html:\n    toc: true\n    toc-expand: 2\n    toc-location: left\n    number-sections: true\n    code-copy: true\n    smooth-scroll: true\n    link-external-icon:\ttrue\n    link-external-newwindow: true\n    page-layout: full\n    code-tools: true\n    \n# format : native    \n\neditor: visual\n\n# Summary for listings and search engines\ndescription: |\n  Trucs et astuces en `R`.\n\n# Date published\ndate: \"2024-07-22\"\noutput:\n  rmdformats::robobook:\n    highlight: tango\n    number_sections: true\n  \ncategories:\n  - R\n---\n\n\n::: justify\nVoici quelques trucs et astuces utiles à connaître sur R, issus en partie des livres [The R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) et [Advanced R](https://adv-r.hadley.nz/), à consulter pour plus de détails.\n:::\n\n# Effets des calculs en virgule flottante\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n1 / 49 * 49 == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n.1 == .3 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nseq(0, 1, by=.1) == .3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3 0.3 0.3\n```\n:::\n:::\n\n\n# Les types d'objet\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# En savoir plus sur ses données\ndata(\"cars\")\ntypeof(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nclass(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nmode(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nstr(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n```\n:::\n\n```{.r .cell-code}\ndim(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50  2\n```\n:::\n\n```{.r .cell-code}\nc(is.data.frame(cars), is.list(cars), is.vector(cars), is.array(cars))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nNotation L\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Notation L : imposer à R de créer un nombre sous format \"integer\", pour des raisons d'efficacité\nclass(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n# Les affectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importance des espaces\nx<-3\n# S'agit-il de ?\nx <- 3\n# Ou de ?\nx < -3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Il s'agit du premier cas !\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Les {} permettent de réaliser une affectation (<-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x <- 1:6 ; x[1:length(x) %% 2 == 0] <- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] <- x[1:length(x) %% 2 != 0] * 3 ; x})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 51\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx <- pi\n(x <- pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.141593\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comparaisons multiples\nx <- 0.5\n# Correct\n0 < x & x < 1\n# Incorrect\n0 < x < 1\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:6:7: '<' inattendu(e)\n5: # Incorrect\n6: 0 < x <\n         ^\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ne pas confondre !\nseq(0:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11\n```\n:::\n\n```{.r .cell-code}\n0:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nseq(0, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn <- 5\n1:n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq_len(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# Problème avec les 0\nn <- 0\n1:n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0\n```\n:::\n\n```{.r .cell-code}\nseq_len(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx <- c() ;length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:length(x)) print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 4 manières de faire\nsum({l <- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 234168\n```\n:::\n\n```{.r .cell-code}\nsum({l <- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 234168\n```\n:::\n\n```{.r .cell-code}\nsum(l<-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 234168\n```\n:::\n\n```{.r .cell-code}\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 234168\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Opérations mathématiques\n# Infini\n1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\n# Nan = not a number\n0/0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n\n```{.r .cell-code}\nlog(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n:::\n\n\n# Principe de vectorisation\n\nLa fonction s'applique à tous les éléments du vecteur !!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemple de vecteur\nvaleurs <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs <- 1:10\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Valeurs au carré\nvaleurs ** 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# logarithme des valeurs\nlog(valeurs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Maximum des valeurs\nmax(valeurs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Limite des valeurs\nrange(valeurs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nmean(valeurs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Attention aux parenthèses !\nn <- 10\n# Inattendu ! Correspond à (1-1, 2-1, 3-1, ..., 10-1)\n1:n-1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 1 2 3 4 5 6 7 8 9\n```\n:::\n\n```{.r .cell-code}\n# Correct\n1:(n-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Minimum ou maximum élément par élément\nx1 <- c(1, 2, 5, 6, 8)\nx2 <- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 5 2 1\n```\n:::\n\n```{.r .cell-code}\nmapply(min, x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 5 2 1\n```\n:::\n\n```{.r .cell-code}\n# Maximum : 2 possibilités\npmax(x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2 7 6 8\n```\n:::\n\n```{.r .cell-code}\nmapply(max, x1, x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 2 7 6 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx <- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0 0.5 1.0\n```\n:::\n:::\n\n\n# Principe de coercion\n\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complex et character, jusqu'à ce que la comparaison puisse se faire.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nTRUE == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nFALSE == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# TRUE est convertit en character\nTRUE == \"1\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 5 est convertit en character\n5 < '7'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 50 est convertit en character\n50 < '7'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n# Principe de recycling\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonctionne sans soulever de message d'erreur\nx <- c(1, 2, 3)\ny <- c(1, 2, 3, 4, 5, 6)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 5 7 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonctionne, mais Warning\nx <- c(1, 2, 3)\ny <- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in x + y: la taille d'un objet plus long n'est pas multiple de la\ntaille d'un objet plus court\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 5 7 9 8\n```\n:::\n:::\n\n\n# Opérateurs de contrôle\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Conditions if / else\nx <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x est égal à 1\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x est égal à 1\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x est égal à 1\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x est égal à 1\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:3:1: 'else' inattendu(e)\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Switch\n# Fonctions et conditions if / else\ncondition <- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition <- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"salut\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Penser au print\nfor(i in 1:5) i\nfor(i in 1:5) print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSalut !\nComment vas-tu ?\n```\n:::\n\n```{.r .cell-code}\nprint(\"Salut !\\nComment vas-tu ?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Salut !\\nComment vas-tu ?\"\n```\n:::\n:::\n\n\n# Les valeurs manquantes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer les valeurs manquantes en 0\nx <- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  X1 X2\n1  1 NA\n2 NA NA\n3  2  3\n```\n:::\n\n```{.r .cell-code}\nx[is.na(x)] <- 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  X1 X2\n1  1  0\n2  0  0\n3  2  3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA\n```\n:::\n\n```{.r .cell-code}\nis.na(c(3, 1, 3, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 <- 1:6\nx1 == c(1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nx1 %in% c(1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection de données en cas de valeurs manquantes\nxna <- c(1, NA, 3, 2, 4, 2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  2  2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Code compact sans les NA\nxna[which(xna == 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incidence des NA dans le calcul de statistiques !\n# Besoin de l'instruction na.rm = TRUE pour en supprimer l'incidence\nx <- c(1, 5, 6, NA, 8)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmean(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nmax(x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Une moyenne de NA donne NaN (Not a Number) avec na.rm = TRUE !\nmean(c(NA, NA, NA), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n\n```{.r .cell-code}\n# Et donne NA avec na.rm = FALSE !\nmean(c(NA, NA, NA), na.rm = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n# Sélection d'éléments\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx <- 1:3\nx[c(0, 4)] <- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cas où les noms ne sont pas uniques\nx <- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \n1 \n```\n:::\n\n```{.r .cell-code}\nx[names(x) %in% \"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na a \n1 3 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Options drop = FALSE\nx <- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(x[, c(1)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(x[, c(1), drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonction subset\nx <- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1\n1  1\n2  2\n```\n:::\n\n```{.r .cell-code}\nsubset(x, select = -x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x2 x3\n1  3  5\n2  4  6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correct\nsubset(x, x1 == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1 x2 x3\n1  1  3  5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incorrect\nsubset(x, x1 = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Référence à des noms de colonne non usuels\ndf <- data.frame(x = rnorm(5), y = runif(5))\nnames(df) <- 1:2\n\n# Correct\ndf$`1`\n\n# Incorrect\ndf$1\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:9:4: constante numérique inattendue\n8: # Incorrect\n9: df$1\n      ^\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n# Les listes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ajouter un élément à une liste\nliste <- list(1, 2)\n# Il faut passer par cette syntaxe\nliste <- c(liste, list(3))\nliste\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trier une liste\nliste <- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nliste[order(names(liste))]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extraction de listes\nliste <- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar <- \"nombres\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ne marche pas, car nombres est en caractère\nliste$var\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonctionne\nliste[[var]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection dans une liste\nliste <- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$nombres\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nis.list(liste[\"nombres\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nliste[[\"nombres\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nis.list(liste[[\"nombres\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Suppression des éléments d'une liste\nliste <- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n:::\n\n```{.r .cell-code}\nliste[\"nombres\"] <- NULL\nliste\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dernier élément de chaque composante d'une liste\nliste <- list(1:26, letters)\nlapply(liste, tail, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 26\n\n[[2]]\n[1] \"z\"\n```\n:::\n:::\n\n\n# Différences entre sort(), order(), rank()\n\nsort() trie un vecteur par ordre croissant. rank() donne le rang de chaque élément du vecteur, le plus petit élément se voyant attribué le rang 1. order() renvoie l'indice du vecteur trié par ordre croissant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvecteur <- c(5,3,1,2,4)\nsort(vecteur)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\norder(vecteur)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 2 5 1\n```\n:::\n\n```{.r .cell-code}\nrank(vecteur)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 1 2 4\n```\n:::\n:::\n\n\nUne autre solution que sort() pour trier un vecteur est :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvecteur <- c(5,3,1,2,4)\nvecteur[order(vecteur)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nÀ noter aussi que sort() permet aussi d'exécuter simultanément les fonctions sort() et order(). Ainsi :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvecteur <- c(5,3,1,2,4)\nsort(vecteur, index.return = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] 1 2 3 4 5\n\n$ix\n[1] 3 4 2 5 1\n```\n:::\n\n```{.r .cell-code}\n# Fonction sort()\nsort(vecteur, index.return = TRUE)$x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nsort(vecteur)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# Fonction order()\nsort(vecteur, index.return = TRUE)$ix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 2 5 1\n```\n:::\n\n```{.r .cell-code}\norder(vecteur)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 2 5 1\n```\n:::\n:::\n\n\n# Ramasse-miettes (Garbage Collector)\n\nSi la mémoire vive de l'ordinateur est saturée, on peut essayer de la \"purger\" en utilisant la fonction gc() de `R`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  783160 41.9    1259890 67.3  1259890 67.3\nVcells 1508977 11.6    8388608 64.0  2706411 20.7\n```\n:::\n:::\n\n\n# Fonctions try() et tryCatch() À FAIRE\n\n# Informations sur R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Informations sur la session de R\nsessionInfo()\nSys.info()\n.Platform\n\n# Version de R\nR.version.string\n\n# Lien vers le bureau de l'utilisateur\nfile.path(path.expand('~'), \"Desktop\")\n\n# Chemin de l'exécutable R est-il installé ?\nR.home(\"bin\")\n\n# Où sont installés les packages R\n.libPaths()\n```\n:::\n\n\n# Trucs et astuces divers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Créer un objet sous forme de code R !\ndata(\"mtcars\")\ndput(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstructure(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, \n24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, \n30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, \n19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, \n8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4), \n    disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, \n    167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7, \n    71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145, \n    301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 95, \n    123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, \n    150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9, \n    3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, \n    3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, \n    3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11\n    ), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, \n    3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, \n    1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, \n    1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 18.61, \n    19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6, \n    18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, \n    17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6\n    ), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, \n    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3, \n    3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, \n    3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, \n    2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, \n    2, 2, 4, 6, 8, 2)), row.names = c(\"Mazda RX4\", \"Mazda RX4 Wag\", \n\"Datsun 710\", \"Hornet 4 Drive\", \"Hornet Sportabout\", \"Valiant\", \n\"Duster 360\", \"Merc 240D\", \"Merc 230\", \"Merc 280\", \"Merc 280C\", \n\"Merc 450SE\", \"Merc 450SL\", \"Merc 450SLC\", \"Cadillac Fleetwood\", \n\"Lincoln Continental\", \"Chrysler Imperial\", \"Fiat 128\", \"Honda Civic\", \n\"Toyota Corolla\", \"Toyota Corona\", \"Dodge Challenger\", \"AMC Javelin\", \n\"Camaro Z28\", \"Pontiac Firebird\", \"Fiat X1-9\", \"Porsche 914-2\", \n\"Lotus Europa\", \"Ford Pantera L\", \"Ferrari Dino\", \"Maserati Bora\", \n\"Volvo 142E\"), class = \"data.frame\")\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# En tidyverse, la fonction tribble peut être utile pour créer des bases lignes par lignes\nlibrary(tidyverse)\ntribble(\n  ~x, ~y,\n  \"a\",   1,\n  \"b\",   2\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  x         y\n  <chr> <dbl>\n1 a         1\n2 b         2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Outils de debogage\noptions(error = recover)\noptions(error=NULL)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' <- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Récupérer les éléments à la diagonale d'un dataframe\ndiag(as.matrix(mtcars))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  21.00   6.00 108.00 110.00   3.15   3.46  15.84   1.00   0.00   4.00\n[11]   4.00\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# S'assurer qu'un objet R existe déjà\nexists(\"mtcars\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n# Le pipe sur R\n\nCet opérateur permet d'enchaîner les opérations et d'avoir un code plus lisible.\n\nIl existe différents types :\n\n-   **Le pipe de Rbase :** `|>`\n\n-   **Le pipe du tidyverse :** `%>%`\n\nLes deux pipes fonctionnent de la même manière mais diffèrent sur les points suivants :\n\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n| Thème                                         | `|>`                      | `%>%`                                                                 |\n+===============================================+===========================+=======================================================================+\n| Placeholder (pour indiquer où placer l'objet) | `_`                       | `.`                                                                   |\n|                                               |                           |                                                                       |\n|                                               | `x |> f(y, a = _)`        | `x %>% f(y, a = .)`                                                   |\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n| Package                                       | Aucun : directement sur R | Magrittr (pipe disponible lorsqu'on effectue `library(tidyverse)`) \\| |\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n| Fonction                                      | Impossible                | Possible                                                              |\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n| Temps de calcul                               | Rapide                    | Plus lent                                                             |\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n| Opérateurs                                    | `|>`                      | `%>%` `%<>%` `%$%` `%!>%` `%T>%`                                      |\n+-----------------------------------------------+---------------------------+-----------------------------------------------------------------------+\n\n*Source* :\n\n-   https://larmarange.github.io/guide-R/manipulation/pipe.html#le-pipe-natif-de-r\n\n# Conseils divers\n\nIl est déconseillé de nommer des variables temporaires `var`, car ce nom désigne la fonction `R` permettant de calculer une variance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemple : variance d'un échantillon aléatoire de 1000 observations tiré d'une loi normale centrée réduite\nvar(rnorm(1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.019345\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}