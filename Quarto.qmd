---
title: "Aide-mémoire `SAS`-`R` (version longue)"
lang : fr
author:
  - Nassab ABDALLAH^[Dares/SCS, nassab.abdallah@travail.gouv.fr]
  - Damien EUZENAT^[Dares/DIP, damien.euzenat@travail.gouv.fr]
format:
  html:
    toc: true
    toc-expand: 2
    toc-location: left
    number-sections: true
    code-copy: true
    embed-resources: true
    code-tools: true
    css: styles.css
# format : native    

editor: visual

# Summary for listings and search engines
description: |
  Trucs et astuces en `R`.

# Date published
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    highlight: tango
    number_sections: true
  
categories:
  - R, SAS
---

# Version longue de l'aide-mémoire

# Importation des packages

## Importation des packages

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Sans objet pour SAS */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Pour manipuler les dates
library(lubridate)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
library(data.table)
# Documentation
# Pour manipuler les dates
library(lubridate)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Préambule

## Chemin du bureau de l'utilisateur

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On vide la log */
dm "log; clear; ";
/* On récupère déjà l'identifiant de l'utilisateur (systèmes Windows) */
%let user = &sysuserid;
/* Chemin proprement dit */
%let bureau = C:\Users\&user.\Desktop;
libname bur "&bureau.";
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On récupère déjà l'identifiant de l'utilisateur
user <- Sys.getenv("USERNAME")
chemin <- file.path("C:/Users", user, "Desktop")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On récupère déjà l'identifiant de l'utilisateur
user <- Sys.getenv("USERNAME")
chemin <- file.path("C:/Users", user, "Desktop")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Affichage de l'année

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let an = %sysfunc(year(%sysfunc(today())));
/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */
%put Année : &an.;
/* Autre possibilité */
data _null_;call symput('annee', strip(year(today())));run;
%put Année (autre méthode) : &annee.;
/* Année passée */
%put Année passée : %eval(&an. - 1);
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
annee <- lubridate::year(Sys.Date())
sprintf("Année : %04d", annee)
print(paste0("Année : ", annee))
annee_1 <- annee - 1
paste0("Année passée: ", annee_1)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
annee <- lubridate::year(Sys.Date())
sprintf("Année : %04d", annee)
print(paste0("Année : ", annee))
annee_1 <- annee - 1
paste0("Année passée: ", annee_1)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Construction des instructions if / else

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%macro Annee(an);
  %if &an. >= 2024 %then %put Nous sommes en 2024 ou après !;
  %else %put Nous sommes avant 2024 !;
%mend Annee;
%Annee(&an.);
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Construction incorrecte ! Le else doit être sur la même ligne que le {
#if (annee >= 2023) {
#  print("Nous sommes en 2023 ou après")
#}
#else {
#  print("Nous sommes en 2022 ou avant")
#}
## Construction correcte ! Le else doit être sur la même ligne que le {
if (annee >= 2024) {
  print("Nous sommes en 2024 ou après")
} else {
  print("Nous sommes avant 2024 !")
}
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Construction incorrecte ! Le else doit être sur la même ligne que le {
#if (annee >= 2023) {
#  print("Nous sommes en 2023 ou après")
#}
#else {
#  print("Nous sommes en 2022 ou avant")
#}
## Construction correcte ! Le else doit être sur la même ligne que le {
if (annee >= 2024) {
  print("Nous sommes en 2024 ou après")
} else {
  print("Nous sommes avant 2024 !")
}
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Autres points à connaître

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Mise en garde : certains codes SAS pourraient aussi avec profit être écrits en langage SAS IML (Interactive Matrix Language).
   Cet aide-mémoire n'ayant pas vocation à être un dictionnaire SAS, cette méthode d'écriture n'est pas proposée ici */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet en R-Base
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Principe de base de data.table
#dt[i, j, by]
# i : sélection de lignes
# j : sélection et manipulation de colonnes
# by : groupements
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Préparation des données

## Création d'une base de données SAS d'exemple

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Données fictives sur des formations */
data donnees_sas;
  infile cards dsd dlm='|';
  format Identifiant $3. Sexe 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens
         Note_Accompagnement Note_Materiel poids_sondage 4.1 CSPF $25. Sexef $5.;
  input Identifiant $ Sexe CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens
        Note_Accompagnement Note_Materiel poids_sondage CSPF $ Sexef $;
  cards;
  173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1|Cadre|Femme
  173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3|Cadre|Femme
  173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6|Cadre|Femme
  173|2|1|Non Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7|Cadre|Femme
  174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9|Cadre|Homme
  175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2|Cadre|Homme
  198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6|Ouvrier|Femme
  198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3|Ouvrier|Femme
  198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3|Ouvrier|Femme
  168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2|Profession intermédiaire|Homme
  211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4|Employé|Femme
  278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2|Retraité|Homme
  347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6|Retraité|Femme
  112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1|Employé|Homme
  112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4|Employé|Homme
  112|1|3|qualifie|13/09/2001|01/12/2023|365||||||187.6|Employé|Homme
  087|1|3|Non qualifie|||365||||||87.3|Employé|Homme
  087|1|3|Non qualifie||31/10/2020|365||||||87.3|Employé|Homme
  099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3|Employé|Homme
  099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3|Employé|Homme
  099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3|Employé|Homme
  187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3|Profession intermédiaire|Femme
  187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1|Profession intermédiaire|Femme
  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3|Cadre|Homme
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme
  ;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Données fictives sur des formations
donnees_rbase <- data.frame(
  Identifiant = c("173", "173", "173", "173", "174", "175", "198", "198", "198", "168", "211", "278", "347", "112", "112", "112", "087", "087", "099", "099", "099", "187", "187", "689", "765", "765", "765"),
  Sexe = c("2", "2", "2", "2", "1", "1", "2", "2", "2", "1", "2", "1", "2", "1", "1", "1", "1", "1", "1", "1", "1", "2", "2", "1", "1", "1", "1"),
  CSP = c("1", "1", "1", "1", "1", "1", "4", "4", "4", "2", "3", "5", "5", "3", "3", "3", "3", "3", "3", "3", "3", "2", "2", "1", "4", "4", "4"),
  Niveau = c("Qualifie", "qualifie", "qualifie", "Non Qualifie", "qualifie", "qualifie", "Non qualifie", "Qualifie", "Qualifie", "Qualifie", "Non qualifie", "Qualifie", "Qualifie", "Non qualifie", 
             "Non qualifie", "qualifie", "Non qualifie", "Non qualifie", "qualifie", "qualifie", "qualifie", "qualifie", "qualifie", NA, "Non qualifie", "Non qualifie", "Non qualifie"),
  Date_naissance = c("17/06/1998", "17/06/1998", "17/06/1998", "17/06/1998", "08/12/1984", "16/09/1989", "17/03/1987", "17/03/1987", "17/03/1987", "30/07/2002", NA, "10/08/1948", 
                     "13/09/1955", "13/09/2001", "13/09/2001", "13/09/2001", NA, NA, "06/06/1998", "06/06/1998", "06/06/1998", "05/12/1986", "05/12/1986", "01/12/2000", "26/12/1995", "26/12/1995", "26/12/1995"),
  Date_entree = c("01/01/2021", "01/01/2022", "06/01/2022", "02/01/2023", "17/08/2021", "21/12/2022", "28/07/2022", "17/11/2022", "21/02/2023", "04/09/2019", "17/12/2021", "07/06/2018", NA, "02/03/2022", "01/03/2021", "01/12/2023", NA, 
                  "31/10/2020", "01/03/2021", "01/03/2022", "01/03/2023", "01/01/2022", "01/01/2023", "06/11/2017", "17/04/2020", "17/04/2020", "17/04/2020"),
  Duree = c("308", "365", "185", "365", "183", "730", "30", "164", "365", "365", "135", "365", "180", "212", "365", "365", "365", "365", "364", "364", "364", "364", "364", "123", "160", "160", "160"),
  Note_Contenu = c("12", "6", "8", "14", "17", "5", "10", "11", "9", "18", "16", "14", "12", "3", "7", NA, NA, NA, "12", "12", "12", "10", "10", "9", "13", "13", "13"),
  Note_Formateur = c("6", NA, "10", "15", "18", "5", "10", "7", "20", "11", "16", "10", "5", "10", "13", NA, NA, NA, "11", "11", "11", "10", "10", "7", "10", "10", "10"),
  Note_Moyens = c("17", "12", "11", "15", "20", "8", "10", "6", "3", "20", "15", "6", "7", "11", "8", NA, NA, NA, "10", "10", "10", "10", "10", "8", "12", "12", "12"),
  Note_Accompagnement = c("4", "7", "1", "10", "15", "4", "16", "14", "4", "13", "12", "8", "11", "9", "19", NA, NA, NA, "12", "12", "12", "10", "10", "13", "18", "18", "18"),
  Note_Materiel = c("19", "14", "9", "8", "12", "9", "8", "13", "17", "15", "9", "12", "12", "8", "2", NA, NA, NA, "13", "13", "13", "10", "10", "16", "10", "10", "10"),
  poids_sondage = c("117.1", "98.3", "214.6", "84.7", "65.9", "148.2", "89.6", "100.3", "49.3", "148.2", "86.4", "99.2", "105.6", "123.1", "137.4", "187.6", "87.3", "87.3", "169.3", "169.3", "169.3", "169.3", "234.1", "189.3", "45.9", "45.9", "45.9"),
  cspf = c("Cadre", "Cadre", "Cadre", "Cadre", "Cadre", "Cadre", "Ouvrier", "Ouvrier", "Ouvrier", "Profession intermédiaire", "Employé", "Retraité", "Retraité", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé",
           "Profession intermédiaire", "Profession intermédiaire", "Cadre", "Ouvrier", "Ouvrier", "Ouvrier"),
  sexef = c("Femme", "Femme", "Femme", "Femme", "Homme", "Homme", "Femme", "Femme", "Femme", "Homme", "Femme", "Homme", "Femme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Femme", "Femme", "Homme", "Homme", 
            "Homme", "Homme")
)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Données fictives sur des formations
donnees_datatable <- data.frame(
  Identifiant = c("173", "173", "173", "173", "174", "175", "198", "198", "198", "168", "211", "278", "347", "112", "112", "112", "087", "087", "099", "099", "099", "187", "187", "689", "765", "765", "765"),
  Sexe = c("2", "2", "2", "2", "1", "1", "2", "2", "2", "1", "2", "1", "2", "1", "1", "1", "1", "1", "1", "1", "1", "2", "2", "1", "1", "1", "1"),
  CSP = c("1", "1", "1", "1", "1", "1", "4", "4", "4", "2", "3", "5", "5", "3", "3", "3", "3", "3", "3", "3", "3", "2", "2", "1", "4", "4", "4"),
  Niveau = c("Qualifie", "qualifie", "qualifie", "Non Qualifie", "qualifie", "qualifie", "Non qualifie", "Qualifie", "Qualifie", "Qualifie", "Non qualifie", "Qualifie", "Qualifie", "Non qualifie", 
             "Non qualifie", "qualifie", "Non qualifie", "Non qualifie", "qualifie", "qualifie", "qualifie", "qualifie", "qualifie", NA, "Non qualifie", "Non qualifie", "Non qualifie"),
  Date_naissance = c("17/06/1998", "17/06/1998", "17/06/1998", "17/06/1998", "08/12/1984", "16/09/1989", "17/03/1987", "17/03/1987", "17/03/1987", "30/07/2002", NA, "10/08/1948", 
                     "13/09/1955", "13/09/2001", "13/09/2001", "13/09/2001", NA, NA, "06/06/1998", "06/06/1998", "06/06/1998", "05/12/1986", "05/12/1986", "01/12/2000", "26/12/1995", "26/12/1995", "26/12/1995"),
  Date_entree = c("01/01/2021", "01/01/2022", "06/01/2022", "02/01/2023", "17/08/2021", "21/12/2022", "28/07/2022", "17/11/2022", "21/02/2023", "04/09/2019", "17/12/2021", "07/06/2018", NA, "02/03/2022", "01/03/2021", "01/12/2023", NA, 
                  "31/10/2020", "01/03/2021", "01/03/2022", "01/03/2023", "01/01/2022", "01/01/2023", "06/11/2017", "17/04/2020", "17/04/2020", "17/04/2020"),
  Duree = c("308", "365", "185", "365", "183", "730", "30", "164", "365", "365", "135", "365", "180", "212", "365", "365", "365", "365", "364", "364", "364", "364", "364", "123", "160", "160", "160"),
  Note_Contenu = c("12", "6", "8", "14", "17", "5", "10", "11", "9", "18", "16", "14", "12", "3", "7", NA, NA, NA, "12", "12", "12", "10", "10", "9", "13", "13", "13"),
  Note_Formateur = c("6", NA, "10", "15", "18", "5", "10", "7", "20", "11", "16", "10", "5", "10", "13", NA, NA, NA, "11", "11", "11", "10", "10", "7", "10", "10", "10"),
  Note_Moyens = c("17", "12", "11", "15", "20", "8", "10", "6", "3", "20", "15", "6", "7", "11", "8", NA, NA, NA, "10", "10", "10", "10", "10", "8", "12", "12", "12"),
  Note_Accompagnement = c("4", "7", "1", "10", "15", "4", "16", "14", "4", "13", "12", "8", "11", "9", "19", NA, NA, NA, "12", "12", "12", "10", "10", "13", "18", "18", "18"),
  Note_Materiel = c("19", "14", "9", "8", "12", "9", "8", "13", "17", "15", "9", "12", "12", "8", "2", NA, NA, NA, "13", "13", "13", "10", "10", "16", "10", "10", "10"),
  poids_sondage = c("117.1", "98.3", "214.6", "84.7", "65.9", "148.2", "89.6", "100.3", "49.3", "148.2", "86.4", "99.2", "105.6", "123.1", "137.4", "187.6", "87.3", "87.3", "169.3", "169.3", "169.3", "169.3", "234.1", "189.3", "45.9", "45.9", "45.9"),
  cspf = c("Cadre", "Cadre", "Cadre", "Cadre", "Cadre", "Cadre", "Ouvrier", "Ouvrier", "Ouvrier", "Profession intermédiaire", "Employé", "Retraité", "Retraité", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé", "Employé",
           "Profession intermédiaire", "Profession intermédiaire", "Cadre", "Ouvrier", "Ouvrier", "Ouvrier"),
  sexef = c("Femme", "Femme", "Femme", "Femme", "Homme", "Homme", "Femme", "Femme", "Femme", "Homme", "Femme", "Homme", "Femme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Homme", "Femme", "Femme", "Homme", "Homme", 
            "Homme", "Homme")
)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Mise en forme des données

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Sans objet pour l'exemple SAS */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On vérifie que la base importée est bien un data.frame
is.data.frame(donnees_rbase)
# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule
# Renommer les colonnes de la base
colnames(donnees_rbase) <- tolower(colnames(donnees_rbase))
# Autre possibilité
setNames(donnees_rbase, tolower(names(donnees_rbase)))
# Tidyverse : rename_with(): Rename variables with a function donnees_rbase |> rename_with(tolower)
# On a importé toutes les variables en format caractère
# On convertit certaines variables en format numérique
enNumerique <- c("duree", "note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
donnees_rbase[, enNumerique] <- lapply(donnees_rbase[, enNumerique], as.integer)
donnees_rbase$poids_sondage <- as.numeric(donnees_rbase$poids_sondage)
# On récupère les variables dont le nom débute par le mot "date"
varDates <- names(donnees_rbase)[grepl("date", tolower(names(donnees_rbase)))]
# On remplace / par - dans les dates
donnees_rbase[, varDates] <- lapply(donnees_rbase[, varDates], function(x) gsub("/", "-", x))
# On exprime les dates en format Date
donnees_rbase[, varDates] <- lapply(donnees_rbase[, varDates], lubridate::dmy)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Transformation en data.table
# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.
# Ceci est plus efficace pour manipuler des données volumineuses.
donnees_datatable <- setDT(donnees_datatable)
is.data.table(donnees_datatable)
# Autre possibilité
donnees_datatable <- as.data.table(donnees_datatable)
# On vérifie que la base est bien un data.table
is.data.table(donnees_datatable)
# Est-ce une liste ?
is.list(donnees_datatable)
# Extraire les noms des variables de la base
# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule
nomCol <- tolower(colnames(donnees_datatable))
# Renommer les colonnes de la base
colnames(donnees_datatable) <- tolower(colnames(donnees_datatable))
# On convertit certaines variables en format 'numeric'
enNumerique <- c("duree", "note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
# Ne pas oublier le . devant SDcols !!!!
donnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]
# Autre solution
# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.
# Ceci est plus efficace pour manipuler des données volumineuses.
for (j in enNumerique) {
  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))
}
donnees_datatable[, poids_sondage := as.numeric(poids_sondage)]
# On récupère les variables dont le nom débute par le mot "date"
varDates <- names(donnees_datatable)[grepl("date", tolower(names(donnees_datatable)))]
# On remplace / par - dans les dates
donnees_datatable[, (varDates) := lapply(.SD, function(x) gsub("/", "-", x)), .SDcols = varDates]
# On exprime les dates en format Date
donnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Informations sur la base de données

## Avoir une vue d'ensemble des données

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Statistiques globales sur les variables numériques */
proc means data = donnees_sas n mean median min p10 p25 median p75 p90 max;var _numeric_;run;
/* Statistiques globales sur les variables caractères */
proc freq data = donnees_sas;tables _character_ / missing;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Informations sur les variables
str(donnees_rbase)
# Statistiques descriptives des variables de la base
summary(donnees_rbase)
library(Hmisc)
Hmisc::describe(donnees_rbase)
# Visualiser la base de données
View(donnees_rbase)
# Tidyverse : glimpse
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Informations sur les variables
str(donnees_datatable)
# Statistiques descriptives des variables de la base
summary(donnees_datatable)
# Visualiser la base de données
View(donnees_datatable)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Extraire les x premières lignes de la base (10 par défaut)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let x = 10;
proc print data = donnees_sas (firstobs = 1 obs = &x.);run;
/* Ou alors */
data Lignes&x.;set donnees_sas (firstobs = 1 obs = &x.);proc print;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
x <- 10
donnees_rbase[1:x, ]
head(donnees_rbase, x)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, head(.SD, 10)]
donnees_datatable[, .SD[1:10]]
head(donnees_datatable, 10)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Extraire les x dernières lignes de la base (10 par défaut)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let x = 10;
proc sql noprint;select count(*) into :total_lignes from donnees_sas;quit;
%let deb = %eval(&total_lignes. - &x. + 1);
data Lignes_&x.;set donnees_sas (firstobs = &deb. obs = &total_lignes.);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
x <- 10
tail(donnees_rbase, x)
donnees_rbase[ ( nrow(donnees_rbase) - x ) : nrow(donnees_rbase), ]
# Les parenthèses sont importantes. Comparer les deux expressions ! Bon exemple du recycling
( nrow(donnees_rbase) - x ) : nrow(donnees_rbase)
nrow(donnees_rbase) - x : nrow(donnees_rbase)
# Tidyverse : slice(): Choose rows by position
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, tail(.SD, 10)]
tail(donnees_datatable, 10)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Nombre de lignes et de colonnes dans la base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Nombre de lignes */
proc sql;select count(*) as Nb_Lignes from donnees_sas;quit;
proc sql;select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants from donnees_sas;quit;
/* Liste des variables de la base dans la base Var */
proc contents data = donnees_sas out = Var noprint;run;
/* Nombre de colonnes */
proc sql;select count(*) as Nb_Colonnes from Var;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sprintf("Nombre de lignes : %d | Nombre de colonnes : %d", dim(donnees_rbase)[1], dim(donnees_rbase)[2])
sprintf("Nombre de lignes : %d | Nombre de colonnes : %d", nrow(donnees_rbase), ncol(donnees_rbase))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
dim(donnees_datatable) ; dim(donnees_datatable)[1] ; dim(donnees_datatable)[2]
dim(donnees_datatable) ; nrow(donnees_datatable) ; ncol(donnees_datatable)
sprintf("Nombre de lignes : %d | Nombre de colonnes : %d", dim(donnees_datatable)[1], dim(donnees_datatable)[2])
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Liste des variables par ordre d'apparition dans la base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data = donnees_sas out = Var noprint;run;
proc sql;select name into :nom_col separated by " " from Var order by varnum;run;
/* On affiche les noms des variables */
%put Liste des variables : &nom_col.;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Liste des variables par ordre d'apparition dans la base
colnames(donnees_rbase)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Liste des variables par ordre d'apparition dans la base
colnames(donnees_datatable)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Nombre d'identifiants uniques et nombre de lignes dans la base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sql;
  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants_Uniques
  from donnees_sas;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sprintf("La base contient %d lignes et %d identifiants uniques !", nrow(donnees_rbase), length(unique(donnees_rbase$identifiant)))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sprintf("La base contient %d lignes et %d identifiants uniques !", nrow(donnees_datatable), donnees_datatable[, uniqueN(identifiant)])
# Identifiants uniques
donnees_datatable[, uniqueN(identifiant)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Quelle est la position de la variable date_entree ?

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = date_entree;
proc contents data = donnees_sas out = Var noprint;run;
proc sql;
  select varnum as Position from Var where lowcase(NAME) = "&var.";
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "date_entree"
pos <- match(var, names(donnees_rbase))
sprintf("La variable %s se trouve en colonne n°%s !", var, pos)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "date_entree"
pos <- match(var, names(donnees_datatable))
sprintf("La variable %s se trouve en colonne n°%s !", var, pos)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Format des variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data = donnees_sas;run;
/* On supprime la base Var temporaire */
proc datasets lib = Work nolist;delete Var;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sapply(donnees_rbase, class)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, lapply(.SD, class)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Sélectionner des lignes et des colonnes

## Selection de colonnes par position

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let pos = 1;
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " "
  from Var
  where varnum = &pos.;
run;
data Colonnes;set donnees_sas (keep = &nom_col.);run;
proc datasets lib = Work nolist;delete Var;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
pos <- 1
# Résultat sous forme de vecteur caractère
id <- donnees_rbase[[pos]] ; class(id)
id <- donnees_rbase[, pos] ; class(id)
# Résultat sous forme de data.frame
id <- donnees_rbase[pos] ; class(id)
id <- donnees_rbase[, pos, drop = FALSE] ; class(id)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
pos <- 1
# Résultat sous forme de vecteur caractère
id <- donnees_datatable[[pos]] ; class(id)
# Résultat sous forme de data.table
id <- donnees_datatable[pos] ; class(id)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Selection de colonnes par nom

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Colonnes;set donnees_sas (keep = identifiant);run;
data Colonnes;set donnees_sas;keep identifiant;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
id <- donnees_rbase$identifiant ; class(id)
id <- donnees_rbase[["identifiant"]] ; class(id)
id <- donnees_rbase[, "identifiant"] ; class(id)
# Résultat sous forme de data.frame
class(donnees_rbase[, "identifiant"])
# Attention, utilisation du drop = FALSE étrange
# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie
# un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)
class(donnees_rbase[, "identifiant", drop = FALSE])
id <- donnees_rbase["identifiant"] ; class(id)
id <- donnees_rbase[, "identifiant", drop = FALSE] ; class(id)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
id <- donnees_datatable$identifiant ; class(id)
id <- donnees_datatable[["identifiant"]] ; class(id)
id <- donnees_datatable[, identifiant] ; class(id)
# Résultat sous forme de data.table
id <- donnees_datatable[, "identifiant"] ; class(id)
id <- donnees_datatable[, .("identifiant")] ; class(id)
id <- donnees_datatable[, list("identifiant")] ; class(id)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Selection de colonnes par variable

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant Sexe note_contenu;
data Colonnes;
  /* Sélection de colonnes */
  set donnees_sas (keep = &var.);
  /* Selection de colonnes */
  keep &var.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
# Résultat sous forme de vecteur caractère
id <- donnees_rbase[, var] ; class(id)
id <- donnees_rbase[[var]] ; class(id)
# Résultat sous forme de data.frame
id <- donnees_rbase[var] ; class(id)
id <- donnees_rbase[, var, drop = FALSE] ; class(id)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
var <- "identifiant"
id <- donnees_datatable[[var]] ; class(id)
# Résultat sous forme de data.table
id <- donnees_datatable[, .(var)] ; class(id)
id <- donnees_datatable[, list(var)] ; class(id)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sauf certaines variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Colonnes;set donnees_sas (drop = &var.);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ne fonctionne pas !
#exclusion_var <- donnees_rbase[, -c(var)]
exclusion_var <- donnees_rbase[, setdiff(names(donnees_rbase), var)]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ne fonctionne pas !
#exclusion_var <- donnees_datatable[, -c(var)]
exclusion_var <- donnees_datatable[, setdiff(names(donnees_datatable), var)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner la 3e colonne

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " "
  from Var
  where varnum = 3;
run;
data Col3;set donnees_sas (keep = &nom_col.);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
col3 <- donnees_rbase[, 3]
col3 <- donnees_rbase[3]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
col3 <- donnees_datatable[, 3]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner plusieurs colonnes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant note_contenu sexe;
data Colonnes;set donnees_sas (keep = &var.);run;
proc sql;create table Colonnes as select %sysfunc(tranwrd(&var., %str( ), %str(, ))) from donnees_sas;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe")
# Plusieurs manières de faire
colonnes <- donnees_rbase[, cols]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe")
# Plusieurs écritures possibles
# Peut-être l'écriture la plus simple, à privilégier
colonnes <- donnees_datatable[, mget(cols)]
# Ecriture cohérente avec la logique data.table
colonnes <- donnees_datatable[, .SD, .SDcols = cols]
# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!
# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas
colonnes <- donnees_datatable[, ..cols]
# Ecriture qui semble tomber en désuétude
colonnes <- donnees_datatable[, cols, with = FALSE]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner les colonnes qui débutent par le mot Note

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 1ère solution */
data Selection_Variables;set donnees_sas (keep = Note:);run;
/* 2e solution */
proc contents data = donnees_sas out = Var noprint;run;
proc sql;
  select name into :var_notes separated by " "
  from Var where substr(upcase(name), 1, 4) = "NOTE" order by varnum;
run;
proc datasets lib = Work nolist;delete Var;run;
data donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_notes <- donnees_rbase[grepl("^note", names(donnees_rbase))]
var_notes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == "note"]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1ère méthode
cols <- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == "note"]
sel <- donnees_datatable[, .SD, .SDcols = cols]
# 2e méthode
sel <- donnees_datatable[, .SD, .SDcols = patterns("^note")]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner les colonnes qui ne débutent pas par le mot Note

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Selection_Variables;set donnees_sas (drop = Note:);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_notes <- donnees_rbase[! grepl("^note", names(donnees_rbase))]
var_notes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != "note"]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == "note"]
sel <- donnees_datatable[, .SD, .SDcols = -cols]
sel <- donnees_datatable[, .SD, .SDcols = -patterns("^note")]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner l'ensemble des variables numériques de la base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Colonnes;set donnees_sas (keep = _numeric_);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
varNumeriques <- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sel <- donnees_datatable[, .SD, .SDcols = is.numeric]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner l'ensemble des variables de format "Date"

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " "
  from Var where format not in ("$", "");
run;
data Colonnes;set donnees_sas (keep = &nom_col.);run;
proc datasets lib = Work nolist;delete Var;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_dates <- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]
var_dates <- Filter(is.Date, donnees_rbase)
# Tidyverse : pull(): Pull out a single variable
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_dates <- donnees_datatable[, .SD, .SDcols = is.Date]
# Tidyverse : pull(): Pull out a single variable
# Sélection de lignes
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélectionner des lignes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 3e ligne */
data Ligne3;set donnees_sas (firstobs = 3 obs = 3);run;
/* Sélection des 3 premières lignes et des 3 premières colonnes de la base */
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " " from Var
  where 1 <= varnum <= 3;
run;
data Top3;set donnees_sas (firstobs = 1 obs = 3 keep = &nom_col.);run;
proc datasets lib = Work nolist;delete Var;run;
/* Sélection de lignes */
/* Entrées en 2023 */
data En2023;set donnees_sas (where = (year(date_entree) = 2023));run;
data Avant2023_femme;set donnees_sas (where = (year(date_entree) < 2023 and sexe = 2));run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sélection des 3 premières lignes et des 3 premières colonnes de la base
top3 <- donnees_rbase[1:3, 1:3]
# 3e ligne
ligne3 <- donnees_rbase[3, ]
# Sélection de lignes
# Entrées en 2023
# ATTENTION, solution qui ne fonctionne pas toujours bien ! En effet, les valeurs manquantes sont sélectionnées !
en2023 <- donnees_rbase[lubridate::year(donnees_rbase$date_entree) == 2023, ]
# Bonnes écritures, qui excluent les valeurs manquantes
en2023 <- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% c(2023), ]
en2023 <- donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == 2023), ]
en2023 <- subset(donnees_rbase, lubridate::year(donnees_rbase$date_entree) == 2023)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
top3 <- donnees_datatable[1:3, 1:3]
# 3e ligne
ligne3 <- donnees_datatable[3, ]
ligne3 <- donnees_datatable[3]
# Sélection de lignes
# Entrées en 2023
# Pas de problème avec les valeurs manquantes comme pour la syntaxe en R-Base
en2023 <- donnees_datatable[lubridate::year(date_entree) == 2023, ]
en2023 <- donnees_datatable[lubridate::year(date_entree) == 2023]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélection sur de multiples conditions

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Ecriture incorrecte. Les valeurs manquantes sont considérées comme des nombres négatifs faibles, et inférieurs à 2023. */
/* Ils sont sélectionnés dans le code suivant : */
data Avant2023_Femme;
  set donnees_sas (where = (year(date_entree) < 2023 and sexe = 2));
run;
/* Ecriture correcte */
data Avant2023_Femme;
  set donnees_sas (where = (year(date_entree) < 2023 and not missing(date_entree) and sexe = 2));
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
avant2023_femme <- subset(donnees_rbase, lubridate::year(date_entree) < 2023 & sexe == "2")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
avant2023_femme <- donnees_datatable[lubridate::year(date_entree) < 2023 & sexe == "2"]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélection de ligne par référence : lignes de l'identifiant 087

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant;
%let sel = 087;
data Selection;set donnees_sas;
  if &var. in ("&sel.");
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
sel <- "087"
donnees_rbase[donnees_rbase[, var] %in% sel, ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
sel <- "087"
donnees_datatable[donnees_datatable[[var]] %chin% sel, ]
donnees_datatable[donnees_datatable[[var]] %chin% sel, ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélection de lignes et de variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let cols = identifiant note_contenu sexe;
data Femmes;set donnees_sas (where = (Sexe = 2) keep = &cols.);run;
data Femmes;set donnees_sas;if Sexe = 2;keep &cols.;run;
/* Par nom ou par variable */
%let var = identifiant Sexe note_contenu;
data Femmes;
  /* Sélection de colonnes */
  set donnees_sas (keep = &var.);
  /* Sélection de lignes respectant une certaine condition */
  if Sexe = "2";
  /* Création de colonne */
  note2 = note_contenu / 20 * 5;
  /* Suppression de colonnes */
  drop Sexe;
  /* Selection de colonnes */
  keep identifiant Sexe note_contenu;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe", "date_naissance")
femmes <- donnees_rbase[donnees_rbase$sexe %in% c("2"), cols]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe", "date_naissance")
femmes <- donnees_datatable[sexe == "2", ..cols]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Manipuler des lignes et des colonnes

## Renommer des variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data donnees_sas;
  set donnees_sas (rename = (sexe = sexe2));
  rename sexe2 = sexe;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On renomme la variable sexe en sexe_red
names(donnees_rbase)[names(donnees_rbase) == "sexe"] <- "sexe_red"
# On la renomme en sexe
names(donnees_rbase)[names(donnees_rbase) == "sexe_red"] <- "sexe"
# Tidyverse : rename(): Rename variables by name
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On renomme la variable sexe en sexe_red
names(donnees_datatable)[names(donnees_datatable) == "sexe"] <- "sexe_red"
# On la renomme en sexe
names(donnees_datatable)[names(donnees_datatable) == "sexe_red"] <- "sexe"
# Autre solution
# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.
# Ceci est plus efficace pour manipuler des données volumineuses.
setnames(donnees_datatable, "sexe", "sexe_red")
setnames(donnees_datatable, "sexe_red", "sexe")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Formater les modalités des valeurs

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Utilisation des formats */
proc format;
  /* Variable discrète */
  value sexef
  1 = "Homme"
  2 = "Femme";
  /* Variable continue */
  value agef
  low-<26 = "1. De 15 à 25 ans"
  26<-<50 = "2. De 26 à 49 ans"
  50-high = "3. 50 ans ou plus";
  /* Variable caractère */
  value $ cspf
  '1' = "Cadre"
  '2' = "Profession intermédiaire"
  '3' = "Employé"
  '4' = "Ouvrier"
  '5' = "Retraité";
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sexef <- c("1" = "Homme", "2" = "Femme")
cspf <- c("1" = "Cadre", "2" = "Profession intermédiaire", "3" = "Employé", "4" = "Ouvrier", "5" = "Retraité")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sexeform <- c("1" = "Homme", "2" = "Femme")
cspform <- c("1" = "Cadre", "2" = "Profession intermédiaire", "3" = "Employé", "4" = "Ouvrier", "5" = "Retraité")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Utiliser les formats

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data donnees_sas;
  set donnees_sas;
  /* Exprimer dans le format sexef (Hommes / Femmes) */
  format Sexef $25.;
  Sexef = put(Sexe, sexef.);
  /* On exprime la CSP en texte dans une variable CSPF avec le format */
  format CSPF $25.;
  CSPF = put(CSP, $cspf.);
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On exprime CSP et sexe en formaté
donnees_rbase$cspf <- cspf[donnees_rbase$csp]
donnees_rbase$sexef <- sexef[donnees_rbase$sexe]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On exprime CSP et sexe en formaté
donnees_datatable[, `:=` (cspf = cspform[csp], sexef = sexeform[sexe])]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Transformer le format d'une variable : put et input

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data donnees_sas;
  set donnees_sas;
  /* Transformer la variable Sexe en caractère */
  Sexe_car = put(Sexe, $1.);
  /* Transformer la variable Sexe_car en numérique */
  Sexe_num = input(Sexe_car, 1.);
  /* Transformer une date d'un format caractère à un format Date */
  format date $10.;
  date = "01/01/2000";
  format date_sas yymmdd10.;
  date_sas = input(date, ddmmyy10.);
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Transformer la variable sexe en numérique
donnees_rbase$sexe_numerique <- as.numeric(donnees_rbase$sexe)
# Transformer la variable sexe_numerique en caractère
donnees_rbase$sexe_caractere <- as.character(donnees_rbase$sexe_numerique)
# Transformer une date d'un format caractère à un format Date
donnees_rbase$date_r <- lubridate::dmy("01/01/2000")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Transformer la variable sexe en numérique
donnees_datatable[, sexe_numerique := as.numeric(sexe)]
# Transformer la variable sexe_numerique en caractère
donnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]
# Transformer une date d'un format caractère à un format Date
donnees_datatable[, date_r := lubridate::dmy("01/01/2000")]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Création et suppressions de plusieurs variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Manipulation de colonnes par référence */
data Creation;set donnees_sas;
  note_contenu2 = note_contenu / 20 * 5;
  note_formateur2 = note_formateur / 20 * 5;
  /* Suppression des variables créées */
  drop note_contenu2 note_formateur2;
run;
/* Par nom ou par variable */
%let var = identifiant Sexe note_contenu;
data Femmes;
  /* Sélection de colonnes */
  set donnees_sas (keep = &var.);
  /* Sélection de lignes respectant une certaine condition */
  if Sexe = "2";
  /* Création de colonne */
  note2 = note_contenu / 20 * 5;
  /* Suppression de colonnes */
  drop note2;
  /* Selection de colonnes */
  keep identifiant Sexe note_contenu;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$note2 <- donnees_rbase$note_contenu / 20 * 5
# Le with permet de s'affranchir des expressions "donnees_rbase$"
with(donnees_rbase, note2 <- note_contenu / 20 * 5)
donnees_rbase <- transform(donnees_rbase, note2 = note_contenu / 20 * 5)
# On ne peut pas utiliser transform pour des variables récemment créées
#donnees_rbase <- transform(donnees_rbase, note3 = note_contenu ** 2, note3 = log(note3))
# Suppression de variables
donnees_rbase$note2 <- NULL
# Création et suppressions de plusieurs variables
donnees_rbase <- transform(donnees_rbase, note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)
# Suppression des variables créées
var <- c("note_contenu2", "note_formateur2")
donnees_rbase[, var] <- NULL
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Création de variables
donnees_datatable[, note2 := note_contenu / 20 * 5]
# Suppression de variables
donnees_datatable[, note2 := NULL]
# Création et suppressions de plusieurs variables
donnees_datatable[, c("note_contenu2", "note_formateur2") := list(note_contenu / 20 * 5, note_formateur / 20 * 5)]
donnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]
# Suppression des variables créées
donnees_datatable[, c("note_contenu2", "note_formateur2") := NULL]
# Ou par référence extérieure
var <- c("note_contenu2", "note_formateur2")
donnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]
donnees_datatable[, (var) := NULL]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## On souhaite réexprimer toutes les notes sur 100 et non sur 20

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;
/* On supprime d'abord les doubles blancs entre les variables */
%let notes = %sysfunc(compbl(&notes.));
/* on affiche les notes dans la log de SAS */
%put &notes;
/* 1ère solution : avec les array */
/* Les variables sont modifiées dans cet exemple */
data Sur100_1;
  set donnees_sas;
  array variables (*) &notes.;
  do increment = 1 to dim(variables);
    variables[increment] = variables[increment] / 20 * 100;
  end; 
  drop increment;
run;
/* 2e solution : avec une macro */
/* De nouvelles variables sont ajoutées dans cet exemple */
data donnees_sas;
  set donnees_sas;
  %macro Sur100;
    %do i = 1 %to %sysfunc(countw(&notes.));
	  %let note = %scan(&notes., &i.);
	  &note._100 = &note. / 20 * 100;
	%end;
  %mend Sur100;
  %Sur100;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
notes <- names(donnees_rbase)[grepl("^note", names(donnees_rbase))]
# Les variables sont modifiées dans cet exemple
sur100 <- donnees_rbase[, notes] / 20 * 100
# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100
donnees_rbase[, paste0(notes, "_100")] <- donnees_rbase[, notes] / 20 * 100
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
notes <- names(donnees_datatable)[grepl("^note", names(donnees_datatable))]
# Les variables sont modifiées dans cet exemple
sur100 <- copy(donnees_datatable)
sur100 <- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]
sur100 <- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SD = notes]
# Ou encore, plus simple
# Dans cet exemple, les notes dans la base donnees_datatable ne sont pas changées
sur100 <- sur100[, lapply(.SD, function(x) x / 20 * 100), .SDcols = patterns("^note")]
# On  souhaite conserver les notes sur 20 dans d'autres variables, suffixées par _20
donnees_datatable[, (paste0(notes, "_100")) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Création de variables avec des conditions

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Civilite;set donnees_sas;
  /* 1ère solution */
  format Civilite $20.;
  if      Sexe = 2 then Civilite = "Mme";
  else if Sexe = 1 then Civilite = "Mr";
  else                  Civilite = "Inconnu";
  /* 2e solution (do - end) */
  if      Sexe = 2 then do;
    Civilite2 = "Femme";
  end;
  else if Sexe = 1 then do;
    Civilite2 = "Homme";
  end;
  else do;
    Civilite2 = "Inconnu";
  end;
  /* 3e solution */
  format Civilite3 $20.;
  select;
    when      (Sexe = 2) Civilite3 = "Femme";
    when      (Sexe = 1) Civilite3 = "Homme";
    otherwise            Civilite3 = "Inconnu";
  end;
  keep Sexe Civilite Civilite2 Civilite3;run;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$civilite <- ifelse(donnees_rbase$sexe == "2", "Mme", 
                           ifelse(donnees_rbase$sexe == "1", "M", 
                                  "Inconnu"))
# Autre solution
donnees_rbase$civilite <- "Inconnu"
donnees_rbase$civilite[donnees_rbase$sexe == "1"] <- "M"
donnees_rbase$civilite[donnees_rbase$sexe == "2"] <- "Mme"
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, civilite := fcase(sexe == "2", "Mme",
                                      sexe == "1", "M.",
                                      is.na(sexe), "Inconnu")]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Manipuler les dates

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */
%let sixmois = %sysevalf(365.25/2);
%put sixmois : &sixmois.;
data donnees_sas;
  set donnees_sas;
  /* Âge à l'entrée dans le dispositif */
  Age = intck('year', date_naissance, date_entree);
  /* Âge formaté */
  Agef = put(Age, agef.);
  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */
  format date_sortie ddmmyy10.;
  date_sortie = intnx('day', date_entree, duree);  
  /* Deux manières de créer une indicatrice 0/1 */
  /* La date de sortie est après le 31 décembre de l'année */
  if date_sortie > "31dec&an."d then apres_31_decembre = 1;else apres_31_decembre = 0;
  /* Ou alors */
  apres_31_decembre = (date_sortie > "31dec&an."d);
  /* La durée du contrat est-elle inférieure à 6 mois ? */
  Duree_Inf_6_mois = (Duree < &sixmois. & Duree ne .);
  /* Deux manières de créer une date */
  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;
  Decembre_31_&an._a = "31dec&an."d;
  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */
  Decembre_31_&an._b = mdy(12, 31, &an.); 
  /* Date 6 mois après la sortie */
  format Date_6mois ddmmyy10.;
  Date_6mois = intnx('month', date_sortie, 6);
run;
/* Ventilation pondérée (cf. infra) */
proc freq data = donnees_sas;tables apres_31_decembre;weight poids_sondage;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Âge à l'entrée dans le dispositif
donnees_rbase$age <- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), "years"))
# Âge formaté
donnees_rbase$agef[donnees_rbase$age < 26]                     <- "1. De 15 à 25 ans"
# 26 <= donnees_rbase$age < 50 ne fonctionne pas, il faut passer en 2 étapes
donnees_rbase$agef[26 <= donnees_rbase$age & donnees_rbase$age < 50] <- "2. De 26 à 49 ans"
donnees_rbase$agef[donnees_rbase$age >= 50]                    <- "3. 50 ans ou plus"
# Autre solution
# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[
agef <- cut(donnees_rbase$age, 
            breaks = c(0, 25, 49, Inf),
            right = TRUE,
            labels = c("1. De 15 à 25 ans", "2. De 26 à 49 ans", "3. 50 ans ou plus"), 
            ordered_result = TRUE)
# Manipuler les dates
sixmois <- 365.25/2
# La durée du contrat est-elle inférieure à 6 mois ?
donnees_rbase$duree_inf_6_mois <- ifelse(donnees_rbase$duree < sixmois, 1, 0)
# Date de sortie du dispositif
donnees_rbase$date_sortie <- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)
# La date de sortie est après le 31 décembre de l'année
apres_31_decembre <- ifelse(donnees_rbase$date_sortie > as.Date(paste0(annee,"-12-31")), 1, 0)
with(donnees_rbase, sum(apres_31_decembre * poids_sondage, na.rm = TRUE) / sum(poids_sondage, na.rm = TRUE)) * 100
# Pour créer une date
as.Date(paste0(annee,"-12-31"))
lubridate::ymd(paste0(annee,"-12-31"))
# Date 6 mois après la sortie
donnees_rbase$date_6mois <- donnees_rbase$date_sortie + lubridate::month(6)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Âge à l'entrée dans le dispositif
donnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), "years"))]
# Âge formaté
donnees_datatable[, agef := fcase(age < 26,             "1. De 15 à 25 ans",
                                  26 <= age & age < 50, "2. De 26 à 49 ans",
                                  age >= 50,            "3. 50 ans ou plus")]
# Manipuler les dates
sixmois <- 365.25/2
# La durée du contrat est-elle inférieure à 6 mois ?
donnees_datatable[, duree_inf_6_mois := ifelse(duree >= sixmois, 1, 0)]
donnees_datatable[, duree_inf_6_mois := fcase(duree >= sixmois, 1,
                                              duree <  sixmois, 0)]
# Date de sortie du dispositif
donnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]
# La date de sortie est après le 31 décembre de l'année
donnees_datatable[, apres_31_decembre := fcase(date_sortie >  as.Date(paste0(annee,"-12-31")), 1,
                                               date_sortie <= as.Date(paste0(annee,"-12-31")), 0)]
donnees_datatable[, sum(apres_31_decembre * poids_sondage, na.rm = TRUE) / sum(poids_sondage, na.rm = TRUE) * 100]
# Pour créer une date
as.Date(paste0(annee,"-12-31"))
lubridate::ymd(paste0(annee,"-12-31"))
# Date 6 mois après la sortie
donnees_datatable[, date_6mois := date_sortie + lubridate::month(6)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Mettre un 0 devant un nombre

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Zero_devant;set donnees_sas (keep = date_entree);
  /* Obtenir le mois et la date */
  Mois = month(date_entree);
  Annee = year(date_entree);
  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois <= 9) : format prédéfini z2. */
  Mois_a = put(Mois, z2.);
  drop Mois;
  rename Mois_a = Mois;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Obtenir le mois et la date
donnees_rbase$mois <- lubridate::month(donnees_rbase$date_entree)
donnees_rbase$annee <- lubridate::year(donnees_rbase$date_entree)
# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois <= 9)
donnees_rbase$mois <- sprintf("%02d", donnees_rbase$mois)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Obtenir le mois et la date
donnees_datatable[, `:=`(mois = lubridate::month(date_entree), annee = lubridate::year(donnees_datatable$date_entree))]
# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois <= 9)
donnees_datatable[, mois := sprintf("%02d", mois)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Arrondir une valeur numérique

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Arrondis;set donnees_sas (keep = poids_sondage);
  /* Arrondi à l'entier le plus proche */
  poids_arrondi_0 = round(poids_sondage);
  /* Arrondi à 1 chiffre après la virgule */
  poids_arrondi_1 = round(poids_sondage, 0.1);
  /* Arrondi à 2 chiffre après la virgule */
  poids_arrondi_2 = round(poids_sondage, 0.2);
  /* Arrondi à l'entier inférieur */
  poids_inf = floor(poids_sondage);
  /* Arrondi à l'entier supérieur */
  poids_sup = ceil(poids_sondage);  
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Arrondi à l'entier le plus proche
poids_arrondi_0 <- round(donnees_rbase$poids_sondage, 0)
# Arrondi à 1 chiffre après la virgule
poids_arrondi_1 <- round(donnees_rbase$poids_sondage, 1)
# Arrondi à 2 chiffre après la virgule
poids_arrondi_2 <- round(donnees_rbase$poids_sondage, 2)
# Arrondi à l'entier inférieur
poids_inf <- floor(donnees_rbase$poids_sondage)
# Arrondi à l'entier inférieur
poids_inf <- ceiling(donnees_rbase$poids_sondage)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Arrondi à l'entier le plus proche
donnees_datatable[, poids_arrondi_0 := round(poids_sondage, 0)]
# Arrondi à 1 chiffre après la virgule
donnees_datatable[, poids_arrondi_1 := round(poids_sondage, 1)]
# Arrondi à 2 chiffre après la virgule
donnees_datatable[, poids_arrondi_2 := round(poids_sondage, 2)]
# Arrondi à l'entier inférieur
donnees_datatable[, poids_inf := floor(poids_sondage)]
# Arrondi à l'entier supérieur
donnees_datatable[, poids_sup := ceiling(poids_sondage)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Les tris

## Trier les colonnes de la base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On met identifiant, date_entree et date_sortie au début de la base */
%let colTri = identifiant date_entree;
data donnees_sas;
  retain &colTri.;
  set donnees_sas;
run;
/* Autre solution */
proc sql;
  create table donnees_sas as
  /* Dans la proc SQL, les variables doivent être séparées par des virgules */
  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */
  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from donnees_sas;
quit;
/* Mettre la variable poids_sondage au début de la base */
data donnees_sas;retain poids_sondage;set donnees_sas;run;
/* Mettre la variable poids_sondage à la fin de la base */
proc contents data = donnees_sas out = var;run;
proc sql noprint;
  select name into :var separated by " " from var
  where lowcase(name) ne "poids_sondage" order by varnum;
quit;
data donnees_sas;retain &var. poids_sondage;set donnees_sas;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Mettre les variables identifiant, date_entree et date_sortie au début de la base
colTri <- c("identifiant", "date_entree")
donnees_rbase <- donnees_rbase[, union(colTri, colnames(donnees_rbase))]
# Autre possibilité, plus longue !
donnees_rbase <- donnees_rbase[, c(colTri, setdiff(colnames(donnees_rbase), colTri))]
donnees_rbase <- donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]
# Mettre la variable poids_sondage au début de la base
donnees_rbase <- donnees_rbase[, c("poids_sondage", setdiff(colnames(donnees_rbase), "poids_sondage"))]
# Mettre la variable poids_sondage à la fin de la base
donnees_rbase <- donnees_rbase[, c(setdiff(colnames(donnees_rbase), "poids_sondage"), "poids_sondage")]
# Tidyverse : relocate(): Change column order
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On met identifiant date_entree et date_sortie au début
colTri <- c("identifiant", "date_entree")
tri <- union(colTri, colnames(donnees_datatable))
donnees_datatable <- donnees_datatable[, ..tri]
# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.
# Ceci est plus efficace pour manipuler des données volumineuses.
setcolorder(donnees_datatable, colTri)
# Mettre la variable poids_sondage au début de la base
setcolorder(donnees_datatable, union("poids_sondage", colnames(donnees_datatable)))
# Mettre la variable poids_sondage à la fin de la base
setcolorder(donnees_datatable, c(setdiff(colnames(donnees_datatable), "poids_sondage"), "poids_sondage"))
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Trier les lignes (par ordre décroissant

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 1ère possibilité */
proc sort data = donnees_sas;by Identifiant Date_entree;run;
/* 2e possibilité */
proc sql;
  create table Donnes as select * from donnees_sas order by Identifiant, Date_entree;
quit;
/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée */
proc sort data = donnees_sas;by Identifiant descending Date_entree;run;
proc sql;
  create table Donnes as select * from donnees_sas
  order by Identifiant, Date_entree desc;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tri par ordre croissant
# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri
# soit croissant ou décroissant
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE, decreasing = c(FALSE, TRUE), method = "radix"), ]
# Autre possibilité : - devant la variable (uniquement pour les variables numériques)
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$duree, na.last = FALSE), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tri par ordre croissant
# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri
# soit croissant ou décroissant
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.
# Ceci est plus efficace pour manipuler des données volumineuses.
setorder(donnees_datatable, "identifiant", "date_entree", na.last = FALSE)
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, 1L), na.last = FALSE)
# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)
donnees_datatable <- donnees_datatable[order(identifiant, -date_entree, na.last = FALSE)]
setorder(donnees_datatable, "identifiant", -"date_entree", na.last = FALSE)
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, -1L), na.last = FALSE)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Incidence des valeurs manquantes dans les tris

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Dans SAS, les valeurs manquantes sont considérées comme des valeurs négatives */
/* Elles sont donc situées en premier dans un tri par ordre croissant ... */
proc sort data = donnees_sas;by identifiant date_entree;run;proc print;run;
/* ... et en dernier dans un tri par ordre décroissant */
proc sort data = donnees_sas;by identifiant descending date_entree;run;proc print;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]
# SAS considère les valeurs manquantes comme des nombres négatifs faibles.
# Pour mimer le tri par ordre croissant en SAS :
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
# Pour mimer le tri par ordre décroissant en SAS :
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE, decreasing = c(FALSE, TRUE), method = "radix"), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...
donnees_datatable <- donnees_datatable[order(identifiant, date_entree)]
# SAS considère les valeurs manquantes comme des nombres négatifs faibles.
# Pour mimer le tri par ordre croissant en SAS :
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, 1L), na.last = FALSE)
# Pour mimer le tri par ordre décroissant en SAS :
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, -1L), na.last = FALSE)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Manipuler des chaînes de caractères

## Majuscule, minuscule

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Fonction tranwrd (TRANslate WoRD) */
data donnees_sas;
  set donnees_sas;
  /* Première lettre en majuscule */
  Niveau = propcase(Niveau);
  /* On transforme une chaîne de caractères en une autre (Qualifie en Qualifié) */
  Niveau = tranwrd(Niveau, "Qualifie", "Qualifié");
  /* En majuscule */
  CSP_majuscule = upcase(CSPF);
  /* En minuscule */
  CSP_minuscule = lowcase(CSPF);
  /* Nombre de caractères dans une chaîne de caractères */
  taille_id = length(identifiant);
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1ère lettre en majuscule, autres lettres en minuscule
donnees_rbase$niveau <- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))
# Le mot qualifie n'a pas d'accent : on le corrige
# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie
donnees_rbase$niveau <- gsub("[Q-q]ualifie", "Qualifié", donnees_rbase$niveau)
# En majuscule
donnees_rbase$csp_maj <- toupper(donnees_rbase$cspf)
# En minuscule
donnees_rbase$csp_min <- tolower(donnees_rbase$cspf)
# Nombre de caractères dans une chaîne de caractères
donnees_rbase$taille_id <- nchar(donnees_rbase$identifiant)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1ère lettre en majuscule, autres lettres en minuscule
donnees_datatable[, niveau := paste0(toupper(substr(niveau, 1, 1)), tolower(substr(niveau, 2, length(niveau))))]
# Le mot qualifie n'a pas d'accent : on le corrige
donnees_datatable[, niveau := gsub("Qualifie", "qualifié", donnees_datatable$niveau)]
# En majuscule
donnees_datatable[, csp_maj := toupper(cspf)]
# En minuscule
donnees_datatable[, csp_min := tolower(cspf)]
# Nombre de caractères dans une chaîne de caractères
donnees_datatable[, taille_id := nchar(identifiant)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Manipuler des chaînes de caractères

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Exemple_chaines;
  Texte = "              Ce   Texte   mériterait   d être   corrigé                  ";
  Texte1 = "Je m'appelle";
  Texte2 = "SAS";
  Texte3 = "Phrase à découper";
  /* Valeur manquante sous forme caractère */
  Texte4 = "";
run;
data Exemple_chaines;set Exemple_chaines;
  /* Enlever les blancs au début et à la fin de la chaîne de caractère */
  Enlever_Blancs_Initiaux = strip(Texte);
  /* Enlever les doubles blancs dans la chaîne de caractères */
  Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);
  /* Enlever doubles blancs */
  /* REVOIR !!!!! */
  Enlever_Doubles_Blancs = compress(Texte, "  ", "t");
  /* Trois méthodes pour concaténer des chaînes de caractères */
  Concatener  = Texte1||" "||Texte2;
  Concatener2 = Texte1!!" "!!Texte2;
  Concatener3 = catx(" ", Texte1, Texte2);
  /* Effet des valeurs manquantes */
  /* Le séparateur est enlevé lors d'une concaténation avec une chaîne de caractère vide */
  Concatener4 = catx("-", Texte4, Texte3);
  /* Extraire les 2e, 3e et 4e caractère de Concatener */
  /* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */
  extrait = substr(Concatener, 2, 3);
  /* Transformer plusieurs caractères différents */
  /* On transforme le é en e, le â en a, le î en i, ... */
  chaine = "éèêëàâçîô";
  chaine_sans_accent = translate(chaine, "eeeeaacio", "éèêëàâçîô");
run;
proc print data = Exemple_chaines;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
texte  <- "              Ce   Texte   mériterait   d être   corrigé                  "
texte1 <- "Ce texte"
texte2 <- "va être"
texte3 <- "concaténé"
# Valeur manquante sous forme caractère
texte4 <- ""
# Enlever les blancs au début et à la fin de la chaîne de caractère
# "\\s+" est une expression régulière indiquant 1 ou plusieurs espaces successifs
# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace
# trimws enlève les espaces au début et à la fin d'une chaîne de caractère 
texte <- gsub("\\s+", " ", trimws(texte))
# Concaténer des chaînes de caractères
concatene <- paste(texte1, texte2, texte3, sep = " ")
paste0(texte1, texte2, texte3)
# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant
paste(texte4, texte3, sep = "-")
# Extraire les 2e, 3e et 4e caractères de Concatener
# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère
extrait <- substr(concatene, 2, 5)
# Transformer plusieurs caractères différents
chaine <- "éèêëàâçîô"
chartr("éèêëàâçîô", "eeeeaacio", chaine)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
texte  <- "              Ce   Texte   mériterait   d être   corrigé                  "
texte1 <- "Je m'appelle"
texte2 <- "R"
# Enlever les blancs au début et à la fin de la chaîne de caractère
# "\\s+" est une expression régulière indiquant 1 ou plusieurs espaces successifs
# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace
# trimws enlève les espaces au début et à la fin d'une chaîne de caractère 
texte <- gsub("\\s+", " ", trimws(texte))
# Concaténer des chaînes de caractères
paste(texte1, texte2, sep = " ")
paste0(texte1, texte2)
# Extraire les 2e, 3e et 4e caractères de texte
# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère
extrait <- substr(texte, 2, 5)
# Transformer plusieurs caractères différents
chaine <- "éèêëàâçîô"
chartr("éèêëàâçîô", "eeeeaacio", chaine)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Découper une chaîne de caractères selon un caractère donné

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots */
data Mots;
  delim = " ";
  Texte = "Mon texte va être coupé !";
  /* Chaque mot dans une variable */
  %macro Decouper;
    %do i = 1 %to %sysfunc(countw(Texte, delim));
	  Mot&i. = scan(Texte, &i., delim);
	%end;
  %mend Decouper;
  %Decouper;
  /* Les mots empilés */
  nb_mots = countw(Texte, delim);
  do nb = 1 to nb_mots;
    mots = scan(Texte, nb, delim);
    output;
  end;
run;
proc print data = Mots;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Découper uen chaîne de caractères selon un caractère donné
# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots
chaine  <- "Mon texte va être coupé !"
unlist(strsplit(chaine, split = " "))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Découper uen chaîne de caractères selon un caractère donné
# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots
chaine  <- "Mon texte va être coupé !"
unlist(strsplit(chaine, split = " "))
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Inverser une chaîne de caractères

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Mots;
  Texte = "Mon texte va être coupé !";
  x = left(reverse(Texte));
run;
proc print data = Mots;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
inverserTexte <- function(x) {
  sapply(
    lapply(strsplit(x, NULL), rev),
    paste, collapse = "")
  }
inverserTexte(chaine)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
inverserTexte <- function(x) {
  sapply(
    lapply(strsplit(x, NULL), rev),
    paste, collapse = "")
}
inverserTexte(chaine)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Gestion par groupe

## Numéroter les lignes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data donnees_sas;set donnees_sas;
  Num_observation = _n_;
run;
/* Autre solution */
proc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;
data numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;
data _NULL_;
  set donnees_sas nobs = n;
  call symputx('nbLignes', n);
run;
%put Nombre de lignes : &nbLignes.;
/* Le merge "simple" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */
data donnees_sas;
  merge donnees_sas numLigne;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_rbase$num_observation <- row.names(donnees_rbase)
donnees_rbase$num_observation <- seq(1 : nrow(donnees_rbase))
# Numéro du contrat de chaque individu, contrat trié par date de survenue
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$un <- 1
donnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)
donnees_rbase$un <- NULL
# Autre solution
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$numero_contrat <- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))
# Autre solution : order pour éviter le as.numeric
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$numero_contrat <- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)
#https://stackoverflow.com/questions/11996135/create-a-sequential-number-counter-for-rows-within-each-group-of-a-dataframe
#https://stackoverflow.com/questions/13732062/what-are-examples-of-when-seq-along-works-but-seq-produces-unintended-results
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_datatable[, num_observation := .I]
donnees_datatable[, num_observation := seq_len(.N)]
# Numéro du contrat de chaque individu, contrat trié par date de survenue
setorder(donnees_datatable, "identifiant", "date_entree", na.last = FALSE)
donnees_datatable[, numero_contrat := rowid(identifiant)]
donnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Numéro de contrat par individu

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = donnees_sas;by identifiant date_entree;run;
/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */
options dkricond=nowarn dkrocond=nowarn;
data donnees_sas;
  set donnees_sas (drop = numero_contrat);
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;
options dkricond=warn dkrocond=warn;
/* Pour trier les colonnes */
data donnees_sas;retain identifiant date_entree numero_contrat numero_contrat;set donnees_sas;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1ère ligne par identifiant
donnees_rbase[!duplicated(donnees_rbase$identifiant), , drop = FALSE]
# Dernière ligne par identifiant
donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Extraire la 1ère ligne par identifiant
donnees_datatable[, .SD[1], by = identifiant]
# Extraire la dernière ligne par identifiant
donnees_datatable[, .SD[.N], by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu ...

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;set donnees_sas;
  by identifiant date_entree;
  Premier_Contrat = (first.identifiant = 1);
  Dernier_Contrat = (last.identifiant = 1);
  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);
run;
/* Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats */
proc sort data = donnees_sas;by identifiant date_entree;run;
/* Création de 2 bases en une seule étape */
data Premier_Contrat Dernier_Contrat;
  set donnees_sas;
  by identifiant date_entree;
  if first.identifiant then output Premier_Contrat;
  if last.identifiant then output Dernier_Contrat;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$premier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = FALSE), 1, 0)
donnees_rbase$dernier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = TRUE), 1, 0)
donnees_rbase$ni_prem_ni_der  <- ifelse(! c(!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 1, 0)
# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
premier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]
dernier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]
ni_prem_ni_der  <- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
donnees_datatable[, premier_contrat := ifelse(!duplicated(identifiant, fromLast = FALSE), 1, 0)]
donnees_datatable[, dernier_contrat := ifelse(!duplicated(identifiant, fromLast = TRUE), 1, 0)]
donnees_datatable[, ni_prem_ni_der := ifelse(! c(!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), 1, 0)]
# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
premier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = FALSE), ]
dernier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = TRUE), ]
ni_prem_ni_der  <- donnees_datatable[! (!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Les 2 premières / dernières lignes de chaque identifiant

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Les 2 premières lignes de chaque identifiant */
proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat <= 2;
quit;
/* Les 2 dernières lignes de chaque identifiant */
proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat >= count(*) - 1;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 2 premières lignes par identifiant (le premier si une seule ligne)
# Peut-on le faire en moins d'étapes ??? Avec head ?
donnees_rbase$a <- 1
donnees_rbase$numero_contrat <- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)
deux_premieres_lignes <- donnees_rbase[which(donnees_rbase$numero_contrat <= 2), ]
# REVOIR
#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]
#ind <- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
deux_premieres_lignes <- donnees_datatable[, .SD[1:2], by = identifiant]
deux_dernieres_lignes <- donnees_datatable[, .SD[.N-2:.N], by = identifiant]
# Version en R Base
#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## 2e ligne de l'individu (et rien si l'individu a 1 seule ligne)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;
data Deuxieme_Contrat;set donnees_sas;if numero_contrat = 2;run;
data Deuxieme_Contrat;set donnees_sas (where = (numero_contrat = 2));run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Avec le numéro de contrat
deuxieme_ligne <- donnees_rbase[donnees_rbase$numero_contrat == 2, ]
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
# Autre solution
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-(length(x)-1)])), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
deuxieme_ligne <- donnees_datatable[, .SD[2], by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## L'avant-dernière ligne de l'individu (et rien si l'individu a 1 seul contrat)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Nécessite d'avoir le numéro du contrat */
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat = count(*) - 1;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]
# Tidyverse
#donnees_rbase |> dplyr::group_by(identifiant) |> dplyr::slice(1:2)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[.N-1], by = identifiant]
# Tidyverse
#donnees_tidyverse |> dplyr::group_by(identifiant) |> dplyr::slice(1:2)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Sélection par groupement

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Personnes qui ont eu au moins une entrée en 2022 */
proc sql;
  select *
  from donnees_sas
  group by identifiant
  having sum(year(date_entree) = 2022) >= 1;
quit;
/* Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée */
proc sql;
  create table Qualif_Non_Qualif as
  select *
  from donnees_sas
  group by identifiant
  having sum(Niveau = "Non qualifie") >= 1 and sum(Niveau = "Non qualifie") >= 1;
quit;
/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022 */
proc sql;
  create table Deux_Contrats as
  select *
  from donnees_sas
  group by identifiant
  having count(*) = 2 and sum(year(date_entree) = 2022) >= 1;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
# Ce code ne semble possible que pour une seule variable
# Généralisable à des cas plus complexes ??
donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
qualif_non_qualif <- subset(
  transform(donnees_rbase, 
            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == "qualifie", 1, 0), na.rm = TRUE)), 
            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x != "qualifie", 1, 0), na.rm = TRUE))),
  qualif >= 1 & non_qualif >= 1)
# https://stackoverflow.com/questions/49669862/how-to-group-by-in-base-r
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022
deux_contrats <- subset(
  transform(donnees_rbase, 
            nb = ave(identifiant, identifiant, FUN = length), 
            an = ave(date_entree, identifiant, FUN = function(x) sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),
  nb == 2 & an >= 1)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
donnees_datatable[, if (sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) > 0) .SD, by = identifiant]
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
# Group by et Having de SQL
# https://github.com/Rdatatable/data.table/issues/788
# 1ère méthode
donnees_datatable[, `:=` (qualif = sum(ifelse(niveau == "Qualifié", 1, 0), na.rm = TRUE), non_qualif = sum(ifelse(niveau == "Non qualifié", 1, 0), na.rm = TRUE)),
                by = identifiant][qualif > 0 & non_qualif > 0]
# 2e méthode un peu plus simple
donnees_datatable[, `:=` (qualif = sum(niveau == "Qualifié", na.rm = TRUE), non_qualif = sum(niveau == "Non qualifié", na.rm = TRUE)), by = identifiant][qualif > 0 & non_qualif > 0]
# 3e méthode, plus simple !!
donnees_datatable[, if (sum(niveau == "Qualifié", na.rm = TRUE) > 0 & sum(niveau == "Non qualifié", na.rm = TRUE) > 0) .SD, by = identifiant]
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022
donnees_datatable[, if (.N == 2 & sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) >= 1) .SD, by = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Ajouter une colonne désignant la note moyenne de Note_Contenu par individu

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 1ère solution */
proc sort data = donnees_sas;by identifiant;run;
proc means data = donnees_sas mean noprint;
  var Note_Contenu;by identifiant;output out = Temp;
run;
data Temp;set Temp (where = (_STAT_ = "MEAN"));
  keep identifiant Note_Contenu;
  rename Note_Contenu = Note_Contenu_Moyenne;
run;
data donnees_sas;
  merge donnees_sas (in = a) Temp (in = b);
  by identifiant;
  if a;
run;
/* 2e solution : plus souple */
/* Pour supprimer la variable ajoutée lors de la 1ère solution */
data donnees_sas;set donnees_sas (drop = Note_Contenu_Moyenne);run;
proc sql;
  create table donnees_sas as select *
  from donnees_sas a left join
       (select identifiant, mean(Note_Contenu) as Note_Contenu_Moyenne
        from donnees_sas group by identifiant) b
       on a.identifiant = b.identifiant
  order by identifiant;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- transform(donnees_rbase, 
                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), 
                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))
# Tidyverse
#library(tidyverse)
#donnees_rbase <- donnees_rbase |> group_by(identifiant) |>  mutate(note_contenu_moyenne = mean(note_contenu), note_contenu_somme = sum(note_contenu))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),
                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]
# Moyenne de chaque note
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
donnees_datatable[, paste0(cols, "_m") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Variable retardée (lag)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* La date de fin du contrat précédent (lag) */
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sasBon;set donnees_sas;
  by identifiant date_entree;  
  format Date_fin_1 ddmmyy10.;
  Date_fin_1 = lag(Date_sortie);
  if first.identifiant then Date_fin_1 = .;
run;
/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */
proc sort data = donnees_sas;by identifiant date_entree;run;
data Lag_Bon;set donnees_sas (keep = identifiant date_entree date_sortie);
  format date_sortie_1 lag_faux lag_bon ddmmyy10.;
  /* Erreur */
  if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;
  /* Bonne écriture */
  date_sortie_1 = lag(date_sortie);
  if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# La date de fin du contrat précédent
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)
# Il faut soit utiliser un package, soit utiliser cette astuce
donnees_rbase$date_sortie_1 <- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])
# Peut-on aussi utiliser tail(..., -1) ?
# La date du contrat futur (lead)
donnees_rbase$date_sortie__1 <- c(donnees_rbase$date_sortie[ 2:(length(donnees_rbase$date_sortie))], as.Date(NA))
# Autres solutions
#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# La date de fin du contrat précédent
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, 1L), na.last = FALSE)
donnees_datatable[, date_sortie_1 := shift(.SD, n = 1, fill = NA, "lag"), .SDcols = "date_sortie"]
donnees_datatable[, .(date_sortie, date_sortie_1)]
# La date du contrat futur (lead)
setorderv(donnees_datatable, cols = c("identifiant", "date_entree"), order = c(1L, 1L), na.last = FALSE)
donnees_datatable[, date_sortie__1 := shift(.SD, n = 1, fill = NA, "lead"), .SDcols = "date_sortie"]
donnees_datatable[, .(date_sortie, date_sortie__1)]
# Autres solutions
#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Transposer une base

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On commence déjà par calculer un tableau croisé comptant les occurrences */
proc freq data = donnees_sas;table Sexef * cspf / out = Nb;run;
proc sort data = Nb;by cspf Sexef;run;
proc print data = Nb;run;
proc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;
data transpose;set transpose (drop = _name_ _label_);run;
proc print data = transpose;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On commence déjà par calculer un tableau croisé comptant les occurrences
# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array
nb <- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))
nb_transpose <- as.data.frame(t(nb))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Etablissement d'un tableau croisé comptant les occurrences
nb <- donnees_datatable[, .N, by = list(cspf, sexef)]
data.table::dcast(nb, cspf ~ sexef, value.var = "N")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Passer d'une base en largeur (wide) à une base en longueur (long)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On souhaite mettre les notes en ligne et non en colonne
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
wide_rbase <- aggregate(donnees_rbase[, var_notes], donnees_rbase[, "identifiant", drop = FALSE], mean, na.rm = TRUE)
long_rbase <- reshape(data = wide_rbase,
                varying = var_notes, 
                v.names = "notes",
                timevar = "type_note", 
                times = var_notes,
                new.row.names = NULL,
                direction = "long")
long_rbase <- long_rbase[order(long_rbase$identifiant), ]
row.names(long_rbase) <- NULL
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On souhaite mettre les notes en ligne et non en colonne
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
wide_datatable <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = identifiant, .SDcols = var_notes]
long_datatable <- melt(wide_datatable,
                       id.vars = c("identifiant"),
                       measure.vars = var_notes,
                       variable.name = "type_note",
                       value.name = "note")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Passer de wide à long

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On souhaite mettre les notes en ligne et non en colonne */
/* On commence par calculer les notes moyennes par identifiant */
%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;
proc sort data = donnees_sas;by identifiant;run;
proc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;
data Wide;set Temp (where = (_STAT_ = "MEAN") drop = _TYPE_ _FREQ_);
  keep identifiant &notes.;
  drop _STAT_;
run;
/* On passe de Wide à Long */
proc transpose data = Wide out = Long;by Identifiant;var &notes.;run;
data Long;set Long (rename = (_NAME_ = Type_Note COL1 = Note));run;
/* On passe de Long à Wide */
proc transpose data = Long out = Wide;by Identifiant;var Note;id Type_Note;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Passer de long à wide : on souhaite revenir à la situation initiale
wide_rbase <- reshape(long_rbase, 
                timevar = "type_note",
                idvar = c("identifiant", "id"),
                direction = "wide")
#https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
wide_datatable <- dcast(long_datatable, identifiant ~ type_note, value.var = "note")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Gestion par rangées de lignes

## Sélectionner les lignes avec au moins une note \< 10

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
data Note_Inferieure_10;
  set donnees_sas;
  %macro Inf10;
    %global temp;
	%let temp = ;
    %do i = 1 %to %sysfunc(countw(&notes.));
      %let j = %scan(&notes., &i.);
	  &j._inf_10 = (&j. < 10 and not missing(&j.));
	  %let temp = &temp. &j._inf_10;
    %end;
  %mend Inf10;
  %Inf10;
  if sum(of &temp.) >= 1;
  drop &temp.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
donnees_rbase[apply(donnees_rbase[, var_notes], 1, function(x) any(x < 10, na.rm = TRUE)), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
#donnees_datatable[donnees_datatable[apply(donnees_datatable[, var_notes], 1, function(x) any(x < 10, na.rm = TRUE)), ]
note_moins_10 <- donnees_datatable[donnees_datatable[, .I[rowSums(.SD < 10, na.rm = TRUE) >= 1], .SDcols = var_notes]]
# Autre solution
# Le Reduce(`|`, ...) permet d'appliquer la condition | (ou) à tous les élements de la ligne, qui sont une vérification d'un nb < 10
note_moins_10 <- donnees_datatable[donnees_datatable[, Reduce(`|`, lapply( .SD, `<`,  10)), .SDcols = var_notes]]
# https://arelbundock.com/posts/datatable_rowwise/
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Moyenne par ligne

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes */
%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
data donnees_sas;
  set donnees_sas;
  /* 1ère solution */
  Note_moyenne    = mean(of &notes.);
  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */
  %macro List_comprehension;
    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));
	                      %let j = %scan(&notes., &i.);
						  &j.
						 %end;);;
  %mend List_comprehension;
  %List_comprehension;
run;
/* Note moyenne (moyenne des moyennes), non pondérée et pondérée */
proc means data = donnees_sas mean;var Note_moyenne;run;
proc means data = donnees_sas mean;var Note_moyenne;weight poids_sondage;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
# apply permet d'appliquer une fonctions aux lignes (1) ou colonnes (2) d'un data.frame
donnees_rbase$note_moyenne <- apply(donnees_rbase[, notes], 1, mean, na.rm = TRUE)
# Autre possibilité
donnees_rbase$note_moyenne <- rowMeans(donnees_rbase[, notes], na.rm = TRUE)
# Note moyenne (moyenne des moyennes), non pondérée et pondérée
mean(donnees_rbase$note_moyenne, na.rm = TRUE)
weighted.mean(donnees_rbase$note_moyenne, donnees_rbase$poids_sondage, na.rm = TRUE)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- c("note_contenu","note_formateur","note_moyens","note_accompagnement","note_materiel")
# On souhaite moyenner les notes par formation
donnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]
# Manière alternative, qui ne semble pas fonctionner
#donnees_datatable[, note_moyenne := Reduce(function(...) sum(..., na.rm = TRUE), .SD),
#                  .SDcols = notes,
#                  by = 1:nrow(donnees_datatable)]
#donnees_datatable[, do.call(function(x, y) sum(x, y, na.rm = TRUE), .SD), .SDcols = notes, by = 1:nrow(donnees_datatable)]
# Note moyenne (moyenne des moyennes), non pondérée et pondérée
donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]
donnees_datatable[, weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## La note donnée est-elle supérieure à la moyenne ?

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On crée une macro-variable SAS à partir de la valeur de la moyenne */
proc sql noprint;select mean(Note_moyenne) into :moyenne from donnees_sas;quit;
data donnees_sas;set donnees_sas;
  Note_Superieure_Moyenne = (Note_moyenne > &moyenne.);
run;
proc freq data = donnees_sas;tables Note_Superieure_Moyenne;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
moyenne <- mean(donnees_rbase$note_moyenne, na.rm = TRUE)
donnees_rbase$note_superieure_moyenne <- ifelse(donnees_rbase$note_moyenne > moyenne, 1, 0)
table(donnees_rbase$note_superieure_moyenne, useNA = "always")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
moyenne <- donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]
donnees_datatable[, note_superieure_moyenne := fcase(note_moyenne >= moyenne, 1,
                                                     note_moyenne <  moyenne, 0)]
table(donnees_datatable$note_superieure_moyenne, useNA = "always")
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Moyenne par ligne

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On souhaite affecter les pondérations suivantes aux notes :
Note_Contenu : 30%, Note_Formateur : 20%, Note_Moyens : 25%, Note_Accompagnement : 15%, Note_Materiel : 10% */
/* Voici une solution possible. Une alternative intéressante serait de passer par IML (non traité ici) */
%let ponderation = 0.3 0.2 0.25 0.15 0.10;
%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
data donnees_sas;
  set donnees_sas;
  %macro Somme_pond;
    %global temp;
	%let temp = ;
    %do i = 1 %to %sysfunc(countw(&notes.));
      %let k = %scan(&notes., &i.);
	  %let l = %scan(&ponderation., &i., %str( ));
	  &k._pond = &k. * &l.;
	  %let temp = &temp. &k._pond;
	%end;
  %mend Somme_pond;
  %Somme_pond;
  Note_moyenne_pond = sum(of &temp.);
  drop &temp.;
run;
proc means data = donnees_sas mean;var Note_moyenne_pond;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On calcule de nouveau cette moyenne, mais en pondérant
# On souhaite affecter les pondérations suivantes aux notes :
# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%
notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
ponderation <- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100
sum(ponderation)
donnees_rbase$note_moyennepond <- apply(donnees_rbase[, notes], 1, function(x) weighted.mean(x, ponderation, na.rm = TRUE))
# Autre manière, en exploitant le calcul matriciel
# Ne fonctionne pas, du fait des NA
as.matrix(donnees_rbase[, notes]) %*% as.matrix(ponderation)
# Produit élément par élément
# On peut procéder par produit matriciel
as.matrix(donnees_rbase[, notes]) * matrix(t(as.matrix(ponderation)), nrow(donnees_rbase), 5)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
## On souhaite affecter les pondérations suivantes aux notes :
## note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%
notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
ponderation <- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100
donnees_datatable[, note_moyenne_pond := rowSums(mapply(FUN = `*`, .SD, ponderation), na.rm = TRUE), .SDcols = names(ponderation)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Les valeurs manquantes

## Repérer les valeurs manquantes (variables Âge et Niveau)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Missing;set donnees_sas;
  /* 1ère solution */
  if missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;
  /* 2e solution */
  if age = . or Niveau = '' then missing2 = 1;else missing2 = 0;
  keep Age Niveau Missing1 Missing2;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$manquant <- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)
# Mauvaise méthode pour repérer les valeurs manquantes
ageManquant <- donnees_rbase[donnees_rbase$age == NA,  ]
# Bonne méthode pour repérer les valeurs manquantes
ageManquant <- donnees_rbase[is.na(donnees_rbase$age), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, missing := ifelse(is.na(donnees_datatable$age) | is.na(donnees_datatable$niveau), 1, 0)]
ageManquant <- donnees_datatable[age == NA] # Faux
ageManquant <- donnees_datatable[is.na(age)] # Correct
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Incidence des valeurs manquantes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* En SAS, les valeurs manquantes sont des nombres négatifs faibles */
data Valeur_Manquante;set donnees_sas;
  /* Lorsque Age est manquant (missing), Jeune_Correct vaut 0 mais Jeune_Incorrect vaut 1 */
  /* En effet, pour SAS, un Age manquant est une valeur inférieure à 0, donc bien inférieure à 25.
     Donc la variable Jeune_Incorrect vaut bien 1 pour les âges inconnus */
  Jeune_Incorrect = (Age <= 25);
  Jeune_Correct   = (0 <= Age <= 25);
run;
proc print data = Valeur_Manquante (keep  = Age Jeune_Correct Jeune_Incorrect
                                    where = (missing(Age)));
run;
proc freq data = Valeur_Manquante;tables Jeune_Incorrect Jeune_Correct;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
mean(donnees_rbase$note_formateur)
mean(donnees_rbase$note_formateur, na.rm = TRUE)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, mean(note_formateur)]
donnees_datatable[, mean(note_formateur, na.rm = TRUE)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Remplacer toutes les valeurs numériques manquantes par 0

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On sélectionne toutes les variables numériques */
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " " from Var where format = "";
run;
data donnees_sas_sans_missing;set donnees_sas;
  %macro Missing;
    %local i var;
    %do i = 1 %to %sysfunc(countw(&nom_col.));
	  %let var = %scan(&nom_col., &i);
	  if missing(&var.) then &var. = 0;
	%end;
  %mend Missing;
  %Missing;
run;
proc datasets lib = Work nolist;delete Var;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Dans le cas des dates, la valeur manquante a été remplacée par 1970-01-01
donnees_rbase_sans_na <- donnees_rbase
donnees_rbase_sans_na[is.na(donnees_rbase_sans_na)] <- 0
# On remplace seulement les valeurs numériques par 0
donnees_rbase_sans_na <- donnees_rbase
varNumeriques <- names(donnees_rbase)[unlist(lapply(donnees_rbase, is.numeric))]
donnees_rbase_sans_na[, varNumeriques][is.na(donnees_rbase_sans_na[, varNumeriques])] <- 0
# Autre solution, avec replace
donnees_rbase_sans_na[, varNumeriques] <- lapply(donnees_rbase_sans_na[, varNumeriques], function(x) {replace(x, is.na(x), 0)})
# En data.table : https://stackoverflow.com/questions/53282404/using-data-table-to-replace-multiple-columns-on-single-condition
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable_sans_na <- copy(donnees_datatable)
setnafill(donnees_datatable[, .SD, .SDcols = is.numeric], fill = 0)
# Autre solution
donnees_datatable_sans_na <- copy(donnees_datatable)
cols <- colnames(donnees_datatable_sans_na[, .SD, .SDcols = is.numeric])
donnees_datatable_sans_na[, (cols) := lapply(.SD, function(x) ifelse(is.na(x), 0, x)), .SDcols = cols]
# Ensemble des colonnes
donnees_datatable_sans_na <- copy(donnees_datatable)
donnees_datatable_sans_na[is.na(donnees_datatable_sans_na)] <- 0
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Les doublons

## Doublons pour toutes les colonnes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 1ère méthode */
/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :derniere_var from Var
  where varnum = (select max(varnum) from Var);
quit;
proc sort data = donnees_sas;by &nom_col.;run;
data Doublons;set donnees_sas;by &nom_col.;
  if not (first.&derniere_var. and last.&derniere_var.);
run;
/* 2e méthode */
/* Dans la proc SQL, les variables doivent être séparées par des virgules */
/* On remplace donc les blancs entre les mots par des virgules pour la proc sql */
%let nom_col_sql = %sysfunc(tranwrd(&nom_col., %str( ), %str(, )));
/* On groupe par toutes les colonnes, et si on aboutit à strictement plus qu'une ligne, c'est un doublon */
proc sql;
  create table Doublons as
  select * from donnees_sas
  group by &nom_col_sql.
  having count(*) > 1;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
doublons <- donnees_rbase[duplicated(donnees_rbase), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
doublons <- donnees_datatable[duplicated(donnees_datatable), ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Doublons pour une ou plusieurs colonnes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant;
proc sort data = donnees_sas;by &var.;run;
data doublons;set donnees_sas;by &var.;if not first.&var.;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
doublons <- donnees_rbase[duplicated(donnees_rbase[, var]), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
doublons <- donnees_datatable[duplicated(donnees_datatable[, ..var]), ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Récupérer toutes les lignes pour les identifiants en doublon

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant;
proc sql;
  create table enDouble as
  select *
  from donnees_sas
  where &var. in (select &var. from donnees_sas group by &var.
                  having count(*) > 1)
  order by &var.;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
enDouble <- donnees_rbase[donnees_rbase[, var] %in% donnees_rbase[duplicated(donnees_rbase[, var]), var]]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
enDouble <- donnees_datatable[donnees_datatable[[var]] %chin% donnees_datatable[[var]][duplicated(donnees_datatable[[var]])], ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Récupérer toutes les lignes pour les identifiants sans doublon

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var = identifiant;
proc sql;
  create table enDouble as
  select *
  from donnees_sas
  where &var. not in (select &var. from donnees_sas
                      group by &var.
                      having count(*) > 1)
  order by &var.;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
enDouble <- donnees_rbase[! donnees_rbase[, var] %in% donnees_rbase[duplicated(donnees_rbase[, var]), var]]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
var <- "identifiant"
sansDouble <- donnees_datatable[! donnees_datatable[[var]] %chin% donnees_datatable[[var]][duplicated(donnees_datatable[[var]])], ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Suppression des doublons

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* 1ère méthode */
proc sort data = donnees_sas nodupkey;by _all_;run;
/* 2e méthode, avec first. et last. (cf. infra) */
/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;
proc sql noprint;select name into :nom_col separated by " " from Var order by varnum;quit;
%put Dernière variable de la base : &derniere_var.;
proc sort data = donnees_sas;by &nom_col.;run;
data sansDouble;set donnees_sas;by &nom_col.;if first.&derniere_var.;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase_sansdoublon <- donnees_rbase[! duplicated(donnees_rbase), ]
# Autre solution (équivalente à la solution first. de SAS)
donnees_rbase_sansdoublon <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]
donnees_rbase_sansdoublon <- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable <- unique(donnees_datatable)
donnees_datatable <- donnees_datatable[! duplicated(donnees_datatable), ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Suppression des doublons pour une seule variable

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = donnees_sas;by _all_;run;
data sansDouble;set donnees_sas;by _all_;if first.identifiant;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase_sansdoublon <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]
donnees_rbase_sansdoublon <- donnees_rbase_sansdoublon[!duplicated(donnees_rbase_sansdoublon$identifiant), , drop = FALSE]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
setorderv(donnees_datatable, cols = colnames(donnees_datatable), na.last = FALSE)
sansDouble <- donnees_datatable[! duplicated(donnees_datatable[, c("identifiant")]), ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Identifiants uniques

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sql;create table id as select distinct identifiant from donnees_sas order by identifiant;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
unique(donnees_rbase["identifiant"])
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
unique(donnees_datatable[, "identifiant"])
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Nombre de lignes uniques, sans doublon

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;select name into :nom_col separated by ", " from Var order by varnum;quit;
proc sql;
  select count(*) as Nb_Lignes_Uniques
  from (select &nom_col., count(*) from donnees_sas group by &nom_col.);
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
length(unique(donnees_rbase))
# Tidyverse : distinct(): Select distinct/unique rows
#https://sparkbyexamples-com.cdn.ampproject.org/v/s/sparkbyexamples.com/r-programming/remove-duplicate-rows-in-r/amp/?amp_gsa=1&amp_js_v=a9&usqp=mq331AQIUAKwASCAAgM%3D#amp_tf=Source%C2%A0%3A%20%251%24s&aoh=17039415557934&csi=1&referrer=https%3A%2F%2Fwww.google.com&ampshare=https%3A%2F%2Fsparkbyexamples.com%2Fr-programming%2Fremove-duplicate-rows-in-r%2F
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# À FAIRE : pas sûr de moi
uniqueN(donnees_datatable)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Les jointures de bases

## Importation de bases pour les jointures

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */
data Diplome;
  infile cards dsd dlm='|';
  format Identifiant $3. Diplome $20.;
  input Identifiant $ Diplome $;
  cards;
  173|Bac
  168|Bep-Cap
  112|Bep-Cap
  087|Bac+2
  689|Bac+2
  765|Pas de diplôme
  113|Bac
  999|Bac
  554|Bep-Cap
  ;
run;
/* On suppose que l'on dispose aussi d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller */
data Entrevue;
  infile cards dsd dlm='|';
  format Identifiant $3. Date_entrevue ddmmyy10.;
  input Identifiant $ Date_entrevue ddmmyy10.;
  cards;
  173|06/08/2021
  168|17/10/2019
  087|12/06/2021
  689|28/03/2018
  099|01/09/2022
  765|01/10/2020
  ;
run;
/* On récupère un extrait de la base initiale */
data Jointure;set donnees_sas (keep = Identifiant Sexe Age date_entree date_sortie);run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes
diplome_rbase <- data.frame(identifiant = c("173", "168", "112", "087", "689", "765", "113", "999", "554"),
                      diplome = c("Bac", "Bep-Cap", "Bep-Cap", "Bac+2", "Bac+2", "Pas de diplôme", "Bac", "Bac", "Bep-Cap"))
# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller
entrevue_rbase <- data.frame(identifiant = c("173", "168", "087", "689", "099", "765"),
                       date_entrevue = c("06/08/2021", "17/10/2019", "12/06/2021", "28/03/2018", "01/09/2022", "01/10/2020"))
entrevue_rbase$date_entrevue <- lubridate::dmy(entrevue_rbase$date_entrevue)
# On récupère un extrait de la base initiale
jointure_rbase <- donnees_rbase[, c("identifiant", "sexe", "age", "date_entree", "date_sortie")]
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes
diplome_datatable <- data.table(identifiant = c("173", "168", "112", "087", "689", "765", "113", "999", "554"),
                                diplome = c("Bac", "Bep-Cap", "Bep-Cap", "Bac+2", "Bac+2", "Pas de diplôme", "Bac", "Bac", "Bep-Cap"))
# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller
entrevue_datatable <- data.table(identifiant = c("173", "168", "087", "689", "099", "765"),
                                 date_entrevue = c("06/08/2021", "17/10/2019", "12/06/2021", "28/03/2018", "01/09/2022", "01/10/2020"))
entrevue_datatable[, date_entrevue := lubridate::dmy(date_entrevue)]
# On récupère un extrait de la base initiale
jointure_datatable <- donnees_datatable[, c("identifiant", "sexe", "age", "date_entree", "date_sortie")]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Inner join : les seuls identifiants communs aux deux bases

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
proc sort data = Diplome;by identifiant;run;
proc sort data = Jointure;by identifiant;run;
data Inner_Join1;
  merge Jointure (in = a) Diplome (in = b);
  by identifiant;
  if a and b;
run;
/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
proc sql;
  create table Inner_Join2 as
  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant
  order by a.identifiant;
quit;
proc print data = Inner_Join1 (obs = 10);run;
proc sql;select count(*) from Inner_Join1;quit;
proc sql;select count(*) from Inner_Join2;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sont appariés les identifiants communs aux deux bases
innerJoin <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant")
dim(innerJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
innerJoin <- merge(jointure_datatable, diplome_datatable, by.x = "identifiant", by.y = "identifiant")
innerJoin <- jointure_datatable[diplome_datatable, nomatch = 0, on = list(identifiant == identifiant)]
innerJoin <- jointure_datatable[diplome_datatable, nomatch = 0, on = .(identifiant == identifiant)]
dim(innerJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Left join : les identifiants de la base de gauche

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
proc sort data = Diplome;by identifiant;run;
proc sort data = Jointure;by identifiant;run;
data Left_Join1;
  merge Jointure (in = a) Diplome (in = b);
  by identifiant;
  if a;
run;
/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
proc sql;
  create table Left_Join2 as
  select * from Jointure a left join Diplome b on a.identifiant = b.identifiant
  order by a.identifiant;
quit;
proc print data = Left_Join1 (obs = 10);run;
proc sql;select count(*) from Left_Join1;quit;
proc sql;select count(*) from Left_Join2;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite
leftJoin <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant", all.x = TRUE)
dim(leftJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
leftJoin <- merge(jointure_datatable, diplome_datatable, by.x = "identifiant", by.y = "identifiant", all.x = TRUE)
dim(leftJoin)
leftJoin <- diplome_datatable[jointure_datatable, on = .(identifiant == identifiant)]
dim(leftJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Right join : les identifiants de la base de droite

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
proc sort data = Diplome;by identifiant;run;
proc sort data = Jointure;by identifiant;run;
data Right_Join1;
  merge Jointure (in = a) Diplome (in = b);
  by identifiant;
  if b;
run;
/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
proc sql;
  create table Right_Join2 as
  select * from Jointure a right join Diplome b on a.identifiant = b.identifiant
  order by a.identifiant;
quit;
proc print data = Right_Join1 (obs = 10);run;
proc sql;select count(*) from Right_Join1;quit;
proc sql;select count(*) from Right_Join2;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche
rightJoin <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant", all.y = TRUE)
dim(rightJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
rightJoin <- merge(jointure_datatable, diplome_datatable, by.x = "identifiant", by.y = "identifiant", all.y = TRUE)
dim(rightJoin)
rightJoin <- jointure_datatable[diplome_datatable, on = .(identifiant == identifiant)]
dim(rightJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Full join : les identifiants des deux bases

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
proc sort data = Diplome;by identifiant;run;
proc sort data = Jointure;by identifiant;run;
data Full_Join1;
  merge Jointure (in = a) Diplome (in = b);
  by identifiant;
  if a or b;
run;
/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
proc sql;
  create table Full_Join2 as
  select coalesce(a.identifiant, b.identifiant) as Identifiant, *
  from Jointure a full outer join Diplome b on a.identifiant = b.identifiant
  order by calculated identifiant;
quit;
proc print data = Full_Join1 (obs = 10);run;
proc sql;select count(*) from Full_Join1;quit;
proc sql;select count(*) from Full_Join2;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sont appariés les identifiants des deux bases
fullJoin <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant", all = TRUE)
dim(fullJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
fullJoin <- merge(jointure_datatable, diplome_datatable, by.x = "identifiant", by.y = "identifiant", all = TRUE)
dim(fullJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Jointure de 3 bases ou plus en une seule opération (inner join)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = Jointure;by identifiant;run;
proc sort data = Diplome;by identifiant;run;
proc sort data = Entrevue;by identifiant;run;
data Inner_Join3;
  merge Jointure (in = a) Diplome (in = b) Entrevue (in = c);
  by identifiant;
  if a and b and c;
run;
/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
proc sql;
  create table Inner_Join4 as
  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant
                           inner join Entrevue c on a.identifiant = c.identifiant
  order by a.identifiant;
quit;
proc print data = Inner_Join4 (obs = 10);run;
proc sql;select count(*) from Inner_Join3;quit;
proc sql;select count(*) from Inner_Join4;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Via un inner join
# Utilisation de la fonction Reduce
# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction
innerJoin2 <- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = "identifiant", by.y = "identifiant"),
                     list(jointure_rbase, diplome_rbase, entrevue_rbase))
dim(innerJoin2)
# Tidyverse
#library(purrr)
#library(dplyr)
#innerJoin2 <- list(jointure_rbase, diplome_rbase, entrevue_rbase) |> purrr::reduce(dplyr::left_join, all = TRUE, by.x = "identifiant", by.y = "identifiant")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Utilisation de la fonction Reduce : elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction
innerJoin2 <- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = "identifiant", by.y = "identifiant"),
                    list(jointure_datatable, diplome_datatable, entrevue_datatable))
# Tidyverse
dim(innerJoin2)
#library(purrr)
#library(dplyr)
#innerJoin2 <- list(jointure, diplome, entrevue) |> purrr::reduce(dplyr::left_join, all = TRUE, by.x = "identifiant", by.y = "identifiant")
# JOINDRE PLUSIEURS BASES
#https://stackoverflow.com/questions/32066402/how-to-perform-multiple-left-joins-using-dplyr-in-r
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Jointure sur inégalités

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On associe l'entrevue au contrat au cours duquel elle a eu lieu */
proc sql;
  create table Inner_Join_Inegalite as
  select *
  from Jointure a inner join Entrevue b
       on a.identifiant = b.identifiant and a.date_entree <= b.date_entrevue <= a.date_sortie
  order by a.identifiant;
quit;
proc print data = Inner_Join_Inegalite (obs = 10);run;
proc sql;select count(*) from Inner_Join_Inegalite;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ne semble pas natif en R-Base.
# Une proposition indicative où on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...
innerJoinInegalite <- merge(jointure_rbase, entrevue_rbase, by = "identifiant")
innerJoinInegalite <- with(innerJoinInegalite,
                           innerJoinInegalite[which(date_entree <= date_entrevue & date_entrevue <= date_sortie), ])
dim(innerJoinInegalite)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Attention, l'ordre des conditions doit correspondre à l'ordre des bases dans la jointure !
# Il semble que l'on soit forcé de spécifier tous les noms des colonnes, et ce qui est un peu problématique ...
# À FAIRE : Peut-on faire plus simplement ??
innerJoinInegalite <- jointure_datatable[entrevue_datatable,
                                         .(identifiant, sexe, age, date_entree, date_sortie, date_entrevue),
                                         on = .(identifiant, date_entree <= date_entrevue, date_sortie >= date_entrevue),
                                         nomatch = 0L
                                         ][order(identifiant)]
dim(innerJoinInegalite)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sql;
  create table CrossJoin as
  select *
  from (select distinct CSPF from donnees_sas)  cross join
       (select distinct Sexef from donnees_sas) cross join
       (select distinct Diplome from Diplome)
  order by CSPF, Sexef, Diplome;
quit;
proc sql;select count(*) from CrossJoin;quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Toutes les combinaisons possibles de CSP, sexe et diplome
crossJoin <- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))
colnames(crossJoin) <- c("cspf", "sexef", "diplome")
dim(crossJoin)
# Autre solution
crossJoin2 <- unique(merge(donnees_rbase[, c("cspf", "sexef")], diplome_rbase[, "diplome"], by = NULL))
dim(crossJoin2)
# https://stackoverflow.com/questions/10600060/how-to-do-cross-join-in-r
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
crossJoin <- data.table::CJ(donnees_datatable$cspf, donnees_datatable$sexef, diplome_datatable$diplome, unique = TRUE)
colnames(crossJoin) <- c("cspf", "sexef", "diplome")
dim(crossJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Juxtaposer côte à côte deux bases de données

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On va ajouter le numéro de la ligne */
proc sql noprint;select count(*) into :tot from donnees_sas;run;
data Ajout;do Num_ligne = 1 to &tot.;output;end;run;
/* Le merge sans by va juxtaposer côte à côte les bases */
data Concatener;merge Ajout donnees_sas;run;
/* Si l'une des bases comprend plus de ligne que l'autre, ajout d'une ligne de valeurs manquantes */
proc sql noprint;select count(*) + 1 into :tot from donnees_sas;run;
data Ajout;do Num_ligne = 1 to &tot.;output;end;run;
data Concatener;merge Ajout donnees_sas;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va ajouter le numéro de la ligne
# cbind si les deux bases comprennent le même nombre de lignes
ajout <- data.frame(num_ligne = seq_len(nrow(donnees_rbase)))
concatener <- cbind(ajout, donnees_rbase)
# Erreur si l'une des bases comprend plus de lignes que l'autre
ajout <- data.frame(num_ligne = seq_len(nrow(donnees_rbase) + 1))
# donnees_rbase_ajout <- cbind(ajout, donnees_rbase)
# Proposition de solution
cbind_alt <- function(liste) {
  # Nombre maximal de colonnes dans la liste de dataframes
  maxCol <- max(unlist(lapply(liste, nrow)))
  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum
  res <- lapply(liste, function(x) {
    for (i in seq_len(maxCol - nrow(x))) {
      x[nrow(x) + i, ] <- NA
    }
    return(x)
  })
  # On joint les résultats
  return(do.call(cbind, res))
}
concatener <- cbind_alt(list(ajout, donnees_rbase))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va ajouter le numéro de la ligne
# data.frame::cbind si les deux bases comprennent le même nombre de lignes
ajout <- data.table(num_ligne = seq_len(nrow(donnees_datatable)))
concatener <- cbind(ajout, donnees_datatable)
# Fonctionne aussi avec des bases comportement un nombre différent de lignes
# Mais attention, le résultat n'est pas le même que sur SAS, il y a recycling
ajout <- data.table(num_ligne = seq_len(nrow(donnees_datatable) + 1))
concatener <- cbind(ajout, donnees_datatable)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Empiler deux bases de données

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On va empiler la somme des notes en dessous de la base des notes */
%let var = Identifiant Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
/* On sélectionne un nombre réduit de variables pour simplifier l'exemple */
%let var2 = %sysfunc(tranwrd(&var., Identifiant,));
data Notes;set donnees_sas (keep = &var.);run;
/* Moyenne des notes */
proc means data = Notes noprint mean;var &var2.;output out = Ajout mean = &var2.;run;
/* On concatène avec les données. Valeur manquante si les variables ne correspondent pas */
/* L'instruction set permet de concaténer les bases */
data Empiler;set Notes Ajout (drop = _type_ _freq_);run;
/* Autre solution, proc append */
data Empiler;set Notes;run;
proc append base = Empiler data = Ajout force;run;
/* On renomme la ligne des moyennes ajoutée */
data Empiler;
  set Empiler nobs = nobs;
  if _N_ = nobs then Identifiant = "Moyenne";
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va empiler la somme des notes en dessous de la base des notes
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
# Moyenne des notes
moyennes <- data.frame(t(colMeans(donnees_rbase[, var_notes], na.rm = TRUE)))
# On sélectionne la base des notes
notes <- donnees_rbase[, var_notes]
# rbind lorsque les bases empilées ont le même nombre de colonne
empiler <- rbind(notes, moyennes)
# Mais, ne fonctionne plus si l'on concatène des bases de taille différente
notes <- donnees_rbase[, c("identifiant", var_notes)]
# Ne fonctionne pas
#empiler <- rbind(notes, moyennes)
# Une solution alternative, lorsque le nombre de colonnes diffère entre les deux bases
# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff
rbind_alt <- function(x, y) {
  rbind(data.frame(c(x, sapply(setdiff(names(y), names(x)), function(z) NA))),
        data.frame(c(y, sapply(setdiff(names(x), names(y)), function(z) NA)))
  )
  }
empiler <- rbind_alt(notes, moyennes)
empiler[nrow(empiler), "identifiant"] <- "Moyenne"
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va empiler la somme des notes en dessous de la base des notes
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
# Moyenne des notes
moyennes <- data.table(donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = var_notes])
# On sélectionne la base des notes
notes <- donnees_datatable[, mget(c("identifiant", var_notes))]
empiler <- rbindlist(list(notes, moyennes), fill = TRUE)
empiler[nrow(empiler), "identifiant"] <- "Moyenne"
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Ajouter une ligne de valeurs manquantes à une base de données

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Ajout;run;
data Ajout_Missing;set Jointure Ajout;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
ajout_na <- donnees_rbase
ajout_na[nrow(ajout_na) + 1, ] <- NA
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
ajout_na <- rbindlist(list(donnees_datatable, data.table(NA)), fill = TRUE)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Semi join

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Identifiants de la base de gauche qui ont un correspondant dans la base de droite */
proc sql;
  create table Semi_Join as select * from donnees_sas
  where Identifiant in (select distinct Identifiant from Diplome);
  select count(*) from Semi_Join;
quit;
proc sql;
  create table Semi_Join as select * from donnees_sas a
  where exists (select * from Diplome b where (a.Identifiant = b.Identifiant);
  select count(*) from Semi_Join;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Identifiants de la base de gauche qui ont un correspondant dans la base de droite
semiJoin <- donnees_rbase[donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]
dim(semiJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Identifiants de la base de gauche qui ont un correspondant dans la base de droite
semiJoin <- donnees_datatable[identifiant %in% diplome_datatable$identifiant, ]
dim(semiJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Anti join

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite */
proc sql;
  create table Anti_Join as select * from donnees_sas
  where Identifiant not in (select distinct Identifiant from Diplome);
  select count(*) from Anti_Join;
quit;
proc sql;
  create table Anti_Join as select * from donnees_sas a
  where not exists (select * from Diplome b where (a.Identifiant = b.Identifiant);
  select count(*) from Anti_Join;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite
antiJoin <- donnees_rbase[! donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]
dim(antiJoin)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite
antiJoin <- donnees_datatable[! identifiant %in% diplome_datatable$identifiant, ]
dim(antiJoin)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Autres fonctions utiles

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sql;
  /* Concaténation des identifiants */
  select Identifiant from Jointure union all
  select Identifiant from Diplome order by identifiant;
  /* Identifiants uniques des 2 bases */
  select distinct Identifiant from
  (select distinct Identifiant from Jointure union select distinct Identifiant from Diplome)
  order by identifiant;
  /* Identifiants communs des 2 bases */
  select Identifiant from Jointure intersect select Identifiant from Diplome
  order by identifiant;
  /* Identifiants dans jointure mais pas diplome */
  select distinct Identifiant from Jointure where
  Identifiant not in (select distinct Identifiant from Diplome)
  order by identifiant;
  select Identifiant from Jointure except select Identifiant from Diplome;
  /* Identifiants dans diplome mais pas jointure */
  select distinct Identifiant from Diplome
  where Identifiant not in (select distinct Identifiant from Jointure)
  order by identifiant;
  select Identifiant from Diplome except
  select Identifiant from Jointure order by identifiant;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Concaténation des identifiants
sort(c(jointure_rbase$identifiant, diplome_rbase$identifiant))
sort(union(jointure_rbase$identifiant, diplome_rbase$identifiant))
# Identifiants uniques des 2 bases
sort(unique(c(jointure_rbase$identifiant, diplome_rbase$identifiant)))
# Identifiants communs des 2 bases
sort(intersect(jointure_rbase$identifiant, diplome_rbase$identifiant))
# Identifiants dans jointure mais pas diplome
sort(setdiff(jointure_rbase$identifiant, diplome_rbase$identifiant))
# Identifiants dans diplome mais pas jointure
sort(setdiff(diplome_rbase$identifiant, jointure_rbase$identifiant))
#https://stackoverflow.com/questions/21738784/difference-between-inner-join-and-left-semi-join#:~:text=If%20there%20are%20multiple%20matching%20rows%20in%20the%20right%2Dhand,rows%20on%20the%20right%20side.
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R-Base
# Concaténation des identifiants
var <- "identifiant"
sort(c(jointure_datatable[[var]], diplome_datatable[[var]]))
sort(union(jointure_datatable[[var]], diplome_datatable[[var]]))
# Identifiants uniques des 2 bases
sort(unique(c(jointure_datatable[[var]], diplome_datatable[[var]])))
# Identifiants communs des 2 bases
fintersect(jointure_datatable[, ..var], diplome_datatable[, ..var])[order(identifiant)]
# Identifiants dans jointure mais pas diplome
fsetdiff(jointure_datatable[, ..var], diplome_datatable[, ..var])[order(identifiant)]
# Identifiants dans diplome mais pas jointure
fsetdiff(diplome_datatable[, ..var], jointure_datatable[, ..var])[order(identifiant)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Statistiques descriptives

## Moyenne d'une note

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc means data = donnees_sas mean;var note_contenu;run;
proc sql;select mean(note_contenu) from donnees_sas;run;
/* Par sélection (ici pour les seules femmes) */
proc means data = donnees_sas mean;
  var note_contenu;
  where sexef = "Femme";
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Importance du na.rm = TRUE
mean(donnees_rbase$note_contenu)
mean(donnees_rbase$note_contenu, na.rm = TRUE)
# Par sélection (ici pour les seules femmes)
with(subset(donnees_rbase, sexef == "Femme"), mean(note_contenu, na.rm = TRUE))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Importance du na.rm = TRUE
donnees_datatable[, mean(note_contenu)]
donnees_datatable[, mean(note_contenu, na.rm = TRUE)]
# Par sélection (ici pour les seules femmes)
donnees_datatable[sexef == "Femme", mean(note_contenu, na.rm = TRUE)]
donnees_datatable[sexef == "Femme", lapply(.SD, function(x) mean(x, na.rm = TRUE)), .SDcols = "note_contenu"]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Moyenne pondérée

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc means data = donnees_sas mean;
  var note_contenu;
  weight poids_sondage;
run;
/* Par sélection (ici pour les seules femmes) */
proc means data = donnees_sas mean;
  var note_contenu;where sexef = "Femme";
  weight poids_sondage;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
weighted.mean(donnees_rbase$note_contenu, donnees_rbase$poids_sondage, na.rm = TRUE)
# Autre méthode, mais attention aux NA !!
with(donnees_rbase, sum(note_contenu * poids_sondage, na.rm = TRUE) / sum((!is.na(note_contenu)) * poids_sondage, na.rm = TRUE))
# Par sélection (ici pour les seules femmes)
with(subset(donnees_rbase, sexef == "Femme"), sum(note_contenu * poids_sondage, na.rm = TRUE) / sum(poids_sondage, na.rm = TRUE))
# On peut aussi utiliser la fonction crossprod
# Mais ne fonctionne pas dans ce cas, car elle ne prend pas en compte les na.rm = TRUE
# Ne pas confondre cumprod et crossprod !!!!
with(subset(donnees_rbase, sexef == "Femme"), crossprod(note_contenu, poids_sondage) / sum(poids_sondage, na.rm = TRUE))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]
# Par sélection (ici pour les seules femmes)
donnees_datatable[sexef == "Femme", weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]
donnees_datatable[sexef == "Femme", lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)),
                  .SDcols = "note_contenu"]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Moyenne de chaque note

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
proc means data = donnees_sas mean;var &notes.;run;
/* Avec la pondération */
proc means data = donnees_sas mean;var &notes.;weight poids_sondage;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
# Plusieurs solutions
lapply(donnees_rbase[, notes], mean, na.rm = TRUE)
sapply(donnees_rbase[, notes], mean, na.rm = TRUE)
apply(donnees_rbase[, notes], 2, mean, na.rm = TRUE)
# Avec la pondération
with(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
moyennes <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = notes]
setnames(moyennes, notes, paste("Moyenne", notes, sep = "_"))
moyennes
# Avec la pondération
moyennes <- donnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), .SDcols = notes]
moyennes
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Nombreuses statistiques

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes */
/* Somme, moyenne, médiane, minimum, maximum, nombre de données */ 
proc means data = donnees_sas sum mean median min max n;var &notes.;run;
/* Notes pondérées (poids de sondage) */
proc means data = donnees_sas sum mean median min max var std n;var &notes.;weight poids_sondage;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes
sapply(donnees_rbase[, notes], function(x) c("Somme"      = sum(x, na.rm = TRUE),
                                             "Moyenne"    = mean(x, na.rm = TRUE),
                                             "Médiane"    = median(x, na.rm = TRUE),
                                             "Min"        = min(x, na.rm = TRUE),
                                             "Max"        = max(x, na.rm = TRUE),
                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données
                                             "Variance"   = var(x, na.rm = TRUE),
                                             "Ecart-type" = sd(x, na.rm = TRUE),
                                             "N"          = length(x)
))
# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse
library(collapse)
sapply(donnees_rbase[, notes], function(x) c("Somme"      = collapse::fsum(x, w = donnees_rbase$poids_sondage, na.rm = TRUE),
                                             "Moyenne"    = collapse::fmean(x, w = donnees_rbase$poids_sondage, na.rm = TRUE),
                                             "Médiane"    = collapse::fmedian(x, w = donnees_rbase$poids_sondage, na.rm = TRUE),
                                             "Min"        = collapse::fmin(x),
                                             "Max"        = collapse::fmax(x),
                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données
                                             "Variance"   = collapse::fvar(x, w = donnees_rbase$poids_sondage, na.rm = TRUE),
                                             "Ecart-type" = collapse::fsd(x, w = donnees_rbase$poids_sondage, na.rm = TRUE),
                                             "N"          = collapse::fnobs(x)
))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes
# Plusieurs statistiques
moyennes <- donnees_datatable[, lapply(.SD, function(x) c(sum(x, na.rm = TRUE),
                                                          mean(x, na.rm = TRUE),
                                                          median(x, na.rm = TRUE),
                                                          min(x, na.rm = TRUE),
                                                          max(x, na.rm = TRUE),
                                                          var(x, na.rm = TRUE),
                                                          sd(x, na.rm = TRUE),
                                                          .N)),
                              .SDcols = notes]
cbind(data.table(Nom = c("Somme", "Moyenne", "Médiane", "Min", "Max", "Variance", "Ecart_type", "N")), moyennes)
# Autre solution
StatsDesc <- function(x) {
  list(
    Variables= names(x),
    Somme = lapply(x, sum, na.rm = TRUE),
    Moyenne = lapply(x, mean, na.rm = TRUE),
    Mediane = lapply(x, median, na.rm = TRUE),
    Min = lapply(x, min, na.rm = TRUE),
    Max = lapply(x, max, na.rm = TRUE),
    Variance = lapply(x, function(x) var(x, na.rm = TRUE)),
    Ecart_type = lapply(x, sd, na.rm = TRUE),
    N = lapply(x, function(x) length(x)))
}
donnees_datatable[, StatsDesc(.SD), .SDcols = notes]
# Avec la pondération ?
# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse
# À FAIRE : y-a-t-il plus simple ???
# Est-on obligés d'utiliser systématiquement donnees_datatable$poids_sondage ?
library(collapse)
StatsDescPond <- function(x) {
  list(
    Variables= names(x),
    Somme = lapply(x, fsum, w = donnees_datatable$poids_sondage, na.rm = TRUE),
    Moyenne = lapply(x, fmean, w = donnees_datatable$poids_sondage, na.rm = TRUE),
    Mediane = lapply(x, fmedian, w = donnees_datatable$poids_sondage, na.rm = TRUE),
    Min = lapply(x, fmin),
    Max = lapply(x, fmax),
    Variance = lapply(x, function(x) fvar(x, w = donnees_datatable$poids_sondage, na.rm = TRUE)),
    Ecart_type = lapply(x, fsd, w = donnees_datatable$poids_sondage, na.rm = TRUE),
    N = lapply(x, fnobs)
  )
}
donnees_datatable[, StatsDescPond(.SD), .SDcols = notes]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Déciles et quartiles

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On calcule déjà la moyenne des notes par individu */
%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
data donnees_sas;
  set donnees_sas;
  /* 1ère solution */
  Note_moyenne    = mean(of &notes.);
  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */
  %macro List_comprehension;
    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));
	                          %let j = %scan(&notes., &i.);
						      &j.
						    %end;);;
  %mend List_comprehension;
  %List_comprehension;
run;
/* Déciles et quartiles de la note moyenne */
/* Par la proc means */
proc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3;
  var Note_moyenne;
  ods output summary = Deciles_proc_means;
run;
/* Par la proc univariate */
proc univariate data = donnees_sas;
  var Note_moyenne;
  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_; 
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# on calcule déjà la moyenne des notes par individu
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
donnees_rbase$note_moyenne <- rowMeans(donnees_rbase[, notes], na.rm = TRUE)
# Et les quantiles
quantile(donnees_rbase$note_moyenne, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# on calcule déjà la moyenne des notes par individu
notes <- c("note_contenu","note_formateur","note_moyens","note_accompagnement","note_materiel")
# On souhaite moyenner les notes par formation
donnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]
donnees_datatable[, quantile(.SD, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE), .SDcols = "note_moyenne"]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Rang de la note

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Ajouter dans la base le rang de la note par ordre décroissant */
proc rank data = donnees_sas out = donnees_sas descending;
  var note_moyenne;
  ranks rang_note_moyenne;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ajouter dans la base le rang de la note par ordre décroissant
donnees_rbase$rang_note_moyenne <- rank(donnees_rbase$note_moyenne)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ajouter dans la base le rang de la note par ordre décroissant
# Attention, en R, rank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS
# On exprime le rang par ordre décroissant, avec le - devant
donnees_datatable[, rang_note_moyenne := rank(-note_moyenne)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Tableaux de fréquence

## Tableaux de fréquence (proc freq) pour 1 variable

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc freq data = donnees_sas;
  tables Sexe CSP;
  format Sexe sexef. CSP $cspf.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableaux de fréquence (proc freq) (sans les valeurs manquantes)
table(donnees_rbase$cspf)
table(donnees_rbase$sexef)
# Pour enlever les "donnees_rbase$", on peut utiliser with pour se placer dans l'environnement de donnees_rbase
with(donnees_rbase, table(cspf))
# Pour les proportions
prop.table(table(donnees_rbase$cspf)) * 100
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)
donnees_datatable[, table(cspf) ]
donnees_datatable[, table(sexef) ]
# Pour les proportions
donnees_datatable[, prop.table(table(cspf)) ] * 100
donnees_datatable[, .(Nombre = .N, Pourcentage = .N / length(donnees_datatable[, cspf]) * 100), keyby = cspf]
donnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]
# Autre façon d'utiliser les méthodes de data.table
tab <- data.table::dcast(donnees_datatable, cspf ~ ., fun = length)
colnames(tab)[colnames(tab) == "."] <- "Nombre"
tab[, Proportion := lapply(.SD, function(col) col / sum(col) * 100), .SDcols = is.numeric]
tab
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableaux de fréquence avec les valeurs manquantes

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc freq data = donnees_sas;
  tables Sexe CSP / missing;
  format Sexe sexef. CSP $cspf.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)
table(donnees_rbase$cspf, useNA = "always")
prop.table(table(donnees_rbase$cspf, useNA = "always")) * 100
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, table(cspf, useNA = "always") ]
donnees_datatable[, prop.table(table(cspf, useNA = "always"))] * 100
donnees_datatable[, .(Nombre = .N, Pourcentage = .N / length(donnees_datatable[, cspf]) * 100), keyby = cspf]
donnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableaux de fréquence avec la pondération

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc freq data = donnees_sas;
  tables Sexe CSP / missing;
  format Sexe sexef. CSP $cspf.;
  weight poids_sondage;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
xtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE)
prop.table(xtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE) ]
donnees_datatable[, prop.table(xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE)) ]
donnees_datatable[, .(prop = sum(poids_sondage, na.rm = TRUE) / sum(donnees_datatable[, poids_sondage]) * 100), keyby = cspf]
donnees_datatable[, {tot = sum(poids_sondage, na.rm = TRUE); .SD[, .(prop = sum(poids_sondage, na.rm = TRUE) / tot * 100), by = cspf]} ] 
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableaux de contingence (proc freq) pour 2 variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc freq data = donnees_sas;
  tables Sexe * CSP / missing;
  format Sexe sexef. CSP $cspf.;
run;
/* Tableau de contingence (tableau croisé) sans les proportions lignes, colonnes et totales */
proc freq data = donnees_sas;
  tables CSP * Sexe  / missing nofreq norow nocol;
  format Sexe sexef. CSP $cspf.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableau simple
table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = "always")
# Tableau avec les sommes
addmargins(table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = "always"))
# Proportions
tab <- table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = "always")
# Proportions par case
addmargins(prop.table(tab)) * 100
# Proportions par ligne
addmargins(prop.table(tab, margin = 1)) * 100
# Proportions par colonne
addmargins(prop.table(tab, margin = 2)) * 100
# Solution alternative, sans pondération
tab <- xtabs(~ cspf + sexef, data = donnees_rbase)
tab
addmargins(prop.table(tab)) * 100
addmargins(prop.table(tab, margin = 1), margin = 2) * 100
addmargins(prop.table(tab, margin = 2), margin = 1) * 100
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableau simple
donnees_datatable[, table(cspf, sexef, useNA = "always") ]
# Tableau avec les sommes
donnees_datatable[, addmargins(table(cspf, sexef, useNA = "always")) ]
# Proportions
tab <- donnees_datatable[, table(cspf, sexef, useNA = "always") ]
# Proportions par case
addmargins(prop.table(tab)) * 100
# Proportions par ligne
addmargins(prop.table(tab, margin = 1)) * 100
# Proportions par colonne
addmargins(prop.table(tab, margin = 2)) * 100
# Solution alternative, sans pondération
tab <- donnees_datatable[, xtabs(~ cspf + sexef, data = donnees_datatable) ]
tab
addmargins(prop.table(tab)) * 100
addmargins(prop.table(tab, margin = 1), margin = 2) * 100
addmargins(prop.table(tab, margin = 2), margin = 1) * 100
# Autre façon d'utiliser les méthodes de data.table
tab_prop <- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)
# Proportion par ligne
tab_prop[, .SD / Reduce(`+`, .SD), cspf]
# Proportion par colonne
cols <- unique(donnees_datatable[, (sexef)])
tab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = cols]
# Pour avoir les sommes lignes
# À FAIRE : ne marche pas, à revoir !
#tab[, Total := rowSums(.SD), .SDcols = is.numeric]
#tab <- rbind(tab, tab[, c(cspf = "Total", lapply(.SD, sum, na.rm = TRUE)), .SDcols = is.numeric], fill = TRUE)
#tab[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]
## Pour avoir les sommes colonnes
#tab[, sum(.SD), by = 1:nrow(tab), .SDcols = is.numeric]
#tab[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]
#
## Autre solution plus pratique avec data.table
## Manipuler des formules sur R
#var <- c("cspf", "sexef")
#formule <- as.formula(paste(paste(var, collapse = " + "), ".", sep = " ~ "))
#tab_prop <- data.table::dcast(donnees_datatable, formule, fun.aggregate = length)
#colnames(tab_prop)[colnames(tab_prop) == "."] <- "total"
#tab_prop[, prop := total / sum(total)]
## Le tableau est remis sous forme croisée
#tab_prop <- dcast(tab_prop, cspf ~ sexef, value.var = c("prop"), fill = 0)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableau de contingence avec pondération

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc freq data = donnees_sas;
  tables Sexe * CSP / missing;
  format Sexe sexef. CSP $cspf.;
  weight poids_sondage;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
tab <- xtabs(poids_sondage ~ cspf + sexef, data = donnees_rbase, addNA = TRUE)
tab
addmargins(prop.table(tab)) * 100
addmargins(prop.table(tab, margin = 1), margin = 2) * 100
addmargins(prop.table(tab, margin = 2), margin = 1) * 100
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
tab <- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]
tab
addmargins(prop.table(tab)) * 100
addmargins(prop.table(tab, margin = 1), margin = 2) * 100
addmargins(prop.table(tab, margin = 2), margin = 1) * 100
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Solutions avec package R permettant de pondérer

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Sans objet pour SAS */
proc freq data = donnees_sas;
  tables Sexe * CSP / missing;
  format Sexe sexef. CSP $cspf.;
  weight poids_sondage;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS
# Package survey : permet de pondérer
# À FAIRE : ne fonctionne pas
library(survey)
tab <- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_rbase)
survey::svytable(poids_sondage ~ sexef + cspf, design = tab)
# Package descr : permet de pondérer
library(descr)
with(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))
# Package flextable : permet de pondérer
library(flextable)
flextable::proc_freq(donnees_rbase, "cspf", "sexef")
flextable::proc_freq(donnees_rbase, "cspf", "sexef", weight = "poids_sondage")
# Package procs : permet de pondérer, mais semble ne pas bien fonctionner ...
library(procs)
procs::proc_freq(donnees_rbase, tables = cspf * sexef, options = v(missing))
# Ne fonctionne pas avec le poids !!!
#procs::proc_freq(donnees_rbase, tables = cspf * sexef, weight = poids_sondage, options = v(missing))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Solutions avec package R ne permettant apparemment pas de pondérer

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Sans objet pour SAS */
proc freq data = donnees_sas;
  tables Sexe * CSP / missing;
  format Sexe sexef. CSP $cspf.;
  weight poids_sondage;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS
# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer
# Package crosstable : lui non plus ne permet pas de pondérer, apparemment ...
library(crosstable)
crosstable::crosstable(donnees_rbase, cspf, by = sexef, showNA = "always", percent_digits = 0, percent_pattern ="{n} ({p_col}/{p_row})")
# Package gmodels : ne permet pas de pondérer, apparemment
library(gmodels)
gmodels::CrossTable(donnees_rbase$cspf, donnees_rbase$sexef)
# Package gtsummary : ne permet pas de pondérer, apparemment
library(gtsummary)
# Pourcentages par case, colonne, ligne
gtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c("cell"),   margin = c("column", "row"), missing = c("always"))
gtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c("column"), margin = c("column", "row"), missing = c("always"))
gtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c("row"),    margin = c("column", "row"), missing = c("always"))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Statistiques agrégées par groupe

## Une seule variable de groupement, une seule variable

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Moyenne de note_contenu et nombre de personnes */
/* 1ère solution */
proc sort data = donnees_sas;by cspf;run;
proc means data = donnees_sas mean n;var note_contenu;class cspf;run;
/* 2e solution */
proc tabulate data = donnees_sas;
  var note_contenu;
  class cspf;
  table (cspf all = "Total"), note_contenu * (mean n);
run;
/* 3e solution */
proc sql;
  select cspf, mean(note_contenu) as note_contenu_moyenne, count(*) as N
  from donnees_sas
  group by cspf
  order by cspf;
quit;
/* Avec la pondération */
proc sort data = donnees_sas;by cspf;run;
proc means data = donnees_sas mean n;
  var note_contenu;class cspf;
  weight poids_sondage;
run;
proc tabulate data = donnees_sas;
  var note_contenu;
  class cspf;
  weight poids_sondage;
  table (cspf all = "Total"), note_contenu * (mean n);
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Moyenne de note_contenu et nombre de personnes
aggregate(note_contenu ~ cspf, donnees_rbase, function(x) c(Moyenne = mean(x, na.rm = TRUE), Nombre = length(x)))
# Moyenne de note_contenu
# Une seule variable, une seule variable de groupe, une seule fonction
aggregate(note_contenu ~ cspf, donnees_rbase, mean, na.rm = TRUE)
# rowsum, à ne pas confondre avec rowSums, calcule des sommes
rowsum(donnees_rbase$note_contenu, donnees_rbase$cspf, recorder = TRUE, na.rm = TRUE)
# Fonctions tapply et by
tapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)
with(donnees_rbase, tapply(note_contenu, cspf, mean, na.rm = TRUE))
tapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)
by(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)
# Avec la pondération : tapply ne fonctionne pas, il faut découper la base en facteurs avec split
sapply(split(donnees_rbase, donnees_rbase$cspf), function(x) weighted.mean(x$note_contenu, x$poids_sondage, na.rm = TRUE))
# À FAIRE : autre solution ?
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Moyenne de note_contenu et nombre de personnes
donnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = cspf]
donnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = "cspf"]
# Variables définies à part
var_notes <- "note_contenu"
var_groupe <- "cspf"
# À FAIRE : les deux variables sont empilées, pourquoi ??
donnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))), keyby = var_groupe,
                  .SDcols = var_notes]
# Avec la pondération
donnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), keyby = var_groupe,
                  .SDcols = var_notes]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Plusieurs variables

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let var_notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;
%let var_groupe = cspf sexef;
proc sort data = donnees_sas;by &var_groupe.;run;
proc means data = donnees_sas mean n;
  class &var_groupe.;
  var &var_notes.;
  output out = Resultat;
run;
/* Autre solution */
%macro sel;
  %global select;
  %local i j;
  %let select = ;
  %do i = 1 %to %sysfunc(countw(&var_notes.));
    %let j = %scan(&var_notes., &i., %str( ));
	%let select = &select. mean(&j) as &j._moyenne,;
  %end;
%mend sel;
%sel;
%let group = %sysfunc(tranwrd(&var_groupe., %str( ), %str(, )));
proc sql;
  select &group., &select. count(*) as N
  from donnees_sas
  group by &group.
  order by &group.;
quit;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Plusieurs solutions avec aggregate (plutôt lent)
aggregate(note_contenu ~ cspf + sexef, donnees_rbase, function(x) c(mean = mean(x), n = length(x)))
aggregate(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))
# Via les formules
var <- c("note_contenu")
varGroupement <- c("cspf", "sexef")
formule <- as.formula(paste(var, paste(varGroupement, collapse = " + "), sep = " ~ "))
aggregate(formule, donnees_rbase, function(x) list(mean = mean(x, na.rm = TRUE), n = length(x)))
# Avec by
by(donnees_rbase[, var], donnees_rbase[, varGroupement], function(x) c(mean = mean(x, na.rm = TRUE), n = length(x)))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = c("cspf", "sexef")]
# Autre solution
data.table::dcast(donnees_datatable, cspf + sexef ~ ., value.var = "note_contenu", fun.aggregate = mean, na.rm = TRUE)
# Variables définies à part
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
var_groupe <- c("cspf", "sexef")
# À FAIRE : les deux variables sont empilées, pourquoi ??
donnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))),
                  keyby = var_groupe,
                  .SDcols = var_notes]
# Nombre de femmes par CSP
# Il y a un recycling de gender = "M", utile de le mentionner
donnees_datatable[, .(Femmes = sum(sexef == "Femme", na.rm = TRUE), Hommes = sum(sexef == "Homme", na.rm = TRUE)), by = .(cspf)]
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableaux croisés à 2 variables de groupement

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc tabulate data = donnees_sas;
  class cspf sexef;
  var note_contenu;
  table (cspf all = "Ensemble"), sexef * (note_contenu) * mean;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableau croisé Cspf par Sexef
varGroupement <- c("cspf", "sexef")
var <- c("note_contenu")
# Solution avec tapply
tapply(donnees_rbase[, var], donnees_rbase[varGroupement], function(x) moyenne = mean(x, na.rm = TRUE))
# Solution avec xtabs
xtabs(note_contenu ~ cspf + sexef, aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE))
# Ou, sous forme de formule
formule <- as.formula(paste(var, paste(varGroupement, collapse = " + "), sep = " ~ "))
xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))
# Autre solution, en calculant un tableau "long", et en le transformant en "wide"
tableau <- aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE)
reshape(tableau, 
        timevar = "sexef",
        idvar = "cspf",
        direction = "wide")
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Tableau croisé Cspf par Sexef
varGroupement <- c("cspf", "sexef")
var <- "note_contenu"
data.table::dcast(donnees_datatable, cspf ~ sexef, value.var = "note_contenu", fun.aggregate = mean, na.rm = TRUE)
# Avec références seulement
data.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = var,
                  fun.aggregate = mean, na.rm = TRUE)
# Autre solution, plus indirecte
# À FAIRE : attention, toujours utiliser lapply, même avec une seule variable ! LE DIRE !!!
tab <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = varGroupement, .SDcols = "note_contenu"]
data.table::dcast(tab, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = var)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Tableaux croisés à 3 variables de groupement ou plus : 1 variable en ligne, 2 en colonne

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Notes par croisement de CSP (en ligne) et de Sexe x Niveau */
%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;
proc tabulate data = donnees_sas;
  class cspf sexef;
  var &notes.;
  table (cspf all = "Ensemble"), sexef * (&notes.) * mean;
run;
/* Note_contenu par croisement de CSP (en ligne) et de Sexe x Niveau */
proc tabulate data = donnees_sas;
  class cspf sexef Niveau;
  var note_moyenne;
  table (cspf all = "Ensemble"), (sexef * Niveau) * (note_moyenne) * mean;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
var_groupe <- c("cspf", "sexef")
tableau <- aggregate(donnees_rbase[, var_notes], donnees_rbase[var_groupe], function(x) moyenne = mean(x, na.rm = TRUE))
reshape(tableau, 
        timevar = var_groupe[2],
        idvar = var_groupe[1],
        direction = "wide")
# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée
# À FAIRE : proposer une fonction ?
formule <- as.formula("note_contenu ~ cspf + sexef + niveau")
tab <- xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))
nomsCol <- do.call(paste, c(expand.grid(dimnames(tab)[-1L]), sep = "_"))
nomsLig <- dimnames(tab)[[1L]]
# Transformation du tableau de résultats (en format array) vers un format matrix, puis dataframe
# Permet d'exprimer le array (matrice multidimensionnelle) en un tableau à deux dimensions
# On transforme le tableau en matrice ayant en nombre de lignes dim(tab)[1], c'est-à-dire le nombre de lignes du array
# et en nombre de colonnes le reste des variables
tab <- data.frame(matrix(tab, nrow = dim(tab)[1L]))
# Renommage des noms des colonnes de la base
colnames(tab) <- nomsCol
# Renommage des noms des lignes de la base
row.names(tab) <- nomsLig
# On annule les valeurs manquantes
tab[is.na(tab)] <- 0
tab
# À FAIRE : développer autour de cet exemple
# Avec 3 variables
xtabs(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase)
# En tidyverse
#library(dplyr)
#donnees_rbase |> dplyr::group_by(cspf) |> dplyr::summarise(mean = mean(note_contenu), n = n())
                                                             
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne
var_notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
var_groupe <- c("cspf", "sexef")
data.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = var_notes,
                  fun.aggregate = mean, na.rm = TRUE)
# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée
data.table::dcast(donnees_datatable, cspf ~ sexef + niveau, value.var = "note_contenu",
                  fun.aggregate = mean, na.rm = TRUE)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Macros, SAS, fonctions R

## Boucles imbriquées

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data _null_;call symput('annee', strip(year(today())));run;
/* Ensemble des premiers jours de chaque mois entre 2020 et le 31 décembre de l'année courante */
%macro Boucles_Imbriquees(an_debut, an_fin);
  %local i j;
  %global liste_mois;
  %let liste_mois = ;
  %do i = &an_debut. %to &an_fin.;
    %do j = 1 %to 12;
	  %let liste_mois = &liste_mois. %sysfunc(putn(%sysfunc(mdy(&j., 1, &i.)), ddmmyy10.));
	%end;
  %end;
%mend Boucles_Imbriquees;
%let annee = %sysfunc(year(%sysfunc(today())));
%Boucles_Imbriquees(an_debut = 2020, an_fin = &annee.);
%put &liste_mois.;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante
annee <- lubridate::year(Sys.Date())
# 1ère solution avec for (lente, à déconseiller !)
listeMois <- c()
for (i in seq(2020, annee)) {
  for (j in 1:12) {
    listeMois <- as.Date(c(listeMois, lubridate::ymd(sprintf("%02d-%02d-01", i, j))))
  }
}
# 2e  solution : 2 fonctions lapply imbriquées
listeMois <- as.Date(unlist(lapply(seq(2020, annee), function(x) lapply(1:12, function(y) lubridate::ymd(sprintf("%02d-%02d-01", x, y))))))
# 3e solution : expand.grid
listeMois <- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, function(x) lubridate::ymd(sprintf("%02d-%02d-01", x[1], x[2])))))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante
annee <- lubridate::year(Sys.Date())
# 1ère solution avec for (lente, à déconseiller !)
listeMois <- c()
for (i in seq(2020, annee)) {
  for (j in 1:12) {
    listeMois <- as.Date(c(listeMois, lubridate::ymd(sprintf("%02d-%02d-01", i, j))))
  }
}
# 2e  solution : 2 fonctions lapply imbriquées
listeMois <- as.Date(unlist(lapply(seq(2020, annee), function(x) lapply(1:12, function(y) lubridate::ymd(sprintf("%02d-%02d-01", x, y))))))
# 3e solution : expand.grid
listeMois <- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, function(x) lubridate::ymd(sprintf("%02d-%02d-01", x[1], x[2])))))
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Boucles imbriquées (second exemple)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Itérer sur toutes les années et les trimestres d'une certaine plage */
/* on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 */
%macro iteration(debut, fin);
  %global liste_an;
  %let liste_an = ;
  %do i = &debut. %to &fin.;
    %let liste_an = &liste_an.&i.-;
  %end;
%mend iteration;
%iteration(debut = 2020, fin = %sysfunc(year(%sysfunc(today()))));
%put &liste_an.;
%let liste_trim = 1 2 3 4;
%let liste_niv = max min;
/* Supposons que nous ayons des noms de fichier suffixés par AXXXX_TY_NZ, avec X l'année, Y le trimestre et
   Z max ou min. Par exemple, A2010_T2_NMax */
/* Pour obtenir l'ensemble de ces noms de 2010 à cette année */
%macro noms_fichiers(base = temp);
  %global res;
  %let res = ;
  %do j = 1 %to %sysfunc(countw(&liste_an., "-"));
    %let y = %scan(&liste_an., &j., "-"); /* année */
    %do i = 1 %to 4;
      %let t = %scan(&liste_trim, &i.); /* trimestre */
      %do g = 1 %to 2;
        %let n = %scan(&liste_niv., &g.); /* niveau */
		%let res = &res. &base._&y._t&t._n&n.;
	  %end;
	%end;
  %end;
%mend noms_fichiers;
%noms_fichiers(base = base);
%put &res.;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Itérer sur toutes les années et les trimestres d'une certaine plage
# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 
debut <- 2020
fin <- lubridate::year(Sys.Date())
res <- unlist(lapply(debut:fin, function(x) lapply(c("max", "min"), function(y)  sprintf("base_%4d_t%d_n%s", x, 1:4, y))))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Itérer sur toutes les années et les trimestres d'une certaine plage
# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 
debut <- 2020
fin <- lubridate::year(Sys.Date())
res <- unlist(lapply(debut:fin, function(x) lapply(c("max", "min"), function(y)  sprintf("base_%4d_t%d_n%s", x, 1:4, y))))
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Boucles for

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On va créer une base par année d'entrée */
proc sql noprint;
  select year(min(date_entree)), year(max(date_entree)) into :an_min, :an_max
  from donnees_sas;
quit;
%macro Base_par_mois(debut, fin);
  /* %local impose que an n'est pas de signification hors de la macro */
  %local an;
  /* %global impose que nom_bases peut être utilisé en dehors de la macro */
  %global nom_bases;
  /* On initalise la création de la macri-variable nom_bases */
  %let nom_bases = ;
  /* On itère entre &debut. et &fin. */
  %do an = &debut. %to &fin.;
    data Entree_&an.;
	  set donnees_sas;
	  if year(date_entree) = &an.;
	run;
	/* On ajoute à la macro-variable le nom de la base */
	%let nom_bases = &nom_bases. Entree_&an.;
  %end;
%mend Base_par_mois;
%Base_par_mois(debut = &an_min., fin = &an_max.);
%put &nom_bases.;
/* On va désormais empiler toutes les bases (concaténation par colonne) */
/* L'instruction set utilisée de cette façon permet cet empilement */
data concatene;
  set &nom_bases.;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va créer une base par année d'entrée
anMin <- min(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)
anMax <- max(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)
for (i in anMin:anMax) {
  # assign permet de faire passer une chaîne de caractères en variable R
  assign(paste("entree", i, sep = "_"), donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == i), ])
}
# On va désormais empiler toutes les bases (concaténation par colonne)
# do.call applique la fonction rbind à l'ensemble des bases issues du lapply
# get permet de faire le chemin inverse de assign
concatene <- do.call(rbind, lapply(paste("entree", anMin:anMax, sep = "_"), get))
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On va créer une base par année d'entrée
anMin <- min(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)
anMax <- max(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)
for (i in anMin:anMax) {
  # assign permet de faire passer une chaîne de caractères en variable R
  assign(paste("entree", i, sep = "_"), donnees_datatable[lubridate::year(donnees_datatable$date_entree) == i, ])
}
# On va désormais empiler toutes les bases (concaténation par colonne)
# do.call applique la fonction rbind à l'ensemble des bases issues du lapply
# get permet de faire le chemin inverse de assign
concatene <- rbindlist(lapply(paste("entree", anMin:anMax, sep = "_"), get))
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Boucles for (second exemple)

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On recherche toutes les valeurs de CSP différentes et on les met dans une variable.
   On appelle la proc SQL :
   - utilisation du quit et non run à la fin
   - on récupère toutes les valeurs différentes de CSP, séparés par un espace (separated by)
   - s'il y a un espace dans les noms, on le remplace par _ 
   - on les met dans la macro-variable liste_csp
   - on trier la liste par valeur de CSP */
/* On crée une variable de CSP formaté sans les accents et les espaces */
data donnees_sas;set donnees_sas;
  /* SAS ne pourra pas créer des bases de données avec des noms accentués */
  /* On supprime dans le nom les lettres accentués. On le fait avec la fonction Translate */
  CSPF2 = tranwrd(strip(CSPF), " ", "_");
  CSPF2 = translate(CSPF2, "eeeeaacio", "éèêëàâçîô");
run;
/* Boucles et macros en SAS */
/* Les boucles ne peuvent être utilisées que dans le cadre de macros */
/* Ouverture de la macro */
%macro Boucles(base = donnees_sas, var = CSPF2);
  /* Les modalités de la variable */
  proc sql noprint;select distinct &var. into :liste separated by " " from &base. order by &var.;quit;
  /* On affiche la liste de ces modalités */
  %put &liste.;
  /* %let permet à SAS d'affecter une valeur à une variable en dehors d'une manipulation de base de données */
  /* %sysfunc indique à SAS qu'il doit utiliser la fonction countw dans le cadre d'une macro (pas important) */
  /* countw est une fonction qui compte le nombre de mots (séparés par un espace) d'une chaîne de caractères */
  /* => on compte le nombre de CSP différentes */
  %let nb = %sysfunc(countw(&liste.));
  %put Nombre de modalités différentes : &nb.;
  /* On itère pour chaque CSP différente ... */
  %do i = 1 %to &nb.;
    /* %scan : donne le i-ème mot de &liste. (les mots sont séparés par un espace) */
    /* => on récupère donc la CSP numéro i */
    %let j = %scan(&liste., &i.);
	%put Variable : &j.;
	/* On crée une base avec seulement les individus de la CSP correspondante */
	data &var.;set donnees_sas;if &var. = "&j.";run;
  %end;
/* Fermeture de la macro */
%mend Boucles;
/* Lancement de la macro */
%Boucles(base = donnees_sas, var = CSPF2);
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Base par CSP
for (i in unique(donnees_rbase$cspf)) {
  # Met en minuscule et enlève les accents
  nomBase <- tolower(chartr("éèêëàâçîô", "eeeeaacio", i))
  # assign permet de faire passer une chaîne de caractères en variable R
  assign(nomBase, donnees_rbase[which(donnees_rbase$cspf == i), ])
}
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Créer une base pour chaque individu d'une certaine CSP
for (i in unique(donnees_datatable$cspf)) {
  # Met en minuscule et enlève les accents
  nomBase <- tolower(chartr("éèêëàâçîô", "eeeeaacio", i))
  # assign permet de faire passer une chaîne de caractères en variable R
  assign(nomBase, donnees_datatable[donnees_datatable$cspf == i, ])
}
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Autres transcriptions de fonctions SAS vers R

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* À FAIRE */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Mesurer la durée d'exécution d'un programme
system.time(donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ])
# En SAS : include("chemin")
# En R : source("chemin", encoding = "utf-8", echo = TRUE, max.deparse.length = 1e3)
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Mesurer la durée d'exécution d'un programme
system.time(setorder(donnees_datatable, "identifiant", "date_entree", na.last = FALSE))
# En SAS : include("chemin")
# En R : source("chemin", encoding = "utf-8", echo = TRUE, max.deparse.length = 1e3)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Débogage

## Outils d'aide au débogage

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
options symbolgen mprint mlogic;
%macro Debogage;
  %local phrase i j;
  %let phrase = Voici une phrase;
  %do i = 1 %to %sysfunc(countw(&phrase.));
    %let j = %scan(&phrase., &i.);
	%put Mot n°&i. = &j.;
  %end;
%mend Debogage;
%Debogage;
options nosymbolgen nomprint nomlogic;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
#phrase <- c("voici", "une", "phrase")
#options(error=recover)
#for (i in phrase) print(k)
#options(error=NULL)
# À FAIRE : autres outils
#traceback()
#browser()
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
#phrase <- c("voici", "une", "phrase")
#options(error=recover)
#for (i in phrase) print(k)
#options(error=NULL)
# À FAIRE : autres outils
#traceback()
#browser()
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Points de vigilance en SAS

## Emploi des guillemets et double guillemets

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Quelques points de vigilance en SAS (à ne connaître que si on est amené à modifier le programme SAS, pas utiles sinon) */
/* Double guillemets pour les macro-variables */
%let a = Bonjour;
%put '&a.'; /* Incorrect */
%put "&a."; /* Correct */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet en R
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet en R
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Macro-variable définie avec un statut global avant son appel dans le cadre d'un statut local

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%macro test;
  %let reponse = oui;
%mend test;
%test;
/* 1. Erreur car &reponse. n'est défini que dans le cas d'un environnement local */ 
%put &reponse.;
/* 2. Défini auparavant dans un environnement global, elle change de valeur à l'appel de la fonction */
%let reponse = non;
%put Reponse : &reponse.;
%test;
%put Reponse après la macro : &reponse.;
/* 3. Problème corrigé, en imposant la variable à local dans la macro */
%macro test2;
  %local reponse;
  %let reponse = oui;
%mend test2;
%let reponse = non;
%put Reponse : &reponse.;
%test2;
%put Année après la macro : &reponse.;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet en R
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Sans objet en R
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

# Fin du programme

## Taille des objets en mémoire

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Sans objet en SAS */
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Taille, en mémoire, d'une base (en Mb)
format(object.size(donnees_rbase), nsmall = 3, digits = 1, unit = "Mb")
# Taille des objets en mémoire, en Gb
sort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Taille, en mémoire, d'une base (en Mb)
format(object.size(donnees_datatable), nsmall = 3, digits = 1, unit = "Mb")
# Taille des objets en mémoire, en Gb
sort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::

## Supprimer des bases

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Supprimer une base */
proc datasets lib = work nolist;delete donnees_sas;run;
/* Supprimer toutes les bases dans la work */
proc datasets lib = work nolist kill;run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Supprimer une base
#rm(donnees_rbase)
# Supprimer toutes les bases et tous les objets de la mémoire vive
#rm(list = ls())
```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}


```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Supprimer une base
#rm(donnees_datatable)
# Supprimer toutes les bases et tous les objets de la mémoire vive
#rm(list = ls())
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```

## `polars` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}

```
:::
