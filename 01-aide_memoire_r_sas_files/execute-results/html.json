{
  "hash": "5faad35adcf6283ebac5b447da1144c3",
  "result": {
    "markdown": "---\ntitle: \"Aide-mémoire `SAS` - `R`\"\nlang : fr\nauthor:\n  - name: Nassab ABDALLAH\n    affiliation: Dares/SCS, <nassab.abdallah@travail.gouv.fr>\n  - name: Damien EUZENAT\n    affiliation: Dares/DIP, <damien.euzenat@travail.gouv.fr>\n  - name: Sébastien LI-THIAO-TE\n    affiliation: Dares/DFA, <sebastien.li-thiao-te@travail.gouv.fr>\n    \nformat:\n  html:\n    toc: true\n    toc-expand: 2\n    toc-location: left\n    number-sections: true\n    code-copy: true\n    smooth-scroll: true\n    embed-resources: true\n    link-external-icon:\ttrue\n    link-external-newwindow: true\n    page-layout: full\n    code-tools: true\n    theme:\n      light: united\n      dark: darkly\n# format : native   \neditor: source\nexecute:\n  eval: true\n\nembed-resources: true\n\nsyntax-definitions: \n  - sas.xml\n\n# Summary for listings and search engines\ndescription: |\n  Un aide-mémoire pour les statisticiens traduisant des codes standards en `SAS` et en `R`, suivant 4 environnements (`R-Base`, `Tidyverse`, `data.table`, `Arrow / DuckDb`).\n\n# Date published\ndate: \"2024-06-17\"\ndate-modified: \"05/24/2024\"\n\noutput:\n  rmdformats::robobook:\n    highlight: tango\n    number_sections: true\n  \ncategories:\n  - SAS\n  - R\n---\n\n\nL'aide-mémoire a pour but de fournir des codes écrits en `SAS` et d'en donner la traduction en `R` de différentes manières possibles :\n\n-   `base R`\n\n-   `tidyverse`\n\n-   `data.table`\n\n-   `arrow/duckdb`\n\nLes codes traduits sont typiques de la production statistique ou la réalisation d'études descriptives.\n\nCe document s'adresse notamment aux utilisateurs de `SAS` qui veulent connaître la traduction du code `SAS` en `R`, aux utilisateurs de `R` qui ont besoin de comprendre le code `SAS`, ainsi qu'aux utilisateurs d'un environnement `R` qui sont intéressés par la traduction dans un autre environnement `R`.\n\nIl se veut complémentaire de la documentation en ligne en français Utilit'R, née à l'Insee (<https://www.book.utilitr.org/>). Le lecteur est invité à s'y référer pour obtenir des informations importantes sur l'utilisation de `R` et qui ne sont pas discutées dans ce document, comme l'importation de données en `R` (<https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats>). \n\nEnfin, si vous souhaitez collaborer à cet aide-mémoire ou nous faire part de votre avis, n'hésitez pas à nous contacter via nos adresses email.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(width=130)\n```\n:::\n# Importation des packages \n\n\n\n## Importation des packages\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet pour R-Base\n\n# Cependant, on importe le package lubridate pour faciliter la gestion des dates\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n# Pour manipuler les dates\nlibrary(lubridate)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n# Chargement des packages\n# Pour manipuler les dates\nlibrary(lubridate)\n# Pour utiliser le pipe %>%\nlibrary(magrittr)\n# Le tidyverse proprement dit\nlibrary(tidyverse)\n# Les packages importés par le tidyverse sont :\n# - dplyr (manipulation de données)\n# - tidyr (réorganisation de bases de données)\n# - readr (importation de données)\n# - purrr (permet de réaliser des boucles)\n# - tibble (format de données tibble, complémentaire du data.frame)\n# - stringr (manipulation de chaînes de caractères)\n# - ggplot2 (création de graphiques)\n# - forcats (gestion des formats \"factors\")\n# Documentation de tidyverse\nvignette(\"dplyr\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\nlibrary(data.table)\n# Documentation de data.table\n?'[.data.table'\n# Pour manipuler les dates\nlibrary(lubridate)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n#library(duckdb)\n#library(arrow)\n```\n:::\n\n:::\n\n# Importation des données \n\n\n## Mode d'emploi de l'aide-mémoire\n\nLes codes informatiques sont appliqués sur une base de données illustrative fictive. Cette base est importée à cette étape. Aussi, pour répliquer les codes sur sa machine, le lecteur doit d'abord exécuter le code d'importation de la base de données ci-dessous.\n\nLes codes sont majoritairement exécutables indépendamment les uns des autres.\n\n\n## Création d'une base de données SAS d'exemple\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Données fictives sur des formations */\ndata donnees_sas;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Sexe 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n         Note_Accompagnement Note_Materiel poids_sondage 4.1 CSPF $25. Sexef $5.;\n  input Identifiant $ Sexe CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n        Note_Accompagnement Note_Materiel poids_sondage CSPF $ Sexef $;\n  cards;\n  173|2|1|Qualifié|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|01/01/2022|365|6||12|7|14|98.3|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6|Cadre|Femme\n  173|2|1|Non qualifié|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7|Cadre|Femme\n  174|1|1|Qualifié|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9|Cadre|Homme\n  175|1|1|Qualifié|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2|Cadre|Homme\n  198|2|3|Non qualifié|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3|Employé|Femme\n  168|1|2|Qualifié|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2|Profession intermédiaire|Homme\n  211|2|3|Non qualifié||17/12/2021|135|16|16|15|12|9|86.4|Employé|Femme\n  278|1|5|Qualifié|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2|Retraité|Homme\n  347|2|5|Qualifié|13/09/1955||180|12|5|7|11|12|105.6|Retraité|Femme\n  112|1|3|Non qualifié|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1|Employé|Homme\n  112|1|3|Non qualifié|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4|Employé|Homme\n  112|1|3|Qualifié|13/09/2001|01/12/2023|365|9|||||187.6|Employé|Homme\n  087|2|4|Non qualifié|||365||10||||87.3|Ouvrier|Femme\n  087|2|4|Non qualifié||31/10/2020|365|||11|||87.3|Ouvrier|Femme\n  099|1|4|Qualifié|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  187|2|2|Qualifié|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3|Profession intermédiaire|Femme\n  187|2|2|Qualifié|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1|Profession intermédiaire|Femme\n  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3|Cadre|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  ;\nrun;\n\n/* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\ndata donnees_sas;\n  set donnees_sas;\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Données fictives sur des formations\ndonnees_rbase <- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n# On vérifie que la base importée est bien un data.frame\nis.data.frame(donnees_rbase)\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base\ncolnames(donnees_rbase) <- tolower(colnames(donnees_rbase))\n# Autre possibilité\nsetNames(donnees_rbase, tolower(names(donnees_rbase)))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique <- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, enNumerique] <- lapply(donnees_rbase[, enNumerique], as.integer)\ndonnees_rbase$poids_sondage <- as.numeric(donnees_rbase$poids_sondage)\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nenDate <- names(donnees_rbase)[grepl(\"date\", tolower(names(donnees_rbase)))]\n# On remplace / par - dans les dates\ndonnees_rbase[, enDate] <- lapply(donnees_rbase[, enDate], function(x) gsub(\"/\", \"-\", x))\n# On exprime les dates en format Date\ndonnees_rbase[, enDate] <- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie <- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Format de la base\nclass(donnees_rbase)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Données fictives sur des formations\n# Autre solution !\ndonnees_tidyverse <- tibble(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n  \n)\n\n# Mise en forme des données\n\n# On vérifie que la base importée est bien un tibble\nis_tibble(donnees_tidyverse)\n\n# Transformation en tibble, le format de Tidyverse\ndonnees_tidyverse <- tibble::as_tibble(donnees_tidyverse)\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base en minuscule\ndonnees_tidyverse <- donnees_tidyverse %>% rename_with(tolower)\n# Autre solution\ndonnees_tidyverse <- donnees_tidyverse %>% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique <- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# On convertit certaines variables au format date\n# On récupère d'abord les variables dont le nom débute par le mot \"date\"\nenDate <- names(donnees_tidyverse)[grepl(\"date\", tolower(names(donnees_tidyverse)))]\n\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate_at(enNumerique, as.integer) %>% \n  mutate(poids_sondage = as.numeric(poids_sondage)) %>% \n  mutate_at(enDate, lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Format de la base\nclass(donnees_tidyverse)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Données fictives sur des formations\ndonnees_datatable <- data.table(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n\n# Mise en forme des données\n\n# On vérifie que la base est bien un data.table\nis.data.table(donnees_datatable)\n\n# Transformation en data.frame\nsetDF(donnees_datatable)\nis.data.frame(donnees_datatable)\n\n# Transformation en data.table\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetDT(donnees_datatable)\nis.data.table(donnees_datatable)\n# Autre possibilité\ndonnees_datatable <- as.data.table(donnees_datatable)\n\n\n# Est-ce une liste ?\nis.list(donnees_datatable)\n\n# Extraire les noms des variables de la base\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\nnomCol <- tolower(colnames(donnees_datatable))\n# Renommer les colonnes de la base\ncolnames(donnees_datatable) <- tolower(colnames(donnees_datatable))\n\n# On convertit certaines variables en format 'numeric'\nenNumerique <- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Ne pas oublier le . devant SDcols !!!!\ndonnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nfor (j in enNumerique) {\n  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))\n}\ndonnees_datatable[, poids_sondage := as.numeric(poids_sondage)]\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates <- names(donnees_datatable)[grepl(\"date\", tolower(names(donnees_datatable)))]\n# On remplace / par - dans les dates\ndonnees_datatable[, (varDates) := lapply(.SD, function(x) gsub(\"/\", \"-\", x)), .SDcols = varDates]\n# On exprime les dates en format Date\ndonnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]\n\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Format de la base\nclass(donnees_datatable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nDuckdb est un serveur SQL séparé de la session R. Les calculs sont effectués _en dehors_ de `R` et l'espace mémoire est distinct de celui de `R`. \nAu lieu d'accéder directement aux données, il faut passer par un objet _connection_ qui contient l'adresse du serveur, un peu comme lorsque l'on se connecte à un serveur web. Ici en particulier, il est nécessaire de transférer les données vers `duckdb`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ouvrir une connexion au serveur duckdb\ncon <- DBI::dbConnect(duckdb::duckdb()); \n\n# On \"copie\" les données dans une table du nom table_duckdb\ncon %>% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\n\ncon %>% tbl(\"table_duckdb\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<table_duckdb> [?? x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   <chr>       <chr> <chr> <chr>      <date>         <date>      <int>        <int>          <int>       <int>               <int>\n 1 173         2     1     Qualifié   1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2     1     Qualifié   1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2     1     Non quali… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1     1     Qualifié   1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2     3     Qualifié   1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1     2     Qualifié   2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n\n```{.r .cell-code}\n# Fermer la connexion au serveur duckdb\nDBI::dbDisconnect(con, shutdown = TRUE)\n```\n:::\n\nPour la suite, on suppose que la connexion est ouverte sous le nom `con`, et que les données sont accessibles par la requête `requete_duckdb`. Le code modifiera la requête, mais pas la table dans le serveur SQL.\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(duckdb::duckdb()); \ncon %>% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\nrequete_duckdb <- con %>% tbl(\"table_duckdb\")\n```\n:::\n\nN.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier `.parquet` sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n'affectent pas les fichiers source.\n\n\n:::\n\n# Préambule \n\n\n\n## Chemin du bureau de l'utilisateur \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On vide la log */\ndm \"log; clear; \";\n/* On récupère déjà l'identifiant de l'utilisateur (systèmes Windows) */\n%let user = &sysuserid;\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On récupère déjà l'identifiant de l'utilisateur\nuser <- Sys.getenv(\"USERNAME\")\nchemin <- file.path(\"C:/Users\", user, \"Desktop\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On récupère déjà l'identifiant de l'utilisateur\nuser <- Sys.getenv(\"USERNAME\")\nchemin <- file.path(\"C:/Users\", user, \"Desktop\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On récupère déjà l'identifiant de l'utilisateur\nuser <- Sys.getenv(\"USERNAME\")\nchemin <- file.path(\"C:/Users\", user, \"Desktop\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On récupère déjà l'identifiant de l'utilisateur\nuser <- Sys.getenv(\"USERNAME\")\nchemin <- file.path(\"C:/Users\", user, \"Desktop\")\n```\n:::\n\n:::\n\n## Affichage de l'année \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Année courante */\n%let an = %sysfunc(year(%sysfunc(today())));\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &an.;\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n/* Année passée */\n%put Année passée : %eval(&an. - 1);\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Année courante\nannee <- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 <- annee - 1\npaste0(\"Année passée: \", annee_1)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Année courante\nannee <- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 <- annee - 1\npaste0(\"Année passée: \", annee_1)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Année courante\nannee <- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 <- annee - 1\npaste0(\"Année passée: \", annee_1)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n:::\n\n## Construction des instructions if / else \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%macro Annee(an);\n  %if &an. >= 2024 %then %put Nous sommes en 2024 ou après !;\n  %else %put Nous sommes avant 2024 !;\n%mend Annee;\n%Annee(&an.);\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee >= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes en 2023 ou avant\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee >= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee >= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes en 2024 ou avant\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee >= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee >= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee >= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n:::\n\n## Répertoire de travail \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Afficher le répertoire de travail par défaut (la Work) */\n%let chemin_work = %sysfunc(pathname(work));\n%put &chemin_work.;\nproc sql;\n  select path from dictionary.libnames where libname = \"WORK\";\nquit;\n/* Définir le répertoire de travail, si besoin */\n/* libname \"nom du répertoire\";\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n:::\n\n## Autres points à connaître \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Mise en garde : certains codes SAS pourraient aussi avec profit être écrits en langage SAS IML (Interactive Matrix Language).\n   Cet aide-mémoire n'ayant pas vocation à être un dictionnaire SAS, cette méthode d'écriture n'est pas proposée ici. */\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Le pipe peut aussi être utilisé avec R-Base et data.table\n# Le pipe permet d'enchaîner des opérations sur une même base\n1:10 |> sum()\n# R-Base est réputé plus lent que ses concurrents, ce qui est souvent vrai.\n# Mais certaines fonctions en R-Base être très rapides (rowsum, rowSums, tapply, etc.)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# tidyverse promeut l'utilisation du pipe (%>%), qui permet d'enchaîner des opérations sur une même base modifiée successivement.\n# 2 types de pipes existent, le pipe de magrittr (%>%) et le pipe de R-Base (|>, à partir de la version 4.1)\n# Les fonctionnalités simples des deux opérateurs sont identiques, mais il existe des différences.\n# Le tidyverse peut s'utiliser sans pipe, mais le pipe simplifie la gestion des programmes.\n# Les autres environnements (R-Base, data.table) peuvent aussi se présenter avec le pipe\n# Dans cet aide-mémoire, le pipe de magrittr (%>%) est privilégié.\n\n# À FAIRE :\n# - expliquer les différences entre le pipe de magrittr et de R-Base\n\n# Documentation de tidyverse (dplyr et tidyr)\nvignette(\"dplyr\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Principe de base de data.table\n#dt[i, j, by]\n# i : sélection de lignes (instructions )\n# j : sélection et manipulation de colonnes\n# by : groupements\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n:::\n\n\n# Informations sur la base de données \n\n## Avoir une vue d'ensemble des données \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Statistiques globales sur les variables numériques */\nproc means data = donnees_sas n mean median min p10 p25 median p75 p90 max;var _numeric_;run;\n/* Statistiques globales sur les variables caractères */\nproc freq data = donnees_sas;tables _character_ / missing;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Informations sur les variables\nstr(donnees_rbase)\n# Statistiques descriptives des variables de la base\nsummary(donnees_rbase)\nlibrary(Hmisc)\nHmisc::describe(donnees_rbase)\n# Visualiser la base de données\nView(donnees_rbase)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Informations sur les variables\ndonnees_tidyverse %>% str()\ndonnees_tidyverse %>% glimpse()\n# Statistiques descriptives des variables de la base\ndonnees_tidyverse %>% summary()\n# Visualiser la base de données\ndonnees_tidyverse %>% View()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Informations sur les variables\nstr(donnees_datatable)\n# Statistiques descriptives des variables de la base\nsummary(donnees_datatable)\n# Visualiser la base de données\nView(donnees_datatable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nOn accède aux données du serveur SQL DuckDB au travers de l'objet `requete_duckdb`, qui est une requête (avec l'adresse du serveur) et non pas un `dataframe` ou un `tibble`. Comme l'accès n'est pas direct, la plupart des fonctions du tidyverse fonctionnent, mais opèrent sur \"l'adresse du serveur DuckDB\" au lieu d'opérer sur les valeurs (nombres, chaînes de caractères). A part `glimpse`, la plupart des fonctions ne renvoient pas un résultat exploitable.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Informations sur les variables\n# requete_duckdb %>% str() \nrequete_duckdb %>% glimpse() # préférer glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 16\nDatabase: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n$ identifiant         <chr> \"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"1…\n$ sexe                <chr> \"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", …\n$ csp                 <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", …\n$ niveau              <chr> \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifi…\n$ date_naissance      <date> 1998-06-17, 1998-06-17, 1998-06-17, 1998-06-17, 1984-12-08, 1989-09-16, 1987-03-17, 1987-03-17, 198…\n$ date_entree         <date> 2021-01-01, 2022-01-01, 2022-01-06, 2023-01-02, 2021-08-17, 2022-12-21, 2022-07-28, 2022-11-17, 202…\n$ duree               <int> 308, 365, 185, 365, 183, 730, 30, 164, 365, 365, 135, 365, 180, 212, 365, 365, 365, 365, 364, 364, 3…\n$ note_contenu        <int> 12, 6, 8, 14, 17, 5, 10, 11, 9, 18, 16, 14, 12, 3, 7, 9, NA, NA, 12, 12, 12, 10, 10, 9, 13, 13, 13\n$ note_formateur      <int> 6, NA, 10, 15, 18, 5, 10, 7, 20, 11, 16, 10, 5, 10, 13, NA, 10, NA, 11, 11, 11, 10, 10, 7, 10, 10, 10\n$ note_moyens         <int> 17, 12, 11, 15, 20, 8, 10, 6, 3, 20, 15, 6, 7, 11, 8, NA, NA, 11, 10, 10, 10, 10, 10, 8, 12, 12, 12\n$ note_accompagnement <int> 4, 7, 1, 10, 15, 4, 16, 14, 4, 13, 12, 8, 11, 9, 19, NA, NA, NA, 12, 12, 12, 10, 10, 13, 18, 18, 18\n$ note_materiel       <int> 19, 14, 9, 8, 12, 9, 8, 13, 17, 15, 9, 12, 12, 8, 2, NA, NA, NA, 13, 13, 13, 10, 10, 16, 10, 10, 10\n$ poids_sondage       <dbl> 117.1, 98.3, 214.6, 84.7, 65.9, 148.2, 89.6, 100.3, 49.3, 148.2, 86.4, 99.2, 105.6, 123.1, 137.4, 18…\n$ cspf                <chr> \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession i…\n$ sexef               <chr> \"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"…\n$ date_sortie         <date> 2021-11-05, 2023-01-01, 2022-07-10, 2024-01-02, 2022-02-16, 2024-12-20, 2022-08-27, 2023-04-30, 2024…\n```\n:::\n\n```{.r .cell-code}\n# requete_duckdb %>% summary()\n# requete_duckdb %>% View() \n```\n:::\n\n:::\n\n## Extraire les x premières lignes de la base (10 par défaut) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let x = 10;\nproc print data = donnees_sas (firstobs = 1 obs = &x.);run;\n/* Ou alors */\ndata Lignes&x.;set donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ndonnees_rbase[1:x, ]\nhead(donnees_rbase, x)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ndonnees_tidyverse %>% \n  slice(1:x)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, head(.SD, 10)]\ndonnees_datatable[, .SD[1:10]]\nhead(donnees_datatable, 10)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\nDuckDB affiche les dix premières lignes par défaut lorsque l'on évalue une requête, comme indiqué dans le code ci-dessous. \n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<table_duckdb> [?? x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   <chr>       <chr> <chr> <chr>      <date>         <date>      <int>        <int>          <int>       <int>               <int>\n 1 173         2     1     Qualifié   1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2     1     Qualifié   1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2     1     Non quali… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1     1     Qualifié   1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2     3     Qualifié   1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1     2     Qualifié   2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n\n```{.r .cell-code}\n# Ceci est équivalent au code suivant\n# requete_duckdb %>% print(n=10)\n```\n:::\n\nAttention, comme il n'y a pas d'ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C'est une opération qui peut être couteuse en temps CPU.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% arrange(duree) %>% print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:     SQL [?? x 16]\n# Database:   DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n# Ordered by: duree\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   <chr>       <chr> <chr> <chr>      <date>         <date>      <int>        <int>          <int>       <int>               <int>\n 1 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 2 689         1     1     <NA>       2000-12-01     2017-11-06    123            9              7           8                  13\n 3 211         2     3     Non quali… NA             2021-12-17    135           16             16          15                  12\n 4 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 5 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 6 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 7 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 8 347         2     5     Qualifié   1955-09-13     NA            180           12              5           7                  11\n 9 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n10 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n# ℹ more rows\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\nL'objet `requete_duckdb` est bien une requête (i.e. une liste à deux éléments) même si on peut en afficher le résultat avec la fonction `print`. Notamment, les informations restent dans la mémoire de DuckDB. Il faut demander explicitement le transfert du résultat vers la session R avec la fonction `collect()`. On obtient alors un objet de type `data.frame` ou au lieu de `tbl_duckdb_connection`. \n\n::: {.cell}\n\n```{.r .cell-code}\nclass(requete_duckdb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_duckdb_connection\" \"tbl_dbi\"               \"tbl_sql\"               \"tbl_lazy\"              \"tbl\"                  \n```\n:::\n\n```{.r .cell-code}\nresultat_tibble <- requete_duckdb %>% collect()\nclass(resultat_tibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\nLa fonction `collect()` transfère l'ensemble des données. Pour obtenir uniquement 10 lignes, il faut utiliser l'une des fonctions `slice_*` (cf [documentation](https://dplyr.tidyverse.org/reference/slice.html)). On conseille `slice_min` ou `slice_max` qui indiquent explicitement l'ordre utilisé.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% slice_max(duree, n=4, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 4 lignes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [4 x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  <chr>       <chr> <chr> <chr>       <date>         <date>      <int>        <int>          <int>       <int>               <int>\n1 175         1     1     Qualifié    1989-09-16     2022-12-21    730            5              5           8                   4\n2 173         2     1     Qualifié    1998-06-17     2022-01-01    365            6             NA          12                   7\n3 173         2     1     Non qualif… 1998-06-17     2023-01-02    365           14             15          15                  10\n4 198         2     3     Qualifié    1987-03-17     2023-02-21    365            9             20           3                   4\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\nEn DuckDB et/ou sur un serveur SQL, on déconseille les fonctions `head` (qui ne respecte pas toujours l'ordre indiqué par `arrange`) ou `top_n` (superseded). La fonction `slice` en fonctionne pas : elle ne peut pas respecter l'ordre.\n\n:::\n\n\n\n## Extraire les x dernières lignes de la base\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n\n``` sas\n%let x = 10;\nproc sql noprint;select count(*) into :total_lignes from donnees_sas;quit;\n%let deb = %eval(&total_lignes. - &x. + 1);\ndata Lignes_&x.;set donnees_sas (firstobs = &deb. obs = &total_lignes.);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\ntail(donnees_rbase, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   identifiant sexe csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n23         187    2   2     Qualifié     1986-12-05  2023-01-01   364           10             10          10                  10\n24         689    1   1         <NA>     2000-12-01  2017-11-06   123            9              7           8                  13\n25         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n26         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n27         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n   note_materiel poids_sondage                     cspf sexef date_sortie\n23            10         234.1 Profession intermédiaire Femme  2023-12-31\n24            16         189.3                    Cadre Homme  2018-03-09\n25            10          45.9                  Ouvrier Homme  2020-09-24\n26            10          45.9                  Ouvrier Homme  2020-09-24\n27            10          45.9                  Ouvrier Homme  2020-09-24\n```\n:::\n:::\n\nAlternativement\n\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase[ ( nrow(donnees_rbase) - x ) : nrow(donnees_rbase), ]\n```\n:::\n\nLes parenthèses sont importantes. Comparer les deux expressions ! Bon exemple du recycling\n\n::: {.cell}\n\n```{.r .cell-code}\n( nrow(donnees_rbase) - x ) : nrow(donnees_rbase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22 23 24 25 26 27\n```\n:::\n\n```{.r .cell-code}\nnrow(donnees_rbase) - x : nrow(donnees_rbase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n```\n:::\n:::\n\n\n## `tidyverse` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  slice( (n()-5) : n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 16\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  <chr>       <chr> <chr> <chr>       <date>         <date>      <int>        <int>          <int>       <int>               <int>\n1 187         2     2     Qualifié    1986-12-05     2022-01-01    364           10             10          10                  10\n2 187         2     2     Qualifié    1986-12-05     2023-01-01    364           10             10          10                  10\n3 689         1     1     <NA>        2000-12-01     2017-11-06    123            9              7           8                  13\n4 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n5 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n6 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\n## `data.table` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(donnees_datatable, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   identifiant   sexe    csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens\n        <char> <char> <char>       <char>         <Date>      <Date> <num>        <num>          <num>       <num>\n1:         187      2      2     Qualifié     1986-12-05  2023-01-01   364           10             10          10\n2:         689      1      1         <NA>     2000-12-01  2017-11-06   123            9              7           8\n3:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n4:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n5:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n   note_accompagnement note_materiel poids_sondage                     cspf  sexef date_sortie\n                 <num>         <num>         <num>                   <char> <char>      <Date>\n1:                  10            10         234.1 Profession intermédiaire  Femme  2023-12-31\n2:                  13            16         189.3                    Cadre  Homme  2018-03-09\n3:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n4:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n5:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n```\n:::\n:::\n\nAlternativement\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n   identifiant   sexe    csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens\n        <char> <char> <char>       <char>         <Date>      <Date> <num>        <num>          <num>       <num>\n1:         187      2      2     Qualifié     1986-12-05  2023-01-01   364           10             10          10\n2:         689      1      1         <NA>     2000-12-01  2017-11-06   123            9              7           8\n3:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n4:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n5:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n   note_accompagnement note_materiel poids_sondage                     cspf  sexef date_sortie\n                 <num>         <num>         <num>                   <char> <char>      <Date>\n1:                  10            10         234.1 Profession intermédiaire  Femme  2023-12-31\n2:                  13            16         189.3                    Cadre  Homme  2018-03-09\n3:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n4:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n5:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n```\n:::\n:::\n\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nMêmes remarques que pour les premières lignes : il n'y a pas d'ordre a priori en SQL. On conseille `slice_min` ou `slice_max` qui indiquent explicitement l'ordre utilisé, et l'on déconseille `slice` et `tail`.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% slice_min(duree, n=5, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 5 lignes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [5 x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  <chr>       <chr> <chr> <chr>       <date>         <date>      <int>        <int>          <int>       <int>               <int>\n1 198         2     3     Non qualif… 1987-03-17     2022-07-28     30           10             10          10                  16\n2 689         1     1     <NA>        2000-12-01     2017-11-06    123            9              7           8                  13\n3 211         2     3     Non qualif… NA             2021-12-17    135           16             16          15                  12\n4 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n5 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\n:::\n\n\n\n## Nombre de lignes et de colonnes dans la base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Nombre de lignes */\nproc sql;select count(*) as Nb_Lignes from donnees_sas;quit;\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants\n  from donnees_sas;\nquit;\n/* Liste des variables de la base dans la base Var */\nproc contents data = donnees_sas out = Var noprint;run;\n/* Nombre de colonnes */\nproc sql;select count(*) as Nb_Colonnes from Var;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", nrow(donnees_rbase), ncol(donnees_rbase))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\",\n        donnees_tidyverse %>% nrow(),\n        donnees_tidyverse %>% ncol())\n# Nombre de lignes\ndonnees_tidyverse %>% nrow()\n# Nombre de colonnes\ndonnees_tidyverse %>% ncol()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndim(donnees_datatable) ; dim(donnees_datatable)[1] ; dim(donnees_datatable)[2]\ndim(donnees_datatable) ; nrow(donnees_datatable) ; ncol(donnees_datatable)\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_datatable)[1], dim(donnees_datatable)[2])\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\nDuckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire `count()`.\n\n::: {.cell}\n\n```{.r .cell-code}\n#Nombre de lignes\nrequete_duckdb %>% nrow() # retourne NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% count() # correct\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n      n\n  <dbl>\n1    27\n```\n:::\n\n```{.r .cell-code}\n#Nombre de colonnes\nrequete_duckdb %>%  ncol()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n:::\n## Liste des variables de la base\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Par ordre d'apparition dans la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var order by varnum;run;\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n/* Par ordre alphabétique */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var;run;\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Liste des variables par ordre d'apparition dans la base\nnames(donnees_rbase)\ncolnames(donnees_rbase)\n# Liste des variables par ordre alphabétique\nls(donnees_rbase)\nsort(colnames(donnees_rbase))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Liste des variables par ordre d'apparition dans la base\ndonnees_tidyverse %>% colnames()\n# Liste des variables par ordre alphabétique\ndonnees_tidyverse %>% colnames() %>% sort()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Liste des variables par ordre d'apparition dans la base\ncolnames(donnees_datatable)\n# Liste des variables par ordre alphabétique\nsort(colnames(donnees_datatable))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% colnames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"identifiant\"         \"sexe\"                \"csp\"                 \"niveau\"              \"date_naissance\"     \n [6] \"date_entree\"         \"duree\"               \"note_contenu\"        \"note_formateur\"      \"note_moyens\"        \n[11] \"note_accompagnement\" \"note_materiel\"       \"poids_sondage\"       \"cspf\"                \"sexef\"              \n[16] \"date_sortie\"        \n```\n:::\n:::\n\n:::\n\n\n\n\n## Nombre d'identifiants uniques et nombre de lignes dans la base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants_Uniques\n  from donnees_sas;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_rbase),\n        length(unique(donnees_rbase$identifiant)))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        donnees_tidyverse %>% nrow(),\n        donnees_tidyverse %>% select(identifiant) %>%\n          n_distinct()\n        )\n# Autre solution pour le nombre d'identifiants uniques\ndonnees_tidyverse %>% select(identifiant) %>% n_distinct()\ndonnees_tidyverse %>% distinct(identifiant) %>% nrow()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_datatable),\n        donnees_datatable[, uniqueN(identifiant)])\n# Identifiants uniques\ndonnees_datatable[, uniqueN(identifiant)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% distinct(identifiant) %>% count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n      n\n  <dbl>\n1    14\n```\n:::\n:::\nNote : on a vu que `nrow` ne fonctionne pas en DuckDB. \n\n:::\n\n## Quelle est la position de la variable date_entree ? \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = date_entree;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select varnum as Position from Var where lowcase(NAME) = \"&var.\";\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"date_entree\"\npos <- match(variable, names(donnees_rbase))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"date_entree\"\npos <- match(variable, donnees_tidyverse %>% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"date_entree\"\npos <- match(variable, names(donnees_datatable))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"date_entree\"\npos <- match(variable, requete_duckdb %>% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"La variable date_entree se trouve en colonne n°6 !\"\n```\n:::\n:::\n\n\n:::\n\n\n# Type des variables (int, char, bool, etc.)\n\n## Afficher le type des variables\n\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n\n``` sas\nproc contents data = donnees_sas;run;\n\n/* On supprime la base Var temporaire */\nproc datasets lib = Work nolist;delete Var;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(donnees_rbase, class)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(donnees_tidyverse, class)\nclass(donnees_tidyverse)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, lapply(.SD, class)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\nOn ne peut pas appliquer directement la fonction `class` sur un objet de type `connection`. Cependant, DuckDB affiche le type des variables dans un print. On peut également appliquer la fonction `class` sur un extrait des données (après `collect`).\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(requete_duckdb %>% select(c(1,2)) %>% head() %>% collect(), class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$identifiant\n[1] \"character\"\n\n$sexe\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(requete_duckdb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_duckdb_connection\" \"tbl_dbi\"               \"tbl_sql\"               \"tbl_lazy\"              \"tbl\"                  \n```\n:::\n:::\n\n:::\n\n## Convertir le type d'une seule variable\n\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata donnees_sas;\n  set donnees_sas;\n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique <- as.numeric(donnees_rbase$sexe)\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere <- as.character(donnees_rbase$sexe_numerique)\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r <- lubridate::dmy(\"01/01/2000\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>%  \n  mutate(sexe_numerique = as.numeric(sexe)) %>% # Transformer la variable sexe en numérique\n  mutate(sexe_caractere = as.character(sexe_numerique)) %>% # Transformer la variable sexe_numerique en caractère\n  select(starts_with(\"sexe\")) %>% print(n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 4]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  sexe  sexef sexe_numerique sexe_caractere\n  <chr> <chr>          <dbl> <chr>         \n1 2     Femme              2 2.000         \n2 2     Femme              2 2.000         \n3 2     Femme              2 2.000         \n4 2     Femme              2 2.000         \n5 1     Homme              1 1.000         \n# ℹ more rows\n```\n:::\n:::\n\nEn DuckDB, plusieurs syntaxes sont possibles pour transformer une chaîne de caractères en date. Sauf lorsque la chaîne de caractères n'est pas au format `YYYY-MM-DD`. On conseille de passer par la fonction `strptime` de DuckDB pour indiquer le format de la date.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer une date d'un format caractère à un format Date\nrequete_duckdb %>%  \n  mutate(date_0 = as.Date(\"2000-01-01\")) %>% \n  mutate(date_1 = as.Date(strptime(\"01/01/2000\",\"%d/%m/%Y\"))) %>% \n  # mutate(date_r = lubridate::dmy(\"01/01/2000\")) %>% # no known SQL translation\n  select(starts_with(\"date\")) %>% print(n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 5]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  date_naissance date_entree date_sortie date_0     date_1    \n  <date>         <date>      <date>      <date>     <date>    \n1 1998-06-17     2021-01-01  2021-11-05  2000-01-01 2000-01-01\n2 1998-06-17     2022-01-01  2023-01-01  2000-01-01 2000-01-01\n3 1998-06-17     2022-01-06  2022-07-10  2000-01-01 2000-01-01\n4 1998-06-17     2023-01-02  2024-01-02  2000-01-01 2000-01-01\n5 1984-12-08     2021-08-17  2022-02-16  2000-01-01 2000-01-01\n# ℹ more rows\n```\n:::\n:::\n\n:::\n\n\n## Convertir le type de plusieurs variables \n\n::: {.panel-tabset group=\"language\"}\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nenNumerique <- c(\"duree\", \"note_contenu\", \"note_formateur\")\nenDate <- c('date_naissance', 'date_entree')\n\nrequete_duckdb %>%  \n  mutate_at(enNumerique, as.integer) %>% \n  mutate_at(enDate, as.character) %>% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%Y-%m-%d'))) %>% # strptime est une fonction duckdb\n  select(enNumerique, enDate) %>% print(n=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 5]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  duree note_contenu note_formateur date_naissance date_entree\n  <int>        <int>          <int> <date>         <date>     \n1   308           12              6 1998-06-17     2021-01-01 \n2   365            6             NA 1998-06-17     2022-01-01 \n3   185            8             10 1998-06-17     2022-01-06 \n4   365           14             15 1998-06-17     2023-01-02 \n5   183           17             18 1984-12-08     2021-08-17 \n# ℹ more rows\n```\n:::\n:::\n:::\n\n\n\n\n\n\n\n\n# Sélectionner des lignes et des colonnes \n\n\n## Selection de colonnes par position \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let pos = 1;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = &pos.;\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\npos <- 1\n# Résultat sous forme de vecteur caractère\nid <- donnees_rbase[[pos]] ; class(id)\nid <- donnees_rbase[, pos] ; class(id)\n# Résultat sous forme de data.frame\nid <- donnees_rbase[pos] ; class(id)\nid <- donnees_rbase[, pos, drop = FALSE] ; class(id)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sous forme de vecteur\nid <- donnees_tidyverse %>% pull(1)\nclass(id)\npos <- 1\nid <- donnees_tidyverse %>% pull(all_of(pos))\nclass(id)\n# Sous forme de tibble\nid <- donnees_tidyverse %>% select(1)\nclass(id)\npos <- 1\nid <- donnees_tidyverse %>% select(all_of(pos))\nclass(id)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\npos <- 1\n# Résultat sous forme de vecteur caractère\nid <- donnees_datatable[[pos]] ; class(id)\n# Résultat sous forme de data.table\nid <- donnees_datatable[pos] ; class(id)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nEn DuckDB, il y a une vraie différence entre `select` et `pull`. Dans le premier cas, les calculs restent du côté DuckDB, et c'est donc le moteur SQL qui continue à exécuter les calculs. Avec `pull`, le résultat est un `tibble` et les données sont transférées à la session R.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   csp  \n   <chr>\n 1 1    \n 2 1    \n 3 1    \n 4 1    \n 5 1    \n 6 1    \n 7 3    \n 8 3    \n 9 3    \n10 2    \n# ℹ more rows\n```\n:::\n:::\n\n:::\n## Selection de colonnes par nom \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Colonnes;set donnees_sas (keep = identifiant);run;\ndata Colonnes;set donnees_sas;keep identifiant;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Résultat sous forme de vecteur caractère\nid <- donnees_rbase$identifiant ; class(id)\nid <- donnees_rbase[[\"identifiant\"]] ; class(id)\nid <- donnees_rbase[, \"identifiant\"] ; class(id)\n# Résultat sous forme de data.frame\nclass(donnees_rbase[, \"identifiant\"])\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie\n# un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nclass(donnees_rbase[, \"identifiant\", drop = FALSE])\nid <- donnees_rbase[\"identifiant\"] ; class(id)\nid <- donnees_rbase[, \"identifiant\", drop = FALSE] ; class(id)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sous forme de vecteur\nid <- donnees_tidyverse %>% pull(identifiant)\nid <- donnees_tidyverse %>% pull(\"identifiant\")\n# Sous forme de tibble\nid <- donnees_tidyverse %>% select(identifiant)\nid <- donnees_tidyverse %>% select(\"identifiant\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Résultat sous forme de vecteur caractère\nid <- donnees_datatable$identifiant ; class(id)\nid <- donnees_datatable[[\"identifiant\"]] ; class(id)\nid <- donnees_datatable[, identifiant] ; class(id)\n# Résultat sous forme de data.table\nid <- donnees_datatable[, \"identifiant\"] ; class(id)\nid <- donnees_datatable[, .(\"identifiant\")] ; class(id)\nid <- donnees_datatable[, list(\"identifiant\")] ; class(id)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(identifiant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant\n   <chr>      \n 1 173        \n 2 173        \n 3 173        \n 4 173        \n 5 174        \n 6 175        \n 7 198        \n 8 198        \n 9 198        \n10 168        \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(\"identifiant\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant\n   <chr>      \n 1 173        \n 2 173        \n 3 173        \n 4 173        \n 5 174        \n 6 175        \n 7 198        \n 8 198        \n 9 198        \n10 168        \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(any_of(\"identifiant\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant\n   <chr>      \n 1 173        \n 2 173        \n 3 173        \n 4 173        \n 5 174        \n 6 175        \n 7 198        \n 8 198        \n 9 198        \n10 168        \n# ℹ more rows\n```\n:::\n:::\nNote : on déconseille l'utilisation de `select` sur des chaînes de caractère : certaines fonction du tidyvers nécessient de passer par les opérateurs `any_of` ou `all_of` pour ce genre d'opérations (`distinct` par exemple).\n\n:::\n\n## Selection de colonnes par un vecteur contenant des chaînes de caractères\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Selection de colonnes */\n  keep &var.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\n# Résultat sous forme de vecteur caractère\nid <- donnees_rbase[, variable] ; class(id)\nid <- donnees_rbase[[variable]] ; class(id)\n# Résultat sous forme de data.frame\nid <- donnees_rbase[variable] ; class(id)\nid <- donnees_rbase[, variable, drop = FALSE] ; class(id)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\n# Sous forme de vecteur\nid <- donnees_tidyverse %>% pull(all_of(variable))\n# Sous forme de tibble\nid <- donnees_tidyverse %>% select(all_of(variable))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Résultat sous forme de vecteur caractère\nvariable <- \"identifiant\"\nid <- donnees_datatable[[variable]] ; class(id)\n# Résultat sous forme de data.table\nid <- donnees_datatable[, .(variable)] ; class(id)\nid <- donnees_datatable[, list(variable)] ; class(id)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- c(\"identifiant\",\"duree\")\nrequete_duckdb %>% select(any_of(variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 2]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant duree\n   <chr>       <int>\n 1 173           308\n 2 173           365\n 3 173           185\n 4 173           365\n 5 174           183\n 6 175           730\n 7 198            30\n 8 198           164\n 9 198           365\n10 168           365\n# ℹ more rows\n```\n:::\n:::\n\n:::\n\n## Sauf certaines variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;set donnees_sas (drop = &var.);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ne fonctionne pas !\nvariable <- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\n#exclusion_var <- donnees_rbase[, -c(variable)]\nexclusion_var <- donnees_rbase[, setdiff(names(donnees_rbase), variable)]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var <- donnees_tidyverse %>% select(!all_of(variable))\nexclusion_var <- donnees_tidyverse %>% select(-all_of(variable))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\n# Ne fonctionne pas !\n#exclusion_var <- donnees_datatable[, -c(variable)]\nexclusion_var <- donnees_datatable[, setdiff(names(donnees_datatable), variable)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nLes opérateurs `-` et `!` fonctionnent.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(!identifiant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 15]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   sexe  csp   niveau   date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement note_materiel\n   <chr> <chr> <chr>    <date>         <date>      <int>        <int>          <int>       <int>               <int>         <int>\n 1 2     1     Qualifié 1998-06-17     2021-01-01    308           12              6          17                   4            19\n 2 2     1     Qualifié 1998-06-17     2022-01-01    365            6             NA          12                   7            14\n 3 2     1     Qualifié 1998-06-17     2022-01-06    185            8             10          11                   1             9\n 4 2     1     Non qua… 1998-06-17     2023-01-02    365           14             15          15                  10             8\n 5 1     1     Qualifié 1984-12-08     2021-08-17    183           17             18          20                  15            12\n 6 1     1     Qualifié 1989-09-16     2022-12-21    730            5              5           8                   4             9\n 7 2     3     Non qua… 1987-03-17     2022-07-28     30           10             10          10                  16             8\n 8 2     3     Qualifié 1987-03-17     2022-11-17    164           11              7           6                  14            13\n 9 2     3     Qualifié 1987-03-17     2023-02-21    365            9             20           3                   4            17\n10 1     2     Qualifié 2002-07-30     2019-09-04    365           18             11          20                  13            15\n# ℹ more rows\n# ℹ 4 more variables: poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(-all_of(variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 13]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   csp   niveau  date_naissance date_entree duree note_formateur note_moyens note_accompagnement note_materiel poids_sondage cspf \n   <chr> <chr>   <date>         <date>      <int>          <int>       <int>               <int>         <int>         <dbl> <chr>\n 1 1     Qualif… 1998-06-17     2021-01-01    308              6          17                   4            19         117.  Cadre\n 2 1     Qualif… 1998-06-17     2022-01-01    365             NA          12                   7            14          98.3 Cadre\n 3 1     Qualif… 1998-06-17     2022-01-06    185             10          11                   1             9         215.  Cadre\n 4 1     Non qu… 1998-06-17     2023-01-02    365             15          15                  10             8          84.7 Cadre\n 5 1     Qualif… 1984-12-08     2021-08-17    183             18          20                  15            12          65.9 Cadre\n 6 1     Qualif… 1989-09-16     2022-12-21    730              5           8                   4             9         148.  Cadre\n 7 3     Non qu… 1987-03-17     2022-07-28     30             10          10                  16             8          89.6 Empl…\n 8 3     Qualif… 1987-03-17     2022-11-17    164              7           6                  14            13         100.  Empl…\n 9 3     Qualif… 1987-03-17     2023-02-21    365             20           3                   4            17          49.3 Empl…\n10 2     Qualif… 2002-07-30     2019-09-04    365             11          20                  13            15         148.  Prof…\n# ℹ more rows\n# ℹ 2 more variables: sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\n:::\n\n## Sélectionner la 3e colonne \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = 3;\nrun;\ndata Col3;set donnees_sas (keep = &nom_col.);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncol3 <- donnees_rbase[, 3]\ncol3 <- donnees_rbase[3]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncol3 <- donnees_tidyverse %>% pull(3)\ncol3 <- donnees_tidyverse %>% select(3)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncol3 <- donnees_datatable[, 3]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   csp  \n   <chr>\n 1 1    \n 2 1    \n 3 1    \n 4 1    \n 5 1    \n 6 1    \n 7 3    \n 8 3    \n 9 3    \n10 2    \n# ℹ more rows\n```\n:::\n:::\n\n:::\n\n## Sélectionner plusieurs colonnes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant note_contenu sexe;\ndata Colonnes;set donnees_sas (keep = &var.);run;\nproc sql;\n  create table Colonnes as\n  select %sysfunc(tranwrd(&var., %str( ), %str(, )))\n  from donnees_sas;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\")\ncolonnes <- donnees_rbase[, cols]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\ncolonnes <- donnees_tidyverse %>% select(all_of(cols))\ncolonnes <- donnees_tidyverse %>% select(any_of(cols))\ncolonnes <- donnees_tidyverse %>% select({{cols}})\ncolonnes <- donnees_tidyverse %>% select(!!cols)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs écritures possibles\n# Peut-être l'écriture la plus simple, à privilégier\ncolonnes <- donnees_datatable[, mget(cols)]\n# Ecriture cohérente avec la logique data.table\ncolonnes <- donnees_datatable[, .SD, .SDcols = cols]\n# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!\n# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas\ncolonnes <- donnees_datatable[, ..cols]\n# Ecriture avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\n# Avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\ncolonnes <- donnees_datatable[, cols, with = FALSE]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\nrequete_duckdb %>% select(all_of(cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe \n   <chr>              <int> <chr>\n 1 173                   12 2    \n 2 173                    6 2    \n 3 173                    8 2    \n 4 173                   14 2    \n 5 174                   17 1    \n 6 175                    5 1    \n 7 198                   10 2    \n 8 198                   11 2    \n 9 198                    9 2    \n10 168                   18 1    \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(any_of(cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe \n   <chr>              <int> <chr>\n 1 173                   12 2    \n 2 173                    6 2    \n 3 173                    8 2    \n 4 173                   14 2    \n 5 174                   17 1    \n 6 175                    5 1    \n 7 198                   10 2    \n 8 198                   11 2    \n 9 198                    9 2    \n10 168                   18 1    \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select({{cols}})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe \n   <chr>              <int> <chr>\n 1 173                   12 2    \n 2 173                    6 2    \n 3 173                    8 2    \n 4 173                   14 2    \n 5 174                   17 1    \n 6 175                    5 1    \n 7 198                   10 2    \n 8 198                   11 2    \n 9 198                    9 2    \n10 168                   18 1    \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(!!cols)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe \n   <chr>              <int> <chr>\n 1 173                   12 2    \n 2 173                    6 2    \n 3 173                    8 2    \n 4 173                   14 2    \n 5 174                   17 1    \n 6 175                    5 1    \n 7 198                   10 2    \n 8 198                   11 2    \n 9 198                    9 2    \n10 168                   18 1    \n# ℹ more rows\n```\n:::\n:::\n:::\n## Sélectionner les colonnes qui débutent par le mot Note \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* 1ère solution */\ndata Selection_Variables;set donnees_sas (keep = Note:);run;\n/* 2e solution */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select name into :var_notes separated by \" \"\n  from Var where substr(upcase(name), 1, 4) = \"NOTE\" order by varnum;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\ndata donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- donnees_rbase[grepl(\"^note\", names(donnees_rbase))]\nvarNotes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == \"note\"]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- donnees_tidyverse %>% select(starts_with(\"note\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère méthode\ncols <- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel <- donnees_datatable[, .SD, .SDcols = cols]\n# 2e méthode\nsel <- donnees_datatable[, .SD, .SDcols = patterns(\"^note\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(starts_with(\"note\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 5]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   note_contenu note_formateur note_moyens note_accompagnement note_materiel\n          <int>          <int>       <int>               <int>         <int>\n 1           12              6          17                   4            19\n 2            6             NA          12                   7            14\n 3            8             10          11                   1             9\n 4           14             15          15                  10             8\n 5           17             18          20                  15            12\n 6            5              5           8                   4             9\n 7           10             10          10                  16             8\n 8           11              7           6                  14            13\n 9            9             20           3                   4            17\n10           18             11          20                  13            15\n# ℹ more rows\n```\n:::\n:::\n:::\n## Sélectionner les colonnes qui ne débutent pas par le mot Note \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Selection_Variables;set donnees_sas (drop = Note:);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- donnees_rbase[! grepl(\"^note\", names(donnees_rbase))]\nvarNotes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != \"note\"]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- donnees_tidyverse %>% select(-starts_with(\"note\"))\nvarNotes <- donnees_tidyverse %>% select(!starts_with(\"note\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel <- donnees_datatable[, .SD, .SDcols = -cols]\nsel <- donnees_datatable[, .SD, .SDcols = -patterns(\"^note\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select(-starts_with(\"note\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 11]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant sexe  csp   niveau       date_naissance date_entree duree poids_sondage cspf                     sexef date_sortie\n   <chr>       <chr> <chr> <chr>        <date>         <date>      <int>         <dbl> <chr>                    <chr> <date>     \n 1 173         2     1     Qualifié     1998-06-17     2021-01-01    308         117.  Cadre                    Femme 2021-11-05 \n 2 173         2     1     Qualifié     1998-06-17     2022-01-01    365          98.3 Cadre                    Femme 2023-01-01 \n 3 173         2     1     Qualifié     1998-06-17     2022-01-06    185         215.  Cadre                    Femme 2022-07-10 \n 4 173         2     1     Non qualifié 1998-06-17     2023-01-02    365          84.7 Cadre                    Femme 2024-01-02 \n 5 174         1     1     Qualifié     1984-12-08     2021-08-17    183          65.9 Cadre                    Homme 2022-02-16 \n 6 175         1     1     Qualifié     1989-09-16     2022-12-21    730         148.  Cadre                    Homme 2024-12-20 \n 7 198         2     3     Non qualifié 1987-03-17     2022-07-28     30          89.6 Employé                  Femme 2022-08-27 \n 8 198         2     3     Qualifié     1987-03-17     2022-11-17    164         100.  Employé                  Femme 2023-04-30 \n 9 198         2     3     Qualifié     1987-03-17     2023-02-21    365          49.3 Employé                  Femme 2024-02-21 \n10 168         1     2     Qualifié     2002-07-30     2019-09-04    365         148.  Profession intermédiaire Homme 2020-09-03 \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% select(!starts_with(\"note\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 11]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant sexe  csp   niveau       date_naissance date_entree duree poids_sondage cspf                     sexef date_sortie\n   <chr>       <chr> <chr> <chr>        <date>         <date>      <int>         <dbl> <chr>                    <chr> <date>     \n 1 173         2     1     Qualifié     1998-06-17     2021-01-01    308         117.  Cadre                    Femme 2021-11-05 \n 2 173         2     1     Qualifié     1998-06-17     2022-01-01    365          98.3 Cadre                    Femme 2023-01-01 \n 3 173         2     1     Qualifié     1998-06-17     2022-01-06    185         215.  Cadre                    Femme 2022-07-10 \n 4 173         2     1     Non qualifié 1998-06-17     2023-01-02    365          84.7 Cadre                    Femme 2024-01-02 \n 5 174         1     1     Qualifié     1984-12-08     2021-08-17    183          65.9 Cadre                    Homme 2022-02-16 \n 6 175         1     1     Qualifié     1989-09-16     2022-12-21    730         148.  Cadre                    Homme 2024-12-20 \n 7 198         2     3     Non qualifié 1987-03-17     2022-07-28     30          89.6 Employé                  Femme 2022-08-27 \n 8 198         2     3     Qualifié     1987-03-17     2022-11-17    164         100.  Employé                  Femme 2023-04-30 \n 9 198         2     3     Qualifié     1987-03-17     2023-02-21    365          49.3 Employé                  Femme 2024-02-21 \n10 168         1     2     Qualifié     2002-07-30     2019-09-04    365         148.  Profession intermédiaire Homme 2020-09-03 \n# ℹ more rows\n```\n:::\n:::\n:::\n## Sélectionner l'ensemble des variables numériques de la base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Colonnes;set donnees_sas (keep = _numeric_);run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNumeriques <- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNumeriques <- donnees_tidyverse %>% select_if(is.numeric)\nvarNumeriques <- donnees_tidyverse %>% select(where(is.numeric))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsel <- donnees_datatable[, .SD, .SDcols = is.numeric]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select_if(is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 7]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   duree note_contenu note_formateur note_moyens note_accompagnement note_materiel poids_sondage\n   <int>        <int>          <int>       <int>               <int>         <int>         <dbl>\n 1   308           12              6          17                   4            19         117. \n 2   365            6             NA          12                   7            14          98.3\n 3   185            8             10          11                   1             9         215. \n 4   365           14             15          15                  10             8          84.7\n 5   183           17             18          20                  15            12          65.9\n 6   730            5              5           8                   4             9         148. \n 7    30           10             10          10                  16             8          89.6\n 8   164           11              7           6                  14            13         100. \n 9   365            9             20           3                   4            17          49.3\n10   365           18             11          20                  13            15         148. \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\n# requete_duckdb %>% select(where(is.numeric))\n```\n:::\n:::\n## Sélectionner l'ensemble des variables de format \"Date\" \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var where format not in (\"$\", \"\");\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarDates <- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]\nvarDates <- Filter(is.Date, donnees_rbase)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarDates <- donnees_tidyverse %>% select_if(is.Date)\nvarDates <- donnees_tidyverse %>% select(where(is.Date))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvar_dates <- donnees_datatable[, .SD, .SDcols = is.Date]\n\n# Sélection de lignes\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% select_if(is.Date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   date_naissance date_entree date_sortie\n   <date>         <date>      <date>     \n 1 1998-06-17     2021-01-01  2021-11-05 \n 2 1998-06-17     2022-01-01  2023-01-01 \n 3 1998-06-17     2022-01-06  2022-07-10 \n 4 1998-06-17     2023-01-02  2024-01-02 \n 5 1984-12-08     2021-08-17  2022-02-16 \n 6 1989-09-16     2022-12-21  2024-12-20 \n 7 1987-03-17     2022-07-28  2022-08-27 \n 8 1987-03-17     2022-11-17  2023-04-30 \n 9 1987-03-17     2023-02-21  2024-02-21 \n10 2002-07-30     2019-09-04  2020-09-03 \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\n# requete_duckdb %>% select(where(is.Date))\n```\n:::\n:::\n## Sélectionner des lignes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* 3e ligne */\ndata Ligne3;set donnees_sas (firstobs = 3 obs = 3);run;\n\n/* Sélection des 3 premières lignes et des 3 premières colonnes de la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var\n  where 1 <= varnum <= 3;\nrun;\ndata Top3;\n  set donnees_sas (firstobs = 1 obs = 3 keep = &nom_col.);\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n/* Sélection de lignes */\n/* Entrées en 2023 */\ndata En2023;\n  set donnees_sas (where = (year(date_entree) = 2023));\nrun;\ndata Avant2023_femme;\n  set donnees_sas (where = (year(date_entree) < 2023 and sexe = 2));\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 <- donnees_rbase[1:3, 1:3]\n\n# 3e ligne\nligne3 <- donnees_rbase[3, ]\n\n# Sélection de lignes\n# Entrées en 2023\n# ATTENTION, solution qui ne fonctionne pas toujours bien ! En effet, les valeurs manquantes sont sélectionnées !\nen2023 <- donnees_rbase[lubridate::year(donnees_rbase$date_entree) == 2023, ]\n# Bonnes écritures, qui excluent les valeurs manquantes\nen2023 <- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% c(2023), ]\nen2023 <- donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == 2023), ]\nen2023 <- subset(donnees_rbase, lubridate::year(donnees_rbase$date_entree) == 2023)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 <- donnees_tidyverse %>% slice(1:3) %>% select(1:3)\n\n# 3e ligne\nligne3 <- donnees_tidyverse %>% slice(3)\n\n# Sélection de lignes\n# Entrées en 2023\nen2023 <- donnees_tidyverse %>% filter(lubridate::year(date_entree) == 2023)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntop3 <- donnees_datatable[1:3, 1:3]\n\n# 3e ligne\nligne3 <- donnees_datatable[3, ]\nligne3 <- donnees_datatable[3]\n\n# Sélection de lignes\n# Entrées en 2023\n# Pas de problème avec les valeurs manquantes comme pour la syntaxe en R-Base\nen2023 <- donnees_datatable[lubridate::year(date_entree) == 2023, ]\nen2023 <- donnees_datatable[lubridate::year(date_entree) == 2023]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n\nDuckDB, moteur SQL, ne respecte pas l'ordre des lignes. Il faut passer par un filtre ou choisir explicitement un ordre.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% filter(lubridate::year(date_entree) == 2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [5 x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  <chr>       <chr> <chr> <chr>       <date>         <date>      <int>        <int>          <int>       <int>               <int>\n1 173         2     1     Non qualif… 1998-06-17     2023-01-02    365           14             15          15                  10\n2 198         2     3     Qualifié    1987-03-17     2023-02-21    365            9             20           3                   4\n3 112         1     3     Qualifié    2001-09-13     2023-12-01    365            9             NA          NA                  NA\n4 099         1     4     Qualifié    1998-06-06     2023-03-01    364           12             11          10                  12\n5 187         2     2     Qualifié    1986-12-05     2023-01-01    364           10             10          10                  10\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n\n:::\n\n## Sélection sur de multiples conditions \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Ecriture incorrecte. Les valeurs manquantes sont considérées comme des nombres négatifs faibles, et inférieurs à 2023. */\n/* Ils sont sélectionnés dans le code suivant : */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) < 2023 and sexe = 2));\nrun;\n/* Ecriture correcte */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) < 2023 and not missing(date_entree) and sexe = 2));\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\navant2023_femme <- subset(donnees_rbase, lubridate::year(date_entree) < 2023 & sexe == \"2\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\navant2023_femme <- donnees_tidyverse %>% \n  filter(lubridate::year(date_entree) < 2023 & sexe == \"2\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\navant2023_femme <- donnees_datatable[lubridate::year(date_entree) < 2023 & sexe == \"2\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% \n  filter(lubridate::year(date_entree) < 2023 & sexe == \"2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [8 x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  <chr>       <chr> <chr> <chr>       <date>         <date>      <int>        <int>          <int>       <int>               <int>\n1 173         2     1     Qualifié    1998-06-17     2021-01-01    308           12              6          17                   4\n2 173         2     1     Qualifié    1998-06-17     2022-01-01    365            6             NA          12                   7\n3 173         2     1     Qualifié    1998-06-17     2022-01-06    185            8             10          11                   1\n4 198         2     3     Non qualif… 1987-03-17     2022-07-28     30           10             10          10                  16\n5 198         2     3     Qualifié    1987-03-17     2022-11-17    164           11              7           6                  14\n6 211         2     3     Non qualif… NA             2021-12-17    135           16             16          15                  12\n7 087         2     4     Non qualif… NA             2020-10-31    365           NA             NA          11                  NA\n8 187         2     2     Qualifié    1986-12-05     2022-01-01    364           10             10          10                  10\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n:::\n## Sélection de ligne par référence : lignes de l'identifiant 087 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant;\n%let sel = 087;\ndata Selection;\n  set donnees_sas;\n  if &var. in (\"&sel.\");\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nsel <- \"087\"\ndonnees_rbase[donnees_rbase[, variable] %in% sel, ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% filter(identifiant %in% c(\"087\")) %>% select(identifiant)\ndonnees_tidyverse %>% filter(identifiant == \"087\") %>% select(identifiant)\n# Essayons désormais par variables\nvariable <- \"identifiant\"\nsel <- \"087\"\n# À FAIRE : peut-on faire plus simplement ?\ndonnees_tidyverse %>% filter(get(variable) %in% sel) %>% select(all_of(variable))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nsel <- \"087\"\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% filter(identifiant %in% c(\"087\")) %>% select(identifiant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [2 x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant\n  <chr>      \n1 087        \n2 087        \n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% filter(identifiant == \"087\") %>% select(identifiant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [2 x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant\n  <chr>      \n1 087        \n2 087        \n```\n:::\n\n```{.r .cell-code}\n# Essayons désormais par variables\nvariable <- \"identifiant\"\nsel <- \"087\"\n# À FAIRE : peut-on faire plus simplement ?\nrequete_duckdb %>% filter(.data[[variable]] %in% sel) %>% select(all_of(variable))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [2 x 1]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n  identifiant\n  <chr>      \n1 087        \n2 087        \n```\n:::\n:::\n:::\n## Sélection de lignes et de variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let cols = identifiant note_contenu sexe;\ndata Femmes;\n  set donnees_sas (where = (Sexe = 2) keep = &cols.);\nrun;\ndata Femmes;\n  set donnees_sas;\n  if Sexe = 2;\n  keep &cols.;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop Sexe;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes <- donnees_rbase[donnees_rbase$sexe %in% c(\"2\"), cols]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes <- donnees_tidyverse %>% filter(sexe == \"2\") %>% select(all_of(cols))\nfemmes <- donnees_tidyverse %>% filter(sexe == \"2\") %>% select({{cols}})\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes <- donnees_datatable[sexe == \"2\", ..cols]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncols <- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nrequete_duckdb %>% filter(sexe == \"2\") %>% select(all_of(cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 4]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe  date_naissance\n   <chr>              <int> <chr> <date>        \n 1 173                   12 2     1998-06-17    \n 2 173                    6 2     1998-06-17    \n 3 173                    8 2     1998-06-17    \n 4 173                   14 2     1998-06-17    \n 5 198                   10 2     1987-03-17    \n 6 198                   11 2     1987-03-17    \n 7 198                    9 2     1987-03-17    \n 8 211                   16 2     NA            \n 9 347                   12 2     1955-09-13    \n10 087                   NA 2     NA            \n# ℹ more rows\n```\n:::\n\n```{.r .cell-code}\nrequete_duckdb %>% filter(sexe == \"2\") %>% select({{cols}})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 4]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant note_contenu sexe  date_naissance\n   <chr>              <int> <chr> <date>        \n 1 173                   12 2     1998-06-17    \n 2 173                    6 2     1998-06-17    \n 3 173                    8 2     1998-06-17    \n 4 173                   14 2     1998-06-17    \n 5 198                   10 2     1987-03-17    \n 6 198                   11 2     1987-03-17    \n 7 198                    9 2     1987-03-17    \n 8 211                   16 2     NA            \n 9 347                   12 2     1955-09-13    \n10 087                   NA 2     NA            \n# ℹ more rows\n```\n:::\n:::\n:::\n\n# Manipuler des lignes et des colonnes \n\n\n\n## Renommer des variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata donnees_sas;\n  set donnees_sas (rename = (sexe = sexe2));\n  rename sexe2 = sexe;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On renomme la variable sexe en sexe_red\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe\"] <- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe_red\"] <- \"sexe\"\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On renomme la variable sexe en sexe_red\ndonnees_tidyverse <- donnees_tidyverse %>%\n  rename(sexe_red = sexe)\n# On la renomme en sexe\ndonnees_tidyverse <- donnees_tidyverse %>%\n  rename(sexe = sexe_red)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On renomme la variable sexe en sexe_red\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe\"] <- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe_red\"] <- \"sexe\"\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetnames(donnees_datatable, \"sexe\", \"sexe_red\")\nsetnames(donnees_datatable, \"sexe_red\", \"sexe\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On renomme la variable sexe en sexe_red\nrequete_duckdb %>% rename(sexe_red = sexe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [?? x 16]\n# Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n   identifiant sexe_red csp   niveau  date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   <chr>       <chr>    <chr> <chr>   <date>         <date>      <int>        <int>          <int>       <int>               <int>\n 1 173         2        1     Qualif… 1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2        1     Qualif… 1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2        1     Qualif… 1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2        1     Non qu… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1        1     Qualif… 1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1        1     Qualif… 1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2        3     Non qu… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2        3     Qualif… 1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2        3     Qualif… 1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1        2     Qualif… 2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel <int>, poids_sondage <dbl>, cspf <chr>, sexef <chr>, date_sortie <date>\n```\n:::\n:::\n:::\n## Formater les modalités des valeurs \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Utilisation des formats */\nproc format;\n  /* Variable discrète */\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n\n  /* Variable continue */\n  value agef\n  low-<26 = \"1. De 15 à 25 ans\"\n  26<-<50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\n\n  /* Variable caractère */\n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsexef <- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf <- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsexef_format <- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf_format <- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsexeform <- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspform <- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\nPréférer `case_match` quand il s'agit de valeurs déterminées.\n\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% \n  mutate(sexef = case_when(\n    sexef==\"1\" ~ \"Homme\",\n    sexef==\"2\" ~ \"Femme\",\n    .default = sexef),\n         cspf = case_match(csp,\n    \"1\" ~ \"Cadre\",\n    \"2\" ~ \"Profession intermédiaire\",\n    \"3\" ~ \"Employé\",\n    \"4\" ~ \"Ouvrier\",\n    \"5\" ~ \"Retraité\",\n    .default = csp)) %>% \n  select(Sexe, sexef, csp, cspf)\n```\n:::\n\n:::\n## Utiliser les formats \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata donnees_sas;\n  set donnees_sas;\n  /* Exprimer dans le format sexef (Hommes / Femmes) */\n  format Sexef $25.;\n  Sexef = put(Sexe, sexef.);\n  /* On exprime la CSP en texte dans une variable CSPF avec le format */\n  format CSPF $25.;\n  CSPF = put(CSP, $cspf.);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On exprime CSP et sexe en formaté\ndonnees_rbase$cspf <- cspf[donnees_rbase$csp]\ndonnees_rbase$sexef <- sexef[donnees_rbase$sexe]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On exprime CSP et sexe en formaté\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(sexef = sexef_format[sexe],\n         cspf = cspf_format[csp])\n\n# Autre solution\n# Les éventuelles valeurs manquantes sont conservées en NA\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(\n    sexef = case_when(\n      sexe == \"1\" ~ \"Homme\",\n      sexe == \"2\" ~ \"Femme\",\n      TRUE        ~ sexe),\n    cspf = case_when(\n      csp == \"1\" ~ \"Cadre\",\n      csp == \"2\" ~ \"Profession intermédiaire\",\n      csp == \"3\" ~ \"Employé\",\n      csp == \"4\" ~ \"Ouvrier\",\n      csp == \"5\" ~ \"Retraité\",\n      TRUE       ~ csp)\n    )\n# Syntaxe pour attribuer une valeur aux NA\nvaleurAuxNA <- donnees_tidyverse %>% \n  mutate(sexef = case_when(\n    sexe == \"1\" ~ \"Homme\",\n    sexe == \"2\" ~ \"Femme\",\n    is.na(x)    ~ \"Inconnu\",\n    TRUE        ~ sexe))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On exprime CSP et sexe en formaté\ndonnees_datatable[, `:=` (cspf = cspform[csp], sexef = sexeform[sexe])]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n:::\n## Transformer le format d'une variable\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata donnees_sas;\n  set donnees_sas;\n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique <- as.numeric(donnees_rbase$sexe)\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere <- as.character(donnees_rbase$sexe_numerique)\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r <- lubridate::dmy(\"01/01/2000\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE\n#enNumerique <- c(\"Duree\", \"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\")\n#enDate <- c('Date_naissance', 'Date_entree')\n#\n#requete_duckdb %>%  \n#  mutate_at(enNumerique, as.integer) %>% \n#  mutate(poids_sondage=as.numeric(poids_sondage)) %>%\n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n#  select(enDate, Duree, Note_Contenu)\n#\n```\n:::\nNote : `duckdb` fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.\n:::\n## Création et suppressions de plusieurs variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Manipulation de colonnes par référence */\ndata Creation;\n  set donnees_sas;\n  note_contenu2 = note_contenu / 20 * 5;\n  note_formateur2 = note_formateur / 20 * 5;\n  /* Suppression des variables créées */\n  drop note_contenu2 note_formateur2;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop note2;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase$note2 <- donnees_rbase$note_contenu / 20 * 5\n# Le with permet de s'affranchir des expressions \"donnees_rbase$\"\nwith(donnees_rbase, note2 <- note_contenu / 20 * 5)\ndonnees_rbase <- transform(donnees_rbase, note2 = note_contenu / 20 * 5)\n# On ne peut pas utiliser transform pour des variables récemment créées\n#donnees_rbase <- transform(donnees_rbase, note3 = note_contenu ** 2, note3 = log(note3))\n\n# Suppression de variables\ndonnees_rbase$note2 <- NULL\n\n# Création et suppressions de plusieurs variables\ndonnees_rbase <- transform(donnees_rbase, note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)\n# Suppression des variables créées\nvariable <- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_rbase[, variable] <- NULL\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(note2 = note_contenu / 20 * 5)\n\n# Suppression de variables\ndonnees_tidyverse <- donnees_tidyverse %>% \n  select(-note2)\n\n# Création et suppressions de plusieurs variables\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(note_contenu2 = note_contenu / 20 * 5,\n         note_formateur2 = note_formateur / 20 * 5)\n\n# Suppression des variables créées\nvariable <- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_tidyverse <- donnees_tidyverse %>% \n  select(-all_of(variable))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Création de variables\ndonnees_datatable[, note2 := note_contenu / 20 * 5]\n\n# Suppression de variables\ndonnees_datatable[, note2 := NULL]\n\n# Création et suppressions de plusieurs variables\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := list(note_contenu / 20 * 5, note_formateur / 20 * 5)]\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\n# Suppression des variables créées\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := NULL]\n# Ou par référence extérieure\nvariable <- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\ndonnees_datatable[, (variable) := NULL]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : à compléter !\n# Création de la colonne note2\nrequete_duckdb %>% \n  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %>% \n  select(note2)\n\n# Suppression de colonnes\n#requete_duckdb %>% select(- CSP, -contains(\"Date\"), -starts_with(\"Note\"))\n```\n:::\n:::\n## On souhaite réexprimer toutes les notes sur 100 et non sur 20 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime d'abord les doubles blancs entre les variables */\n%let notes = %sysfunc(compbl(&notes.));\n/* on affiche les notes dans la log de SAS */\n%put &notes;\n/* 1ère solution : avec les array */\n/* Les variables sont modifiées dans cet exemple */\ndata Sur100_1;\n  set donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun;\n/* 2e solution : avec une macro */\n/* De nouvelles variables sont ajoutées dans cet exemple */\ndata donnees_sas;\n  set donnees_sas;\n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n\t  %let note = %scan(&notes., &i.);\n\t  &note._100 = &note. / 20 * 100;\n\t%end;\n  %mend Sur100;\n  %Sur100;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes <- names(donnees_rbase)[grepl(\"^note\", names(donnees_rbase))]\n# Les variables sont modifiées dans cet exemple\nsur100 <- donnees_rbase[, notes] / 20 * 100\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\ndonnees_rbase[, paste0(notes, \"_100\")] <- donnees_rbase[, notes] / 20 * 100\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les variables sont modifiées dans cet exemple\nsur100 <- donnees_tidyverse %>% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100))\n\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\nnotes <- names(donnees_tidyverse)[grepl(\"^note\", names(donnees_tidyverse))]\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100, .names = \"{.col}_100\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes <- names(donnees_datatable)[grepl(\"^note\", names(donnees_datatable))]\n# Les variables sont modifiées dans cet exemple\nsur100 <- copy(donnees_datatable)\nsur100 <- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\nsur100 <- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SD = notes]\n# Ou encore, plus simple\n# Dans cet exemple, les notes dans la base donnees_datatable ne sont pas changées\nsur100 <- sur100[, lapply(.SD, function(x) x / 20 * 100), .SDcols = patterns(\"^note\")]\n# On  souhaite conserver les notes sur 20 dans d'autres variables, suffixées par _20\ndonnees_datatable[, (paste0(notes, \"_100\")) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% \n  mutate(across(starts_with(\"note\"), ~ as.numeric(.x)/20*100)) %>% \n  select(starts_with(\"note\"))\n```\n:::\n:::\n## Création de variables avec des conditions \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Civilite;\n  set donnees_sas;\n  /* 1ère solution */\n  format Civilite $20.;\n  if      Sexe = 2 then Civilite = \"Mme\";\n  else if Sexe = 1 then Civilite = \"Mr\";\n  else                  Civilite = \"Inconnu\";\n  /* 2e solution (do - end) */\n  if      Sexe = 2 then do;\n    Civilite2 = \"Femme\";\n  end;\n  else if Sexe = 1 then do;\n    Civilite2 = \"Homme\";\n  end;\n  else do;\n    Civilite2 = \"Inconnu\";\n  end;\n  /* 3e solution */\n  format Civilite3 $20.;\n  select;\n    when      (Sexe = 2) Civilite3 = \"Femme\";\n    when      (Sexe = 1) Civilite3 = \"Homme\";\n    otherwise            Civilite3 = \"Inconnu\";\n  end;\n  keep Sexe Civilite Civilite2 Civilite3;run;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase$civilite <- ifelse(donnees_rbase$sexe == \"2\", \"Mme\", \n                           ifelse(donnees_rbase$sexe == \"1\", \"M\", \n                                  \"Inconnu\"))\n# Autre solution\ndonnees_rbase$civilite <- \"Inconnu\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"1\"] <- \"M\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"2\"] <- \"Mme\"\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(civilite = case_when(sexe == \"2\" ~ \"Mme\",\n                              sexe == \"1\" ~ \"M\",\n                              TRUE        ~ \"Inconnu\")\n)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, civilite := fcase(sexe == \"2\", \"Mme\",\n                                      sexe == \"1\", \"M.\",\n                                      is.na(sexe), \"Inconnu\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n:::\n## Manipuler les dates \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */\n%let sixmois = %sysevalf(365.25/2);\n%put sixmois : &sixmois.;\ndata donnees_sas;\n  set donnees_sas;\n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\n  /* Âge formaté */\n  Agef = put(Age, agef.);\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);  \n  /* La durée du contrat est-elle inférieure à 6 mois ? */\n  Duree_Inf_6_mois = (Duree < &sixmois. & Duree ne .);\n  /* Deux manières de créer une date */\n  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;\n  Decembre_31_&an._a = \"31dec&an.\"d;\n  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */\n  Decembre_31_&an._b = mdy(12, 31, &an.); \n  /* Date 6 mois après la sortie */\n  format Date_6mois ddmmyy10.;\n  Date_6mois = intnx('month', date_sortie, 6);\nrun;\n/* Ventilation pondérée (cf. infra) */\nproc freq data = donnees_sas;tables apres_31_decembre;weight poids_sondage;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age <- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n# Âge formaté\ndonnees_rbase$agef[donnees_rbase$age < 26]                           <- \"1. De 15 à 25 ans\"\n# 26 <= donnees_rbase$age < 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 <= donnees_rbase$age & donnees_rbase$age < 50] <- \"2. De 26 à 49 ans\"\ndonnees_rbase$agef[donnees_rbase$age >= 50]                          <- \"3. 50 ans ou plus\"\n# Autre solution\n# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[\nagef <- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n# Manipuler les dates\nsixmois <- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_rbase$duree_inf_6_mois <- ifelse(donnees_rbase$duree < sixmois, 1, 0)\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie <- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"), origin = \"1970-01-01\")\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_rbase$date_6mois <- donnees_rbase$date_sortie + lubridate::month(6)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Âge à l'entrée dans le dispositif\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n# Âge formaté\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(agef = case_when(\n    age < 26             ~ \"1. De 15 à 25 ans\",\n    age >= 26 & age < 50 ~ \"2. De 26 à 49 ans\",\n    age >= 50            ~ \"3. 50 ans ou plus\")\n    )\n\n\n# Manipuler les dates\nsixmois <- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(duree_inf_6_mois = case_when(duree <  sixmois ~ 1,\n                                      duree >= sixmois ~ 0))\ndonnees_tidyverse %>% pull(duree_inf_6_mois) %>% table()\n\n# Date de sortie du dispositif\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(date_6mois = date_sortie + lubridate::month(6))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), \"years\"))]\n\n# Âge formaté\ndonnees_datatable[, agef := fcase(age < 26,             \"1. De 15 à 25 ans\",\n                                  26 <= age & age < 50, \"2. De 26 à 49 ans\",\n                                  age >= 50,            \"3. 50 ans ou plus\")]\n\n# Manipuler les dates\nsixmois <- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_datatable[, duree_inf_6_mois := ifelse(duree >= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fifelse(duree >= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fcase(duree >= sixmois, 1,\n                                              duree <  sixmois, 0)]\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_datatable[, date_6mois := date_sortie + lubridate::month(6)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Création de la colonne age \nrequete_duckdb %>% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %>% \n  select(age)\n\n# Âge formaté\nrequete_duckdb %>%\n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %>% \n  mutate(agef = case_when(\n    age < 26 ~ \"1. De 15 à 25 ans\",\n    age >= 26 | age < 50 ~  \"2. De 26 à 49 ans\",\n    age >= 50 ~ \"3. 50 ans ou plus\")) %>% \n  select(age, agef)\n```\n:::\n:::\n## Mettre un 0 devant un nombre \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Zero_devant;\n  set donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n  Mois = month(date_entree);\n  Annee = year(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois <= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Obtenir le mois et la date\ndonnees_rbase$mois <- lubridate::month(donnees_rbase$date_entree)\ndonnees_rbase$annee <- lubridate::year(donnees_rbase$date_entree)\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois <= 9)\ndonnees_rbase$mois <- sprintf(\"%02d\", donnees_rbase$mois)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(mois = sprintf(\"%02d\", lubridate::month(date_entree)))\n# Autre solution\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(mois = lubridate::month(date_entree),\n         mois = ifelse(str_length(mois) < 2, paste0(\"0\", mois), mois))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Obtenir le mois et la date\ndonnees_datatable[, `:=`(mois = lubridate::month(date_entree), annee = lubridate::year(donnees_datatable$date_entree))]\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois <= 9)\ndonnees_datatable[, mois := sprintf(\"%02d\", mois)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : pas exactement au bon endroit\n#requete_duckdb %>% \n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n#  mutate(mois=lubridate::month(Date_entree),\n#         mois=ifelse(str_length(mois)<2, paste0(\"0\", mois), mois)) %>% \n#  select(mois, Date_entree)\n```\n:::\n:::\n## Arrondir une valeur numérique \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Arrondis;\n  set donnees_sas (keep = poids_sondage);\n  /* Arrondi à l'entier le plus proche */\n  poids_arrondi_0 = round(poids_sondage);\n  /* Arrondi à 1 chiffre après la virgule */\n  poids_arrondi_1 = round(poids_sondage, 0.1);\n  /* Arrondi à 2 chiffre après la virgule */\n  poids_arrondi_2 = round(poids_sondage, 0.2);\n  /* Arrondi à l'entier inférieur */\n  poids_inf = floor(poids_sondage);\n  /* Arrondi à l'entier supérieur */\n  poids_sup = ceil(poids_sondage);  \nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 <- round(donnees_rbase$poids_sondage, 0)\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 <- round(donnees_rbase$poids_sondage, 1)\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 <- round(donnees_rbase$poids_sondage, 2)\n# Arrondi à l'entier inférieur\npoids_inf <- floor(donnees_rbase$poids_sondage)\n# Arrondi à l'entier supérieur\npoids_sup <- ceiling(donnees_rbase$poids_sondage)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Arrondi à l'entier le plus proche\n  mutate(poids_arrondi_0 = round(poids_sondage, 0)) %>% \n  # Arrondi à 1 chiffre après la virgule\n  mutate(poids_arrondi_1 = round(poids_sondage, 1)) %>% \n  # Arrondi à 2 chiffre après la virgule\n  mutate(poids_arrondi_2 = round(poids_sondage, 2)) %>% \n  # Arrondi à l'entier inférieur\n  mutate(poids_inf = floor(poids_sondage)) %>% \n  # Arrondi à l'entier supérieur\n  mutate(poids_sup = ceiling(poids_sondage))\ndonnees_tidyverse %>% select(starts_with(\"poids\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Arrondi à l'entier le plus proche\ndonnees_datatable[, poids_arrondi_0 := round(poids_sondage, 0)]\n# Arrondi à 1 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_1 := round(poids_sondage, 1)]\n# Arrondi à 2 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_2 := round(poids_sondage, 2)]\n# Arrondi à l'entier inférieur\ndonnees_datatable[, poids_inf := floor(poids_sondage)]\n# Arrondi à l'entier supérieur\ndonnees_datatable[, poids_sup := ceiling(poids_sondage)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrequete_duckdb %>% \n  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne\n    poids_arrondi_0 = round(as.numeric(poids_sondage),0),\n    poids_arrondi_1 = round(as.numeric(poids_sondage),1),\n    poids_arrondi_2 = round(as.numeric(poids_sondage),-1),\n    poids_floor = floor(as.numeric(poids_sondage)),\n    poids_ceiling = ceiling(as.numeric(poids_sondage)),\n    ) %>% \n  select(starts_with(\"poids\"))\n```\n:::\n:::\n\n# Les tris \n\n\n\n\n## Trier les colonnes de la base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On met identifiant, date_entree au début de la base */\n%let colTri = identifiant date_entree;\ndata donnees_sas;\n  retain &colTri.;\n  set donnees_sas;\nrun;\n/* Autre solution */\nproc sql;\n  create table donnees_sas as\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from donnees_sas;\nquit;\n/* Mettre la variable poids_sondage au début de la base */\ndata donnees_sas;\n  retain poids_sondage;\n  set donnees_sas;\nrun;\n/* Mettre la variable poids_sondage à la fin de la base */\nproc contents data = donnees_sas out = var;run;\nproc sql noprint;\n  select name into :var separated by \" \" from var\n  where lowcase(name) ne \"poids_sondage\" order by varnum;\nquit;\ndata donnees_sas;\n  retain &var. poids_sondage;\n  set donnees_sas;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Mettre les variables identifiant, date_entree au début de la base\ncolTri <- c(\"identifiant\", \"date_entree\")\ndonnees_rbase <- donnees_rbase[, union(colTri, colnames(donnees_rbase))]\n# Autre possibilité, plus longue !\ndonnees_rbase <- donnees_rbase[, c(colTri, setdiff(colnames(donnees_rbase), colTri))]\ndonnees_rbase <- donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n# Mettre la variable poids_sondage au début de la base\ndonnees_rbase <- donnees_rbase[, c(\"poids_sondage\", setdiff(colnames(donnees_rbase), \"poids_sondage\"))]\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_rbase <- donnees_rbase[, c(setdiff(colnames(donnees_rbase), \"poids_sondage\"), \"poids_sondage\")]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Mettre les variables identifiant, date_entree et date_sortie au début de la base\ndonnees_tidyverse <- donnees_tidyverse %>%\n  relocate(identifiant, date_entree)\n# Autres solutions\ncolTri <- c(\"identifiant\", \"date_entree\")\ndonnees_tidyverse <- donnees_tidyverse %>%\n  relocate(all_of(colTri))\ndonnees_tidyverse_tri <- donnees_tidyverse %>% \n  select(all_of(colTri), everything())\n\n\n# Mettre la variable poids_sondage au début de la base\ndonnees_tidyverse <- donnees_tidyverse %>%\n  relocate(poids_sondage)\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_tidyverse <- donnees_tidyverse %>%\n  relocate(poids_sondage, .after = last_col())\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On met identifiant, date_entree au début\ncolTri <- c(\"identifiant\", \"date_entree\")\ntri <- union(colTri, colnames(donnees_datatable))\ndonnees_datatable <- donnees_datatable[, ..tri]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetcolorder(donnees_datatable, colTri)\n\n# Mettre la variable poids_sondage au début de la base\nsetcolorder(donnees_datatable, union(\"poids_sondage\", colnames(donnees_datatable)))\n# Mettre la variable poids_sondage à la fin de la base\nsetcolorder(donnees_datatable, c(setdiff(colnames(donnees_datatable), \"poids_sondage\"), \"poids_sondage\"))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On met identifiant date_entree au début\nrequete_duckdb %>% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n  select(identifiant, date_entree, everything())\nrequete_duckdb %>% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb\n  relocate(identifiant, date_entree)\n```\n:::\n\n\n:::\n\n## Trier les lignes (par ordre décroissant \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* 1ère possibilité */\nproc sort data = donnees_sas;by Identifiant Date_entree;run;\n/* 2e possibilité */\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree;\nquit;\n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée */\nproc sort data = donnees_sas;by Identifiant descending Date_entree;run;\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree desc;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE, decreasing = c(FALSE, TRUE), method = \"radix\"), ]\n# Autre possibilité : - devant la variable (uniquement pour les variables numériques)\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$duree, na.last = FALSE), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tri par ordre croissant\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, date_entree)\n# Tri par ordre croissant de identifiant et décroissant de date_entree\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, desc(date_entree))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_datatable <- donnees_datatable[order(identifiant, -date_entree, na.last = FALSE)]\nsetorder(donnees_datatable, \"identifiant\", -\"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Incidence des valeurs manquantes dans les tris \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Dans SAS, les valeurs manquantes sont considérées comme des valeurs négatives */\n/* Elles sont donc situées en premier dans un tri par ordre croissant ... */\nproc sort data = donnees_sas;by identifiant date_entree;run;proc print;run;\n/* ... et en dernier dans un tri par ordre décroissant */\nproc sort data = donnees_sas;by identifiant descending date_entree;run;\nproc print;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree,\n                                     na.last = FALSE,\n                                     decreasing = c(FALSE, TRUE),\n                                     method = \"radix\"), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Attention, avec arrange, les variables manquantes (NA) sont toujours classées en dernier, même avec desc()\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, date_entree)\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, desc(date_entree))\n\n# Or, SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Elles sont donc classées en premier dans un tri par ordre croissant, et en dernier dans un tri par ordre décroissant\n\n# Pour mimer le tri par ordre croissant en SAS : les valeurs manquantes de date_entree sont classées en premier\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, !is.na(date_entree), date_entree)\n# Pour mimer le tri par ordre décroissant en SAS\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(identifiant, desc(date_entree))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_datatable <- donnees_datatable[order(identifiant, date_entree)]\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Pour mimer le tri par ordre décroissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\nrequete_duckdb %>% arrange(Identifiant, Note_Contenu) %>% select(Identifiant, Note_Contenu)\n  \n# Pour mimer le tri SAS, il faut écrire :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %>% select(Identifiant, Note_Contenu) %>% arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu)\n```\n:::\n\n\n:::\n\n## Trier par ordre croissant par toutes les variables de la base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = donnees_sas;by _all_;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntri_toutes_variables <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE)]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntri_toutes_variables <- donnees_tidyverse %>% \n  arrange(pick(everything()))\ntri_toutes_variables <- donnees_tidyverse %>% \n  arrange(across(everything()))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntri_toutes_variables <- setorderv(donnees_datatable, na.last = FALSE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Manipuler des chaînes de caractères \n\n\n\n## Majuscule, minuscule \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Fonction tranwrd (TRANslate WoRD) */\ndata donnees_sas;\n  set donnees_sas;\n  /* Première lettre en majuscule */\n  Niveau = propcase(Niveau);\n  /* En majuscule */\n  CSP_majuscule = upcase(CSPF);\n  /* En minuscule */\n  CSP_minuscule = lowcase(CSPF);\n  /* Nombre de caractères dans une chaîne de caractères */\n  taille_id = length(identifiant);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_rbase$niveau <- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))\n\n# En majuscule\ndonnees_rbase$csp_maj <- toupper(donnees_rbase$cspf)\n# En minuscule\ndonnees_rbase$csp_min <- tolower(donnees_rbase$cspf)\n# Nombre de caractères dans une chaîne de caractères\ndonnees_rbase$taille_id <- nchar(donnees_rbase$identifiant)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_tidyverse <- donnees_tidyverse %>%  \n  mutate(niveau = str_to_title(niveau))\n\n# En majuscule\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(csp_maj = toupper(cspf))\n# En minuscule\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(csp_maj = tolower(cspf))\n# Nombre de caractères dans une chaîne de caractères\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(taille_id = nchar(identifiant))\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(taille_id = str_split(identifiant, '') %>% \n           lengths)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_datatable[, niveau := paste0(toupper(substr(niveau, 1, 1)), tolower(substr(niveau, 2, length(niveau))))]\n\n# En majuscule\ndonnees_datatable[, csp_maj := toupper(cspf)]\n# En minuscule\ndonnees_datatable[, csp_min := tolower(cspf)]\n# Nombre de caractères dans une chaîne de caractères\ndonnees_datatable[, taille_id := nchar(identifiant)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Remplacer une chaîne de caractères par une autre \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata A_Corriger;\n  infile cards dsd dlm='|';\n  format A_corriger $8.;\n  input A_corriger $;\n  cards;\n  Qualifie\n  qualifie\n  Qualifie\n  QUALIFIE\n;\nrun;\ndata A_Corriger;\n  set A_Corriger;\n  Corrige = lowcase(A_corriger);\n  Corrige = tranwrd(Corrige, \"qualifie\", \"Qualifié\");\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger <- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger <- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\naCorriger %>% tolower() %>% str_replace_all(\"[Q-q]ualifie\", \"Qualifié\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger <- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Manipuler des chaînes de caractères \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Exemple_chaines;\n  Texte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\n  Texte1 = \"Je m'appelle\";\n  Texte2 = \"SAS\";\n  Texte3 = \"Phrase à découper\";\n  /* Valeur manquante sous forme caractère */\n  Texte4 = \"\";\nrun;\ndata Exemple_chaines;\n  set Exemple_chaines;\n  /* Enlever les blancs au début et à la fin de la chaîne de caractère */\n  Enlever_Blancs_Initiaux = strip(Texte);\n  /* Enlever les doubles blancs dans la chaîne de caractères */\n  Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\n  /* Enlever doubles blancs */\n  /* REVOIR !!!!! */\n  Enlever_Doubles_Blancs = compress(Texte, \"  \", \"t\");\n  /* Trois méthodes pour concaténer des chaînes de caractères */\n  Concatener  = Texte1||\" \"||Texte2;\n  Concatener2 = Texte1!!\" \"!!Texte2;\n  Concatener3 = catx(\" \", Texte1, Texte2);\n  /* Effet des valeurs manquantes */\n  /* Le séparateur est enlevé lors d'une concaténation avec une chaîne de caractère vide */\n  Concatener4 = catx(\"-\", Texte4, Texte3);\n  /* Extraire les 2e, 3e et 4e caractère de Concatener */\n  /* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */\n  extrait = substr(Concatener, 2, 3);\n  /* Transformer plusieurs caractères différents */\n  /* On transforme le é en e, le â en a, le î en i, ... */\n  chaine = \"éèêëàâçîô\";\n  chaine_sans_accent = translate(chaine, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\nproc print data = Exemple_chaines;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntexte  <- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 <- \"Ce texte\"\ntexte2 <- \"va être\"\ntexte3 <- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 <- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte <- gsub(\"\\\\s+\", \" \", trimws(texte))\n\n\n# Concaténer des chaînes de caractères\nconcatene <- paste(texte1, texte2, texte3, sep = \" \")\npaste0(texte1, texte2, texte3)\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\npaste(texte4, texte3, sep = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait <- substr(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine <- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntexte  <- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 <- \"Ce texte\"\ntexte2 <- \"va être\"\ntexte3 <- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 <- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte <- str_squish(texte)\n\n# Concaténer des chaînes de caractères\nconcatene <- str_flatten(c(texte1, texte2, texte3), collapse = \" \")\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\nstr_flatten(c(texte4, texte3), collapse = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait <- str_sub(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine <- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntexte  <- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 <- \"Je m'appelle\"\ntexte2 <- \"R\"\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte <- gsub(\"\\\\s+\", \" \", trimws(texte))\n# Concaténer des chaînes de caractères\npaste(texte1, texte2, sep = \" \")\npaste0(texte1, texte2)\n\n\n# Extraire les 2e, 3e et 4e caractères de texte\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait <- substr(texte, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine <- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Découper une chaîne de caractères selon un caractère donné \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots */\ndata Mots;\n  delim = \" \";\n  Texte = \"Mon texte va être coupé !\";\n  /* Chaque mot dans une variable */\n  %macro Decouper;\n    %do i = 1 %to %sysfunc(countw(Texte, delim));\n\t  Mot&i. = scan(Texte, &i., delim);\n\t%end;\n  %mend Decouper;\n  %Decouper;\n  /* Les mots empilés */\n  nb_mots = countw(Texte, delim);\n  do nb = 1 to nb_mots;\n    mots = scan(Texte, nb, delim);\n    output;\n  end;\nrun;\nproc print data = Mots;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  <- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Découper une chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  <- \"Mon texte va être coupé !\"\nstr_split(chaine, pattern = \" \") %>% unlist()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  <- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Inverser une chaîne de caractères \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Mots;\n  Texte = \"Mon texte va être coupé !\";\n  x = left(reverse(Texte));\nrun;\nproc print data = Mots;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ninverserTexte <- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n  }\ninverserTexte(chaine)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringi)\nstringi::stri_reverse(chaine)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ninverserTexte <- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n}\ninverserTexte(chaine)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Gestion par groupe \n\n\n\n## Numéroter les lignes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata donnees_sas;\n  set donnees_sas;\n  Num_observation = _n_;\nrun;\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\ndata _NULL_;\n  set donnees_sas nobs = n;\n  call symputx('nbLignes', n);\nrun;\n%put Nombre de lignes : &nbLignes.;\n/* Le merge \"simple\" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */\ndata donnees_sas;\n  merge donnees_sas numLigne;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Numéro de l'observation : 2 manières différentes\ndonnees_rbase$num_observation <- row.names(donnees_rbase)\ndonnees_rbase$num_observation <- seq(1 : nrow(donnees_rbase))\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$un <- 1\ndonnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndonnees_rbase$un <- NULL\n# Autre solution\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat <- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))\n# Autre solution : order pour éviter le as.numeric\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat <- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)\n#https://stackoverflow.com/questions/11996135/create-a-sequential-number-counter-for-rows-within-each-group-of-a-dataframe\n#https://stackoverflow.com/questions/13732062/what-are-examples-of-when-seq-along-works-but-seq-produces-unintended-results\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Numéro de l'observation\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  mutate(num_observation = row_number())\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\n# arrange() va permettre de trier les observations par identifiant et date d'entrée \ndonnees_tidyverse <- donnees_tidyverse %>% \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  mutate(numero_contrat = row_number()) %>% \n  ungroup()\n# À FAIRE : Dans group_by, à quoi sert le drop ?\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Numéro de l'observation : 2 manières différentes\ndonnees_datatable[, num_observation := .I]\ndonnees_datatable[, num_observation := seq_len(.N)]\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\ndonnees_datatable[, numero_contrat := rowid(identifiant)]\ndonnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Numéro de contrat par individu \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */\noptions dkricond=nowarn dkrocond=nowarn;\ndata donnees_sas;\n  set donnees_sas (drop = numero_contrat);\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\noptions dkricond=warn dkrocond=warn;\n/* Pour trier les colonnes */\ndata donnees_sas;\n  retain identifiant date_entree numero_contrat numero_contrat;\n  set donnees_sas;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant), , drop = FALSE]\n\n# Dernière ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1ère ligne par identifiant\ndonnees_tidyverse %>% \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  filter(row_number() == 1) %>% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %>% \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  slice(1) %>% \n  ungroup()\ndonnees_tidyverse %>%  \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  slice_head(n = 1) %>% \n  ungroup()\ndonnees_tidyverse %>%  \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  filter(row_number() == nth(row_number(), 1)) %>%\n  ungroup()\n\n# Dernière ligne par identifiant\ndonnees_tidyverse %>% \ngroup_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  filter(row_number() == n()) %>% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %>%  \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  slice(n()) %>% \n  ungroup()\ndonnees_tidyverse %>%  \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>%\n  filter(row_number() == nth(row_number(), -1)) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Extraire la 1ère ligne par identifiant\ndonnees_datatable[, .SD[1], by = identifiant]\n\n# Extraire la dernière ligne par identifiant\ndonnees_datatable[, .SD[.N], by = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu ... \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  Premier_Contrat = (first.identifiant = 1);\n  Dernier_Contrat = (last.identifiant = 1);\n  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);\nrun;\n\n/* Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats */\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* Création de 2 bases en une seule étape */\ndata Premier_Contrat Dernier_Contrat;\n  set donnees_sas;\n  by identifiant date_entree;\n  if first.identifiant then output Premier_Contrat;\n  if last.identifiant then output Dernier_Contrat;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$premier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = FALSE), 1, 0)\ndonnees_rbase$dernier_contrat <- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = TRUE), 1, 0)\ndonnees_rbase$ni_prem_ni_der  <- ifelse(! c(!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 1, 0)\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\npremier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]\ndernier_contrat <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]\nni_prem_ni_der  <- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Premier contrat\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %>% \n  ungroup()\n# Dernier contrat\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %>% \n  ungroup()\n# Ni le premier, ni le dernier contrat\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %>% \n  ungroup()\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\n# Premier contrat\npremier_contrat <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %>% \n  ungroup()\n# Dernier contrat\ndernier_contrat <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %>% \n  ungroup()\n# Ni le premier, ni le dernier contrat\nni_prem_ni_der <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %>% \n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\ndonnees_datatable[, premier_contrat := fifelse(!duplicated(identifiant, fromLast = FALSE), 1, 0)]\ndonnees_datatable[, dernier_contrat := fifelse(!duplicated(identifiant, fromLast = TRUE), 1, 0)]\ndonnees_datatable[, ni_prem_ni_der := fifelse(! c(!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), 1, 0)]\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\npremier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = FALSE), ]\ndernier_contrat <- donnees_datatable[!duplicated(identifiant, fromLast = TRUE), ]\nni_prem_ni_der  <- donnees_datatable[! (!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Les 2 premières / dernières lignes de chaque identifiant \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Les 2 premières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat <= 2;\nquit;\n/* Les 2 dernières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat >= count(*) - 1;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 2 premières lignes par identifiant (le premier si une seule ligne)\n# Peut-on le faire en moins d'étapes ??? Avec head ?\ndonnees_rbase$a <- 1\ndonnees_rbase$numero_contrat <- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)\ndeux_premieres_lignes <- donnees_rbase[which(donnees_rbase$numero_contrat <= 2), ]\ndonnees_rbase$a <- NULL\n# REVOIR\n#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]\n#ind <- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les deux premières lignes\ndeux_premieres_lignes <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  slice(1:2) %>% \n  ungroup()\n# Les deux dernières lignes\ndeux_dernieres_lignes <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  group_by(identifiant) %>% \n  slice(n() - 2) %>% \n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndeux_premieres_lignes <- donnees_datatable[, .SD[1:2], by = identifiant]\ndeux_dernieres_lignes <- donnees_datatable[, .SD[.N-2:.N], by = identifiant]\n# Version en R Base\n#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## 2e ligne de l'individu (et rien si l'individu a 1 seule ligne) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas;\n  if numero_contrat = 2;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas (where = (numero_contrat = 2));\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Avec le numéro de contrat\ndeuxieme_ligne <- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Autre solution\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-(length(x)-1)])), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  filter(row_number() == 2) %>% \n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndeuxieme_ligne <- donnees_datatable[, .SD[2], by = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## L'avant-dernière ligne de l'individu (et rien si l'individu a 1 seul contrat) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Nécessite d'avoir le numéro du contrat */\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat = count(*) - 1;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  group_by(identifiant) %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  filter(row_number() == nth(row_number(), -2))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, .SD[.N-1], by = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Sélection par groupement \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Personnes qui ont eu au moins une entrée en 2022 */\nproc sql;\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(year(date_entree) = 2022) >= 1;\nquit;\n\n/* Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée */\nproc sql;\n  create table Qualif_Non_Qualif as\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(Niveau = \"Non qualifie\") >= 1 and sum(Niveau = \"Non qualifie\") >= 1;\nquit;\n\n/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022 */\nproc sql;\n  create table Deux_Contrats as\n  select *\n  from donnees_sas\n  group by identifiant\n  having count(*) = 2 and sum(year(date_entree) = 2022) >= 1;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 <- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))\n# Autre solution : ne semble possible que pour une seule variable\nauMoins2022 <- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif <- subset(\n  transform(donnees_rbase, \n            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Qualifié\", 1, 0), na.rm = TRUE)), \n            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Non Qualifié\", 1, 0), na.rm = TRUE))),\n  qualif >= 1 & non_qualif >= 1)\n# https://stackoverflow.com/questions/49669862/how-to-group-by-in-base-r\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats <- subset(\n  transform(donnees_rbase, \n            nb = ave(identifiant, identifiant, FUN = length), \n            an = ave(date_entree, identifiant, FUN = function(x) sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),\n  nb == 2 & an >= 1)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 <- donnees_tidyverse %>% \n  group_by(identifiant) %>%\n  filter(any(lubridate::year(date_entree) == 2022))\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif <- donnees_tidyverse %>% \n  group_by(identifiant) %>%\n  filter(any(niveau == \"Qualifié\")) %>% \n  filter(any(niveau == \"Non qualifié\")) %>% \n  ungroup()\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats <- donnees_tidyverse %>% \n  group_by(identifiant) %>%\n  filter(n() == 2) %>% \n  filter(any(lubridate::year(date_entree) == 2022)) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 <- donnees_datatable[, if(any(lubridate::year(date_entree) %in% 2022)) .SD, by = identifiant]\n# Autre solution\nauMoins2022 <- donnees_datatable[, if (sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) > 0) .SD, by = identifiant]\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n# Group by et Having de SQL\n# https://github.com/Rdatatable/data.table/issues/788\n# 1ère méthode\ndonnees_datatable[, `:=` (qualif = sum(fifelse(niveau == \"Qualifié\", 1, 0), na.rm = TRUE),\n                          non_qualif = sum(fifelse(niveau == \"Non qualifié\", 1, 0), na.rm = TRUE)),\n                by = identifiant][qualif > 0 & non_qualif > 0]\n# 2e méthode un peu plus simple\ndonnees_datatable[, `:=` (qualif = sum(niveau == \"Qualifié\", na.rm = TRUE), non_qualif = sum(niveau == \"Non qualifié\", na.rm = TRUE)), by = identifiant][qualif > 0 & non_qualif > 0]\n# 3e méthode, plus simple !!\ndonnees_datatable[, if (sum(niveau == \"Qualifié\", na.rm = TRUE) > 0 & sum(niveau == \"Non qualifié\", na.rm = TRUE) > 0) .SD, by = identifiant]\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndonnees_datatable[, if (.N == 2 & sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) >= 1) .SD, by = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Ajouter une colonne désignant la note moyenne de Note_Contenu par individu \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* 1ère solution */\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;\n  var Note_Contenu;by identifiant;output out = Temp;\nrun;\ndata Temp;\n  set Temp (where = (_STAT_ = \"MEAN\"));\n  keep identifiant Note_Contenu;\n  rename Note_Contenu = Note_Contenu_Moyenne;\nrun;\ndata donnees_sas;\n  merge donnees_sas (in = a) Temp (in = b);\n  by identifiant;\n  if a;\nrun;\n/* 2e solution : plus souple */\n/* Pour supprimer la variable ajoutée lors de la 1ère solution */\ndata donnees_sas;\n  set donnees_sas (drop = Note_Contenu_Moyenne);\nrun;\nproc sql;\n  create table donnees_sas as\n  select *\n  from donnees_sas a left join\n       (select identifiant, mean(Note_Contenu) as Note_Contenu_Moyenne\n        from donnees_sas group by identifiant) b\n       on a.identifiant = b.identifiant\n  order by identifiant;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase <- transform(donnees_rbase, \n                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), \n                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>%\n  group_by(identifiant) %>%\n  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %>% \n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]\n# Moyenne de chaque note\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_datatable[, paste0(notes, \"_m\") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Variable retardée (lag) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* La date de fin du contrat précédent (lag) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sasBon;\n  set donnees_sas;\n  by identifiant date_entree;  \n  format Date_fin_1 ddmmyy10.;\n  Date_fin_1 = lag(Date_sortie);\n  if first.identifiant then Date_fin_1 = .;\nrun;\n\n/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata Lag_Bon;\n  set donnees_sas (keep = identifiant date_entree date_sortie);\n  format date_sortie_1 lag_faux lag_bon ddmmyy10.;\n  /* Erreur */\n  if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n  /* Bonne écriture */\n  date_sortie_1 = lag(date_sortie);\n  if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# La date de fin du contrat précédent\ndonnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 <- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n# Peut-on aussi utiliser tail(..., -1) ?\n\n# La date du contrat futur (lead)\ndonnees_rbase$date_sortie__1 <- c(donnees_rbase$date_sortie[ 2:(length(donnees_rbase$date_sortie))], as.Date(NA))\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# La date de fin du contrat précédent\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n# La date du contrat futur (lead)\ndonnees_tidyverse <- donnees_tidyverse %>% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %>% \n  mutate(date_sortie__1 = lead(date_sortie))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# La date de fin du contrat précédent\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie_1 := shift(.SD, n = 1, fill = NA, \"lag\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie_1)]\n\n# La date du contrat futur (lead)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie__1 := shift(.SD, n = 1, fill = NA, \"lead\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie__1)]\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Transposer une base \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On commence déjà par calculer un tableau croisé comptant les occurrences */\nproc freq data = donnees_sas;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\n/* On transpose le tableau */\nproc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On commence déjà par calculer un tableau croisé comptant les occurrences\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb <- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\n# On transpose le tableau\nnb_transpose <- as.data.frame(t(nb))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On commence déjà par calculer un tableau croisé comptant les occurrences\nnb <- donnees_tidyverse %>% \n  count(cspf, sexef) %>% \n  spread(sexef, n)\n# On transpose le tableau\nnb_transpose <- nb %>% \n  rownames_to_column() %>% \n  gather(variable, value, -rowname) %>%  \n  spread(rowname, value)\n# Autre solution avec les packages janitor et sjmisc\nlibrary(janitor)\nnb <- donnees_tidyverse %>%\n  janitor::tabyl(cspf, sexef) %>% \n  # colonne cspf comme nom de ligne\n  column_to_rownames(var=\"cspf\")\n\nlibrary(sjmisc)\nnb_transpose <- nb %>%\n  sjmisc::rotate_df()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Etablissement d'un tableau croisé comptant les occurrences\nnb <- donnees_datatable[, .N, by = list(cspf, sexef)]\n# On transpose le tableau\ndata.table::dcast(nb, cspf ~ sexef, value.var = \"N\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Passer d'une base en largeur (wide) à une base en longueur (long) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_rbase <- aggregate(donnees_rbase[, varNotes], donnees_rbase[, \"identifiant\", drop = FALSE], mean, na.rm = TRUE)\nlong_rbase <- reshape(data = wide_rbase,\n                varying = varNotes, \n                v.names = \"notes\",\n                timevar = \"type_note\", \n                times = varNotes,\n                new.row.names = NULL,\n                direction = \"long\")\nlong_rbase <- long_rbase[order(long_rbase$identifiant), ]\nrow.names(long_rbase) <- NULL\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_tidyverse <- donnees_tidyverse %>% \n  group_by(identifiant) %>% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE)))\n# On l'exprime en format long\n# Mise en garde : ne pas écrire value_to !\nlong_tidyverse <- wide_tidyverse %>% \n  pivot_longer(cols = !identifiant,\n               names_to = \"type_note\",\n               values_to = \"note\") %>% \n  arrange(type_note, identifiant)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_datatable <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = identifiant, .SDcols = varNotes]\nlong_datatable <- melt(wide_datatable,\n                       id.vars = c(\"identifiant\"),\n                       measure.vars = varNotes,\n                       variable.name = \"type_note\",\n                       value.name = \"note\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Passer base en longueur (long) à une base en largeur (wide) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On souhaite mettre les notes en ligne et non en colonne */\n/* On commence par calculer les notes moyennes par identifiant */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\ndata Long;set Long (rename = (_NAME_ = Type_Note COL1 = Note));run;\n/* On passe de Long à Wide */\nproc transpose data = Long out = Wide;\n  by Identifiant;\n  var Note;\n  id Type_Note;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Passer de long à wide : on souhaite revenir à la situation initiale\nwide_rbase <- reshape(long_rbase, \n                timevar = \"type_note\",\n                idvar = c(\"identifiant\", \"id\"),\n                direction = \"wide\")\n#https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Passer de long à wide : on souhaite revenir à la situation initiale\n# Mise en garde : ne pas écrire value_from !\nwide_tidyverse <- pivot_wider(long_tidyverse, \n                              names_from = type_note,\n                              values_from = note)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nwide_datatable <- dcast(long_datatable, identifiant ~ type_note, value.var = \"note\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Gestion par rangées de lignes \n\n\n\n## Sélectionner les lignes avec au moins une note < 10 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Inferieure_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n\t%let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n\t  &j._inf_10 = (&j. < 10 and not missing(&j.));\n\t  %let temp = &temp. &j._inf_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  if sum(of &temp.) >= 1;\n  drop &temp.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) any(x < 10, na.rm = TRUE)), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %>%\n  filter(if_any(varNotes, ~ .x < 10))\n# Autre solution\ndonnees_tidyverse %>%\n  filter_at(varNotes, any_vars(. < 10))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_moins_10 <- donnees_datatable[donnees_datatable[, .I[rowSums(.SD < 10, na.rm = TRUE) >= 1], .SDcols = varNotes]]\n# Autre solution\n# Le Reduce(`|`, ...) permet d'appliquer la condition | (ou) à tous les élements de la ligne, qui sont une vérification d'un nb < 10\nnote_moins_10 <- donnees_datatable[donnees_datatable[, Reduce(`|`, lapply(.SD, `<`, 10)), .SDcols = varNotes]]\n\n# https://arelbundock.com/posts/datatable_rowwise/\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Sélectionner les lignes avec toutes les notes supérieurs à 10 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Sup_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n\t%let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n\t  &j._sup_10 = (&j. >= 10);\n\t  %let temp = &temp. &j._sup_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  a = sum(of &temp.);\n  b = %sysfunc(countw(&notes.));\n  if sum(of &temp.) = %sysfunc(countw(&notes.));\n  drop &temp.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# À FAIRE : REVOIR LE PB DES VALEURS MANQUANTES !!!!\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) all(x >= 10, na.rm = TRUE)), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %>%\n  filter(if_all(varNotes, ~ . >= 10))\n# Autre solution\ndonnees_tidyverse %>%\n  filter_at(varNotes, all_vars(. >= 10))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_sup_10 <- donnees_datatable[\n  donnees_datatable[, .I[rowSums(.SD >= 10, na.rm = TRUE) == length(varNotes)], .SDcols = varNotes]]\n# Autre solution\nnote_sup_10 <- donnees_datatable[donnees_datatable[, Reduce(`&`, lapply(.SD, `>=`, 10)), .SDcols = varNotes]]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne par ligne \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n\t                      %let j = %scan(&notes., &i.);\n\t\t\t\t\t\t  &j.\n\t\t\t\t\t\t %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n/* Note moyenne (moyenne des moyennes), non pondérée et pondérée */\nproc means data = donnees_sas mean;var Note_moyenne;run;\nproc means data = donnees_sas mean;var Note_moyenne;weight poids_sondage;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# apply permet d'appliquer une fonctions aux lignes (1) ou colonnes (2) d'un data.frame\ndonnees_rbase$note_moyenne <- apply(donnees_rbase[, varNotes], 1, mean, na.rm = TRUE)\n# Autre possibilité\ndonnees_rbase$note_moyenne <- rowMeans(donnees_rbase[, varNotes], na.rm = TRUE)\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\nmean(donnees_rbase$note_moyenne, na.rm = TRUE)\nweighted.mean(donnees_rbase$note_moyenne, donnees_rbase$poids_sondage, na.rm = TRUE)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Codes à privilégier\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(note_moyenne = rowMeans(pick(all_of(varNotes)), na.rm = TRUE))\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Alternative très lente !\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse <- donnees_tidyverse %>% \n  rowwise() %>% \n  mutate(note_moyenne = mean(c_across(all_of(varNotes)), na.rm = TRUE)) %>% \n  ungroup()\n\n\n# Note moyenne (moyenne des moyennes) non pondérée\ndonnees_tidyverse %>% pull(note_moyenne) %>% mean(na.rm = TRUE)\ndonnees_tidyverse %>% summarise(Moyenne = mean(note_moyenne, na.rm = TRUE))\n# Note moyenne (moyenne des moyennes) pondérée\ndonnees_tidyverse %>% summarise(Moyenne_ponderee = weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes <- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = varNotes]\n# Manière alternative, qui ne semble pas fonctionner\n#donnees_datatable[, note_moyenne := Reduce(function(...) sum(..., na.rm = TRUE), .SD),\n#                  .SDcols = varNotes,\n#                  by = 1:nrow(donnees_datatable)]\n#donnees_datatable[, do.call(function(x, y) sum(x, y, na.rm = TRUE), .SD), .SDcols = varNotes, by = 1:nrow(donnees_datatable)]\n\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\ndonnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## La note donnée est-elle supérieure à la moyenne ? \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On crée une macro-variable SAS à partir de la valeur de la moyenne */\nproc sql noprint;select mean(Note_moyenne) into :moyenne from donnees_sas;quit;\ndata donnees_sas;\n  set donnees_sas;\n  Note_Superieure_Moyenne = (Note_moyenne > &moyenne.);\nrun;\nproc freq data = donnees_sas;tables Note_Superieure_Moyenne;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nmoyenne <- mean(donnees_rbase$note_moyenne, na.rm = TRUE)\ndonnees_rbase$note_superieure_moyenne <- ifelse(donnees_rbase$note_moyenne > moyenne, 1, 0)\ntable(donnees_rbase$note_superieure_moyenne, useNA = \"always\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nmoyenne <- donnees_tidyverse %>% pull(note_moyenne) %>% mean(na.rm = TRUE)\ndonnees_tidyverse <- donnees_tidyverse %>% mutate(note_superieure_moyenne = ifelse(note_moyenne > moyenne, 1, 0))\ndonnees_tidyverse %>% pull(note_superieure_moyenne) %>% table(useNA = \"always\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nmoyenne <- donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, note_superieure_moyenne := fcase(note_moyenne >= moyenne, 1,\n                                                     note_moyenne <  moyenne, 0)]\ntable(donnees_datatable$note_superieure_moyenne, useNA = \"always\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne par ligne \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On souhaite affecter les pondérations suivantes aux notes :\nNote_Contenu : 30%, Note_Formateur : 20%, Note_Moyens : 25%, Note_Accompagnement : 15%, Note_Materiel : 10% */\n/* Voici une solution possible. Une alternative intéressante serait de passer par IML (non traité ici) */\n%let ponderation = 0.3 0.2 0.25 0.15 0.10;\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  %macro Somme_pond;\n    %global temp;\n\t%let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let k = %scan(&notes., &i.);\n\t  %let l = %scan(&ponderation., &i., %str( ));\n\t  &k._pond = &k. * &l.;\n\t  %let temp = &temp. &k._pond;\n\t%end;\n  %mend Somme_pond;\n  %Somme_pond;\n  Note_moyenne_pond = sum(of &temp.);\n  drop &temp.;\nrun;\nproc means data = donnees_sas mean;var Note_moyenne_pond;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation <- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\ndonnees_rbase$note_moyennepond <- apply(donnees_rbase[, notes], 1, function(x) weighted.mean(x, ponderation, na.rm = TRUE))\n# Autre manière, en exploitant le calcul matriciel\n# Ne fonctionne pas, du fait des NA\nas.matrix(donnees_rbase[, notes]) %*% as.matrix(ponderation)\n# Produit élément par élément\n# On peut procéder par produit matriciel\nas.matrix(donnees_rbase[, notes]) * matrix(t(as.matrix(ponderation)), nrow(donnees_rbase), 5)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\n# La fonction RowMeans ne fonctionne plus, cette fois !\nnotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation <- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse <- donnees_tidyverse %>%\n  rowwise() %>%\n  mutate(note_moyenne = weighted.mean(c_across(varNotes), ponderation, na.rm = TRUE)) %>% \n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n## On souhaite affecter les pondérations suivantes aux notes :\n## note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation <- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\ndonnees_datatable[, note_moyenne_pond := rowSums(mapply(FUN = `*`, .SD, ponderation), na.rm = TRUE), .SDcols = names(ponderation)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Les valeurs manquantes \n\n\n\n## Repérer les valeurs manquantes (variables Âge et Niveau) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Missing;\n  set donnees_sas;\n  /* 1ère solution */\n  if missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;\n  /* 2e solution */\n  if age = . or Niveau = '' then missing2 = 1;else missing2 = 0;\n  keep Age Niveau Missing1 Missing2;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase$manquant <- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)\n# Mauvaise méthode pour repérer les valeurs manquantes\nageManquant <- donnees_rbase[donnees_rbase$age == NA,  ]\n# Bonne méthode pour repérer les valeurs manquantes\nageManquant <- donnees_rbase[is.na(donnees_rbase$age), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>% \n  mutate(manquant = ifelse(is.na(age) | is.na(niveau), 1, 0))\n\n# Mauvaise méthode pour repérer les valeurs manquantes\nageManquant <- donnees_tidyverse %>%\n  filter(age == NA)\n# Bonne méthode pour repérer les valeurs manquantes\nageManquant <- donnees_tidyverse %>%\n  filter(is.na(age))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, manquant := fifelse(is.na(donnees_datatable$age) | is.na(donnees_datatable$niveau), 1, 0)]\nageManquant <- donnees_datatable[age == NA] # Faux\nageManquant <- donnees_datatable[is.na(age)] # Correct\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Nombre et proportion de valeurs manquantes par variable \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Pour les variables numériques ou date */\n/* Partie \"Missing Values\" en bas du tableau consacré à la variable */\nproc univariate data = donnees_sas;var _numeric_;run;\n\n/* Pour l'ensemble des variables */\n/* Une solution possible */\n%macro Iteration(base = donnees_sas);\n  %local nbVar;\n  proc contents data = donnees_sas out = ListeVar noprint;run;\n  proc sql noprint;select count(*) into :nbVar from ListeVar;quit;\n  %do i = 1 %to &nbVar.;\n    data _null_;\n      set ListeVar (firstobs = &i. obs = &i.);\n\t  call symput('var', name);\n\trun;\n    proc sql;\n      select max(\"&var.\") as Variable, sum(missing(&var.)) as Manquants, sum(missing(&var.)) / count(*) * 100 as Prop_Manquants\n      from &base.;\n    quit;\n  %end;\n  proc datasets lib = work nolist;delete ListeVar;run;\n%mend Iteration;\n%Iteration;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour les variables numériques ou date\napply(is.na(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))]\n  ), 2, mean) * 100\n# Autres solutions\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) mean(is.na(x)) * 100)\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) sum(is.na(x)) / length(x) * 100)\n\n# Pour l'ensemble des variables\ncolMeans(is.na(donnees_rbase)) * 100\napply(is.na(donnees_rbase), 2, mean) * 100\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour les variables numériques ou date\ndonnees_tidyverse %>%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   list(~sum(is.na(.x)), ~mean(is.na(.x)))))\ndonnees_tidyverse %>%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   list(~sum(is.na(.x)), ~sum(is.na(.x)) / length(.x))))\n\n# Pour l'ensemble des variables\ndonnees_tidyverse %>%\n  summarise(across(everything(), ~mean(is.na(.x))))\n# Autres solutions\ndonnees_tidyverse %>% map(~ mean(is.na(.)) * 100)\n# Obsolète\ndonnees_tidyverse %>% summarise_each(funs(mean(is.na(.)) * 100))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Pour les variables numériques ou date\ndonnees_datatable[, lapply(.SD, function(x) mean(is.na(x)) * 100), .SDcols = function(x) c(lubridate::is.Date(x) | is.numeric(x))]\n# Pour l'ensemble des variables\ndonnees_datatable[, lapply(.SD, function(x) mean(is.na(x)) * 100)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Incidence des valeurs manquantes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* En SAS, les valeurs manquantes sont des nombres négatifs faibles */\ndata Valeur_Manquante;\n  set donnees_sas;\n  /* Lorsque Age est manquant (missing), Jeune_Correct vaut 0 mais Jeune_Incorrect vaut 1 */\n  /* En effet, pour SAS, un Age manquant est une valeur inférieure à 0, donc bien inférieure à 25.\n     Donc la variable Jeune_Incorrect vaut bien 1 pour les âges inconnus */\n  Jeune_Incorrect = (Age <= 25);\n  Jeune_Correct   = (0 <= Age <= 25);\nrun;\nproc print data = Valeur_Manquante (keep  = Age Jeune_Correct Jeune_Incorrect\n                                    where = (missing(Age)));\nrun;\nproc freq data = Valeur_Manquante;tables Jeune_Incorrect Jeune_Correct;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nmean(donnees_rbase$note_formateur)\nmean(donnees_rbase$note_formateur, na.rm = TRUE)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% pull(note_formateur) %>% mean()\ndonnees_tidyverse %>% pull(note_formateur) %>% mean(na.rm = TRUE)\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# NE PAS ECRIRE !\n# donnees_tidyverse %>% mean(note_formateur)\n# donnees_tidyverse %>% mean(note_formateur, na.rm = TRUE)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, mean(note_formateur)]\ndonnees_datatable[, mean(note_formateur, na.rm = TRUE)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Remplacer toutes les valeurs numériques manquantes par 0 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On sélectionne toutes les variables numériques */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var where format = \"\";\nrun;\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  %macro Missing;\n    %local i var;\n    %do i = 1 %to %sysfunc(countw(&nom_col.));\n\t  %let var = %scan(&nom_col., &i);\n\t  if missing(&var.) then &var. = 0;\n\t%end;\n  %mend Missing;\n  %Missing;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Dans le cas des dates, la valeur manquante a été remplacée par 1970-01-01\ndonnees_rbase_sans_na <- donnees_rbase\ndonnees_rbase_sans_na[is.na(donnees_rbase_sans_na)] <- 0\n# On remplace seulement les valeurs numériques par 0\ndonnees_rbase_sans_na <- donnees_rbase\nvarNumeriques <- names(donnees_rbase)[unlist(lapply(donnees_rbase, is.numeric))]\ndonnees_rbase_sans_na[, varNumeriques][is.na(donnees_rbase_sans_na[, varNumeriques])] <- 0\n# Autre solution, avec replace\ndonnees_rbase_sans_na[, varNumeriques] <- lapply(donnees_rbase_sans_na[, varNumeriques],\n                                                 function(x) {replace(x, is.na(x), 0)})\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On remplace seulement les valeurs numériques par 0\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>% \n  mutate(across(where(is.numeric), ~tidyr::replace_na(.x, 0)))\n# Autres façons d'écrire les fonctions anonymes\n# La méthode complète\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>% \n  mutate(across(where(is.numeric), function(x) tidyr::replace_na(x, 0)))\n# Une autre façon de raccourcir (depuis R 4.1)\n# \\(x) est un raccourci pour function(x)\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>% \n  mutate(across(where(is.numeric), \\(x) tidyr::replace_na(x, 0)))\n# Autre solution\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>%\n  purrr::modify_if(is.numeric, ~tidyr::replace_na(.x, 0))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable_sans_na <- copy(donnees_datatable)\nsetnafill(donnees_datatable[, .SD, .SDcols = is.numeric], fill = 0)\n# Autre solution\ndonnees_datatable_sans_na <- copy(donnees_datatable)\ncols <- colnames(donnees_datatable_sans_na[, .SD, .SDcols = is.numeric])\ndonnees_datatable_sans_na[, (cols) := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = cols]\n# Ensemble des colonnes\ndonnees_datatable_sans_na <- copy(donnees_datatable)\ndonnees_datatable_sans_na[is.na(donnees_datatable_sans_na)] <- 0\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Remplacer les valeurs manquantes d'une seule variable par 0 \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = note_contenu;\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  if missing(&var.) then &var. = 0;\n  /* Ou alors */\n  if &var. = . then &var. = 0;\n  /* Ou encore */\n  if note_contenu = . then note_contenu = 0;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"note_contenu\"\ndonnees_rbase_sans_na <- donnees_rbase\ndonnees_rbase_sans_na[, variable][is.na(donnees_rbase_sans_na[, variable])] <- 0\ndonnees_rbase_sans_na[, variable] <- replace(donnees_rbase_sans_na[, variable],\n                                             is.na(donnees_rbase_sans_na[, variable]), 0)\n# Ou alors\ndonnees_rbase_sans_na <- donnees_rbase\ndonnees_rbase_sans_na$note_contenu[is.na(donnees_rbase_sans_na$note_contenu)] <- 0\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"note_contenu\"\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>% \n  mutate(across(variable,  ~tidyr::replace_na(.x, 0)))\n# Ou alors\ndonnees_tidyverse_sans_na <- donnees_tidyverse %>% \n  mutate(note_contenu = tidyr::replace_na(note_contenu, 0))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"note_contenu\"\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, \\(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\n# Ou alors\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = \"note_contenu\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Les doublons \n\n\n\n## Doublons pour toutes les colonnes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On extraie tous les doublons, pas la première occurrence */\n\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var\n  from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata Doublons;\n  set donnees_sas;\n  by &nom_col.;\n  if not (first.&derniere_var. and last.&derniere_var.);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\ndoublons <- donnees_rbase[duplicated(donnees_rbase), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\ndoublons <- donnees_tidyverse %>%  \n  group_by_all() %>% \n  filter(n() > 1) %>%\n  slice(-1) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\ndoublons <- donnees_datatable[duplicated(donnees_datatable), ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Doublons pour une ou plusieurs colonnes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On extraie tous les doublons, pas la première occurrence */\n%let var = identifiant;\nproc sort data = donnees_sas;by &var.;run;\ndata doublons;\n  set donnees_sas;\n  by &var.;\n  if not first.&var.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\nvariable <- \"identifiant\"\ndoublons <- donnees_rbase[duplicated(donnees_rbase[, variable]), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\nvariable <- \"identifiant\"\ndoublons <- donnees_tidyverse %>%  \n  group_by(across(variable)) %>% \n  filter(n() > 1) %>%\n  slice(-1) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On extraie tous les doublons, pas la première occurrence\nvariable <- \"identifiant\"\ndoublons <- donnees_datatable[duplicated(donnees_datatable[, ..variable]), ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Récupérer toutes les lignes pour les identifiants en doublon \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant;\n/* On groupe par la colonne identifiant, et si on aboutit à strictement plus d'une ligne, c'est un doublon */\nproc sql;\n  create table enDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) > 1;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nenDouble <- donnees_rbase[donnees_rbase[, variable] %in%\n                            donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nenDouble <- donnees_tidyverse %>%  \n  group_by(across(variable)) %>% \n  filter(n() > 1) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nenDouble <- donnees_datatable[donnees_datatable[[variable]] %chin%\n                                donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Récupérer toutes les lignes pour les identifiants sans doublon \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var = identifiant;\nproc sql;\n  create table sansDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) = 1;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nsansDouble <- donnees_rbase[! donnees_rbase[, variable] %in%\n                              donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nsansDouble <- donnees_tidyverse %>%  \n  group_by(across(variable)) %>% \n  filter(n() == 1) %>%\n  ungroup()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nvariable <- \"identifiant\"\nsansDouble <- donnees_datatable[! donnees_datatable[[variable]] %chin%\n                                  donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Suppression des doublons pour l'ensemble des variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* 1ère méthode */\nproc sort data = donnees_sas nodupkey;\n  by _all_;\nrun;\n/* 2e méthode, avec first. et last. (cf. infra) */\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var order by varnum;\nquit;\n%put Dernière variable de la base : &derniere_var.;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata sansDouble;\n  set donnees_sas;\n  by &nom_col.;\n  if first.&derniere_var.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase_sansdoublon <- donnees_rbase[! duplicated(donnees_rbase), ]\n# Autre solution (équivalente à la solution first. de SAS)\ndonnees_rbase_sansdoublon <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase_sansdoublon <- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(pick(everything())) %>% \n  distinct()\ndonnees_tidyverse <- donnees_tidyverse %>% \n  arrange(across(everything())) %>% \n  distinct()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable <- unique(donnees_datatable)\ndonnees_datatable <- donnees_datatable[! duplicated(donnees_datatable), ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Suppression des doublons pour une seule variable \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = donnees_sas;by _all_;run;\ndata sansDouble;\n  set donnees_sas;\n  by _all_;\n  if first.identifiant;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_rbase_sansdoublon <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase_sansdoublon <- donnees_rbase_sansdoublon[!duplicated(donnees_rbase_sansdoublon$identifiant), , drop = FALSE]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# L'option .keep_all = TRUE est nécessaire \n# À FAIRE : REVOIR LE TRI PAR RAPPORT A SAS !!!\nsansDouble <- donnees_tidyverse %>% \n  arrange(pick(everything())) %>% \n  distinct(identifiant, .keep_all = TRUE)\nsansDouble <- donnees_tidyverse %>% \n  arrange(across(everything())) %>% \n  distinct(identifiant, .keep_all = TRUE)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nsetorderv(donnees_datatable, cols = colnames(donnees_datatable), na.last = FALSE)\nsansDouble <- donnees_datatable[! duplicated(donnees_datatable[, c(\"identifiant\")]), ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Identifiants uniques \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sql;\n  create table id as select distinct identifiant from donnees_sas order by identifiant;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nunique(donnees_rbase[\"identifiant\"])\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>%\n  distinct(identifiant)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nunique(donnees_datatable[, \"identifiant\"])\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Nombre de lignes uniques, sans doublon \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;select name into :nom_col separated by \", \" from Var order by varnum;quit;\nproc sql;\n  select count(*) as Nb_Lignes_Uniques\n  from (select &nom_col., count(*) from donnees_sas group by &nom_col.);\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnrow(unique(donnees_rbase))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>%\n  distinct() %>% \n  nrow()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : pas sûr de moi\nuniqueN(donnees_datatable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Les jointures de bases \n\n\n\n## Importation de bases pour les jointures \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */\ndata Diplome;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Diplome $20.;\n  input Identifiant $ Diplome $;\n  cards;\n  173|Bac\n  168|Bep-Cap\n  112|Bep-Cap\n  087|Bac+2\n  689|Bac+2\n  765|Pas de diplôme\n  113|Bac\n  999|Bac\n  554|Bep-Cap\n  ;\nrun;\n/* On suppose que l'on dispose aussi d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller */\ndata Entrevue;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Date_entrevue ddmmyy10.;\n  input Identifiant $ Date_entrevue ddmmyy10.;\n  cards;\n  173|06/08/2021\n  168|17/10/2019\n  087|12/06/2021\n  689|28/03/2018\n  099|01/09/2022\n  765|01/10/2020\n  ;\nrun;\n/* On récupère un extrait de la base initiale */\ndata Jointure;\n  set donnees_sas (keep = Identifiant Sexe date_entree date_sortie);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_rbase <- data.frame(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_rbase <- data.frame(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_rbase$date_entrevue <- lubridate::dmy(entrevue_rbase$date_entrevue)\n# On récupère un extrait de la base initiale\njointure_rbase <- donnees_rbase[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_tidyverse <-tibble(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_tidyverse <- tibble(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_tidyverse <- entrevue_tidyverse %>% \n  mutate(date_entrevue = lubridate::dmy(date_entrevue))\n# On récupère un extrait de la base initiale\nvariable <- c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")\njointure_tidyverse <- donnees_tidyverse %>%\n  select(variable)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_datatable <- data.table(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                                diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_datatable <- data.table(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                                 date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_datatable[, date_entrevue := lubridate::dmy(date_entrevue)]\n# On récupère un extrait de la base initiale\njointure_datatable <- donnees_datatable[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Inner join : les seuls identifiants communs aux deux bases \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Inner_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a and b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join2 as\n  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join1 (obs = 10);run;\nproc sql;select count(*) from Inner_Join1;quit;\nproc sql;select count(*) from Inner_Join2;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin <- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\")\ndim(innerJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin <- jointure_tidyverse %>% \n  inner_join(diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n# Autres solutions\ninnerJoin <- jointure_tidyverse %>% \n  inner_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(innerJoin)\ninnerJoin <- inner_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ninnerJoin <- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\")\ninnerJoin <- jointure_datatable[diplome_datatable, nomatch = 0, on = list(identifiant == identifiant)]\ninnerJoin <- jointure_datatable[diplome_datatable, nomatch = 0, on = .(identifiant == identifiant)]\ndim(innerJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Left join : les identifiants de la base de gauche \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Left_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Left_Join2 as\n  select * from Jointure a left join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Left_Join1 (obs = 10);run;\nproc sql;select count(*) from Left_Join1;quit;\nproc sql;select count(*) from Left_Join2;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin <- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin <- jointure_tidyverse %>% \n  left_join(diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n# Autres solutions\nleftJoin <- jointure_tidyverse %>% \n  left_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(leftJoin)\nleftJoin <- left_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nleftJoin <- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\nleftJoin <- diplome_datatable[jointure_datatable, on = .(identifiant == identifiant)]\ndim(leftJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Right join : les identifiants de la base de droite \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Right_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Right_Join2 as\n  select * from Jointure a right join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Right_Join1 (obs = 10);run;\nproc sql;select count(*) from Right_Join1;quit;\nproc sql;select count(*) from Right_Join2;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin <- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin <- jointure_tidyverse %>% \n  right_join(diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n# Autre solution\nrightJoin <- jointure_tidyverse %>% \n  right_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(rightJoin)\nrightJoin <- right_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nrightJoin <- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\nrightJoin <- jointure_datatable[diplome_datatable, on = .(identifiant == identifiant)]\ndim(rightJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Full join : les identifiants des deux bases \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Full_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a or b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Full_Join2 as\n  select coalesce(a.identifiant, b.identifiant) as Identifiant, *\n  from Jointure a full outer join Diplome b on a.identifiant = b.identifiant\n  order by calculated identifiant;\nquit;\nproc print data = Full_Join1 (obs = 10);run;\nproc sql;select count(*) from Full_Join1;quit;\nproc sql;select count(*) from Full_Join2;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés les identifiants des deux bases\nfullJoin <- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sont appariés les identifiants des deux bases\nfullJoin <- jointure_tidyverse %>% \n  full_join(diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n# Autre solution\nfullJoin <- jointure_tidyverse %>% \n  full_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(fullJoin)\nfullJoin <- full_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nfullJoin <- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Jointure de 3 bases ou plus en une seule opération (inner join) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sort data = Jointure;by identifiant;run;\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Entrevue;by identifiant;run;\ndata Inner_Join3;\n  merge Jointure (in = a) Diplome (in = b) Entrevue (in = c);\n  by identifiant;\n  if a and b and c;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join4 as\n  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n                           inner join Entrevue c on a.identifiant = c.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join4 (obs = 10);run;\nproc sql;select count(*) from Inner_Join3;quit;\nproc sql;select count(*) from Inner_Join4;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Via un inner join\n# Utilisation de la fonction Reduce\n# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 <- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                     list(jointure_rbase, diplome_rbase, entrevue_rbase))\ndim(innerJoin2)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Via un inner join\n# Utilisation de la fonction reduce de purrr\n# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 <- list(jointure_tidyverse, diplome_tidyverse, entrevue_tidyverse) %>%\n  purrr::reduce(dplyr::inner_join, by = join_by(identifiant == identifiant))\ndim(innerJoin2)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Utilisation de la fonction Reduce : elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 <- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                    list(jointure_datatable, diplome_datatable, entrevue_datatable))\ndim(innerJoin2)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Jointure sur inégalités \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On associe l'entrevue au contrat au cours duquel elle a eu lieu */\nproc sql;\n  create table Inner_Join_Inegalite as\n  select *\n  from Jointure a inner join Entrevue b\n       on a.identifiant = b.identifiant and a.date_entree <= b.date_entrevue <= a.date_sortie\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join_Inegalite (obs = 10);run;\nproc sql;select count(*) from Inner_Join_Inegalite;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ne semble pas natif en R-Base.\n# Une proposition indicative où on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...\ninnerJoinInegalite <- merge(jointure_rbase, entrevue_rbase, by = \"identifiant\")\ninnerJoinInegalite <- with(innerJoinInegalite,\n                           innerJoinInegalite[which(date_entree <= date_entrevue & date_entrevue <= date_sortie), ])\ndim(innerJoinInegalite)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ne semble pas natif en R-Base.\n# Une proposition indicative où on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...\ninnerJoinInegalite <- jointure_tidyverse %>% \n  inner_join(entrevue_tidyverse, join_by(identifiant == identifiant,\n                                         date_entree <= date_entrevue,\n                                         date_sortie >= date_entrevue))\ndim(innerJoinInegalite)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Attention, l'ordre des conditions doit correspondre à l'ordre des bases dans la jointure !\n# Il semble que l'on soit forcé de spécifier tous les noms des colonnes, et ce qui est un peu problématique ...\n# À FAIRE : Peut-on faire plus simplement ??\ninnerJoinInegalite <- jointure_datatable[entrevue_datatable,\n                                         .(identifiant, sexe, date_entree, date_sortie, date_entrevue),\n                                         on = .(identifiant, date_entree <= date_entrevue, date_sortie >= date_entrevue),\n                                         nomatch = 0L\n                                         ][order(identifiant)]\ndim(innerJoinInegalite)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sql;\n  create table CrossJoin as\n  select *\n  from (select distinct CSPF from donnees_sas)  cross join\n       (select distinct Sexef from donnees_sas) cross join\n       (select distinct Diplome from Diplome)\n  order by CSPF, Sexef, Diplome;\nquit;\nproc sql;select count(*) from CrossJoin;quit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin <- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))\ncolnames(crossJoin) <- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)\n# Autre solution\ncrossJoin2 <- unique(merge(donnees_rbase[, c(\"cspf\", \"sexef\")], diplome_rbase[, \"diplome\"], by = NULL))\ndim(crossJoin2)\n# https://stackoverflow.com/questions/10600060/how-to-do-cross-join-in-r\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin <- donnees_tidyverse %>%\n  select(cspf, sexef) %>% \n  cross_join(diplome_tidyverse %>% select(diplome)) %>% \n  distinct()\ndim(crossJoin)\n# Autre solution\ncrossJoin <- cross_join(donnees_tidyverse %>% select(cspf, sexef), diplome_tidyverse %>% select(diplome)) %>% \n  distinct()\ndim(crossJoin)\n# Autre solution\ncrossJoin <- donnees_tidyverse %>% \n  tidyr::expand(cspf, sexef, diplome_tidyverse$diplome) %>%\n  distinct()\ndim(crossJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ncrossJoin <- data.table::CJ(donnees_datatable$cspf, donnees_datatable$sexef, diplome_datatable$diplome, unique = TRUE)\ncolnames(crossJoin) <- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Juxtaposer côte à côte deux bases de données \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On va ajouter le numéro de la ligne */\nproc sql noprint;select count(*) into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\n/* Le merge sans by va juxtaposer côte à côte les bases */\ndata Concatener;merge Ajout donnees_sas;run;\n/* Si l'une des bases comprend plus de ligne que l'autre, ajout d'une ligne de valeurs manquantes */\nproc sql noprint;select count(*) + 1 into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\ndata Concatener;merge Ajout donnees_sas;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va ajouter le numéro de la ligne\n# cbind si les deux bases comprennent le même nombre de lignes\najout <- data.frame(num_ligne = seq_len(nrow(donnees_rbase)))\nconcatener <- cbind(ajout, donnees_rbase)\n# Erreur si l'une des bases comprend plus de lignes que l'autre\najout <- data.frame(num_ligne = seq_len(nrow(donnees_rbase) + 1))\n# donnees_rbase_ajout <- cbind(ajout, donnees_rbase)\n# Proposition de solution\ncbind_alt <- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol <- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res <- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] <- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(do.call(cbind, res))\n}\nconcatener <- cbind_alt(list(ajout, donnees_rbase))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va ajouter le numéro de la ligne\n# cbind si les deux bases comprennent le même nombre de lignes\najout <- tibble(num_ligne = seq_len(nrow(donnees_tidyverse)))\nconcatener <- donnees_tidyverse %>% bind_cols(ajout)\n# Ne fonctionne si l'une des bases comprend plus de lignes que l'autre !\najout <- tibble(num_ligne = seq_len(nrow(donnees_tidyverse) + 1))\n#concatener <- donnees_tidyverse %>% bind_cols(ajout)\n# cf. solution proposée dans R-Base\ncbind_alt <- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol <- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res <- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] <- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(bind_cols(res))\n}\nconcatener <- cbind_alt(list(ajout, donnees_tidyverse))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va ajouter le numéro de la ligne\n# data.frame::cbind si les deux bases comprennent le même nombre de lignes\najout <- data.table(num_ligne = seq_len(nrow(donnees_datatable)))\nconcatener <- cbind(ajout, donnees_datatable)\n# Fonctionne aussi avec des bases comportement un nombre différent de lignes\n# Mais attention, le résultat n'est pas le même que sur SAS, il y a recycling\najout <- data.table(num_ligne = seq_len(nrow(donnees_datatable) + 1))\nconcatener <- cbind(ajout, donnees_datatable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Empiler deux bases de données \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On va empiler la somme des notes en dessous de la base des notes */\n%let var = Identifiant Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* On sélectionne un nombre réduit de variables pour simplifier l'exemple */\n%let var2 = %sysfunc(tranwrd(&var., Identifiant,));\ndata Notes;set donnees_sas (keep = &var.);run;\n/* Moyenne des notes par individu */\nproc means data = Notes noprint mean;var &var2.;output out = Ajout mean = &var2.;run;\n/* On concatène avec les données. Valeur manquante si les variables ne correspondent pas */\n/* L'instruction set permet de concaténer les bases */\ndata Empiler;set Notes Ajout (drop = _type_ _freq_);run;\n/* Autre solution, proc append */\ndata Empiler;set Notes;run;\nproc append base = Empiler data = Ajout force;run;\n/* On renomme la ligne des moyennes ajoutée */\ndata Empiler;\n  set Empiler nobs = nobs;\n  if _N_ = nobs then Identifiant = \"Moyenne\";\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes <- data.frame(t(colMeans(donnees_rbase[, varNotes], na.rm = TRUE)))\n# On sélectionne la base des notes\nnotes <- donnees_rbase[, varNotes]\n# rbind lorsque les bases empilées ont le même nombre de colonne\nempiler <- rbind(notes, moyennes)\n# Mais, ne fonctionne plus si l'on concatène des bases de taille différente\nnotes <- donnees_rbase[, c(\"identifiant\", varNotes)]\n# Ne fonctionne pas\n#empiler <- rbind(notes, moyennes)\n# Une solution alternative, lorsque le nombre de colonnes diffère entre les deux bases\n# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff\nrbind_alt <- function(x, y) {\n  rbind(data.frame(c(x, sapply(setdiff(names(y), names(x)), function(z) NA))),\n        data.frame(c(y, sapply(setdiff(names(x), names(y)), function(z) NA)))\n  )\n  }\nempiler <- rbind_alt(notes, moyennes)\n# On renomme la ligne des moyennes ajoutée\nempiler[nrow(empiler), \"identifiant\"] <- \"Moyenne\"\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes <- donnees_tidyverse %>% \n  summarise(across(varNotes, ~mean(., na.rm = TRUE)))\nempiler <- donnees_tidyverse %>% \n  select(all_of(varNotes)) %>% \n  bind_rows(moyennes)\n# Fonctionne toujours si l'on concatène des bases de taille différente\nempiler <- donnees_tidyverse %>% \n  select(identifiant, all_of(varNotes)) %>% \n  bind_rows(moyennes)\nempiler <- empiler %>% \n  # On renomme la ligne des moyennes ajoutée\n  mutate(identifiant = ifelse(row_number() == nrow(empiler),\n                              \"Moyenne\",\n                              identifiant))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes <- data.table(donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = varNotes])\n# On sélectionne la base des notes\nnotes <- donnees_datatable[, mget(c(\"identifiant\", varNotes))]\nempiler <- rbindlist(list(notes, moyennes), fill = TRUE)\n# On renomme la ligne des moyennes ajoutée\nset(empiler, i = nrow(empiler), j = \"identifiant\", value = \"Moyenne\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Ajouter une ligne de valeurs manquantes à une base de données \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata Ajout;run;\ndata Ajout_Missing;set Jointure Ajout;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\najout_na <- donnees_rbase\najout_na[nrow(ajout_na) + 1, ] <- NA\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\najout_na <- donnees_tidyverse %>%\n  bind_rows(tibble(NA))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\najout_na <- rbindlist(list(donnees_datatable, data.table(NA)), fill = TRUE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Semi join \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Identifiants de la base de gauche qui ont un correspondant dans la base de droite */\nproc sql;\n  create table Semi_Join as select * from donnees_sas\n  where Identifiant in (select distinct Identifiant from Diplome);\n  select count(*) from Semi_Join;\nquit;\nproc sql;\n  create table Semi_Join as select * from donnees_sas a\n  where exists (select * from Diplome b where (a.Identifiant = b.Identifiant));\n  select count(*) from Semi_Join;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin <- donnees_rbase[donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(semiJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin <- donnees_tidyverse %>% \n  semi_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n# Autre solution\nsemiJoin <- semi_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin <- donnees_datatable[identifiant %in% diplome_datatable$identifiant, ]\ndim(semiJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Anti join \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite */\nproc sql;\n  create table Anti_Join as select * from donnees_sas\n  where Identifiant not in (select distinct Identifiant from Diplome);\n  select count(*) from Anti_Join;\nquit;\nproc sql;\n  create table Anti_Join as select * from donnees_sas a\n  where not exists (select * from Diplome b where (a.Identifiant = b.Identifiant);\n  select count(*) from Anti_Join;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin <- donnees_rbase[! donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(antiJoin)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin <- donnees_tidyverse %>% \n  anti_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n# Autre solution\nantiJoin <- anti_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin <- donnees_datatable[! identifiant %in% diplome_datatable$identifiant, ]\ndim(antiJoin)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Autres fonctions utiles \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc sql;\n  /* Concaténation des identifiants */\n  select Identifiant from Jointure union all\n  select Identifiant from Diplome order by identifiant;\n  /* Identifiants uniques des 2 bases */\n  select distinct Identifiant from\n  (select distinct Identifiant from Jointure union select distinct Identifiant from Diplome)\n  order by identifiant;\n  /* Identifiants communs des 2 bases */\n  select Identifiant from Jointure intersect select Identifiant from Diplome\n  order by identifiant;\n  /* Identifiants dans jointure mais pas diplome */\n  select distinct Identifiant from Jointure where\n  Identifiant not in (select distinct Identifiant from Diplome)\n  order by identifiant;\n  select Identifiant from Jointure except select Identifiant from Diplome;\n  /* Identifiants dans diplome mais pas jointure */\n  select distinct Identifiant from Diplome\n  where Identifiant not in (select distinct Identifiant from Jointure)\n  order by identifiant;\n  select Identifiant from Diplome except\n  select Identifiant from Jointure order by identifiant;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# base:: permet de s'assurer que les fonctions proviennent de R-Base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n# Concaténation des identifiants avec les doublons\nsort(c(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants uniques des 2 bases\nsort(base::union(jointure_rbase$identifiant, diplome_rbase$identifiant))\nsort(base::unique(c(jointure_rbase$identifiant, diplome_rbase$identifiant)))\n# Identifiants communs des 2 bases\nsort(base::intersect(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants dans jointure mais pas diplome\nsort(base::setdiff(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants dans diplome mais pas jointure\nsort(base::setdiff(diplome_rbase$identifiant, jointure_rbase$identifiant))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Concaténation des identifiants\ndplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %>% \n  sort()\n# Identifiants uniques des 2 bases\nunique(dplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant)) %>% \n  sort()\ndplyr::union(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %>% \n  sort()\n# Identifiants communs des 2 bases\ndplyr::intersect(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %>% \n  sort()\n# Identifiants dans jointure mais pas diplome\ndplyr::setdiff(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %>% \n  sort()\n# Identifiants dans diplome mais pas jointure\ndplyr::setdiff(diplome_tidyverse$identifiant, jointure_tidyverse$identifiant) %>% \n  sort()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R-Base\n\n# Concaténation des identifiants\nvariable <- \"identifiant\"\nsort(c(jointure_datatable[[variable]], diplome_datatable[[variable]]))\n# Identifiants uniques des 2 bases\nsort(unique(c(jointure_datatable[[variable]], diplome_datatable[[variable]])))\nsort(union(jointure_datatable[[variable]], diplome_datatable[[variable]]))\n# Identifiants communs des 2 bases\nfintersect(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n# Identifiants dans jointure mais pas diplome\nfsetdiff(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n# Identifiants dans diplome mais pas jointure\nfsetdiff(diplome_datatable[, ..variable], jointure_datatable[, ..variable])[order(identifiant)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Statistiques descriptives \n\n\n\n## Moyenne \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc means data = donnees_sas mean;var note_contenu;run;\nproc sql;select mean(note_contenu) from donnees_sas;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Importance du na.rm = TRUE\nmean(donnees_rbase$note_contenu)\nmean(donnees_rbase$note_contenu, na.rm = TRUE)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Importance du na.rm = TRUE\ndonnees_tidyverse %>% pull(note_contenu) %>% mean()\ndonnees_tidyverse %>% pull(note_contenu) %>% mean(na.rm = TRUE)\n# Autre solution\n# Le chiffre est arrondi lorsqu'il est affiché, du fait des propriétés des tibbles\ndonnees_tidyverse %>% \n  summarise(across(note_contenu, ~mean(., na.rm = TRUE)))\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# donnees_tidyverse %>% mean(note_formateur)\n# donnees_tidyverse %>% mean(note_formateur, na.rm = TRUE)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Importance du na.rm = TRUE\ndonnees_datatable[, mean(note_contenu)]\ndonnees_datatable[, mean(note_contenu, na.rm = TRUE)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne par sélection \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Ici pour les seules femmes */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ici, pour les seules femmes\nwith(subset(donnees_rbase, sexef == \"Femme\"), mean(note_contenu, na.rm = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ici, pour les seules femmes\ndonnees_tidyverse %>%\n  filter(sexef == \"Femme\") %>% \n  pull(note_contenu) %>%\n  mean(na.rm = TRUE)\n# Autres solutions\ndonnees_tidyverse %>%\n  filter(sexef == \"Femme\") %>% \n  summarise(across(note_contenu, ~ mean(., na.rm = TRUE)))\n# Attention, syntaxe qui ne fonctionne qu'avec %>%, pas avec %>% !\ndonnees_tidyverse %>%\n  filter(sexef == \"Femme\") %>% \n  {mean(.$note_contenu, na.rm = TRUE)}\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ici, pour les seules femmes\ndonnees_datatable[sexef == \"Femme\", mean(note_contenu, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) mean(x, na.rm = TRUE)), .SDcols = \"note_contenu\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne pondérée \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Ensemble des données */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n/* Par sélection (ici pour les seules femmes) */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des données\nweighted.mean(donnees_rbase$note_contenu, donnees_rbase$poids_sondage, na.rm = TRUE)\n# Autre méthode, mais attention aux NA !!\nwith(donnees_rbase, sum(note_contenu * poids_sondage, na.rm = TRUE) / sum((!is.na(note_contenu)) * poids_sondage, na.rm = TRUE))\n# Par sélection (ici pour les seules femmes)\nwith(subset(donnees_rbase, sexef == \"Femme\"), sum(note_contenu * poids_sondage, na.rm = TRUE) / sum(poids_sondage, na.rm = TRUE))\n# On peut aussi utiliser la fonction crossprod\n# Mais ne fonctionne pas dans ce cas, car elle ne prend pas en compte les na.rm = TRUE\n# Ne pas confondre cumprod et crossprod !!!!\nwith(subset(donnees_rbase, sexef == \"Femme\"), crossprod(note_contenu, poids_sondage) / sum(poids_sondage, na.rm = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des données\ndonnees_tidyverse %>%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n# Par sélection\ndonnees_tidyverse %>%\n  filter(sexef == \"Femme\") %>%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des données\ndonnees_datatable[, weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\n# Par sélection (ici pour les seules femmes)\ndonnees_datatable[sexef == \"Femme\", weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)),\n                  .SDcols = \"note_contenu\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne de plusieurs variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Plusieurs solutions\n# Sous forme de liste\nlapply(donnees_rbase[, notes], mean, na.rm = TRUE)\n# Sous forme de vecteur\nsapply(donnees_rbase[, notes], mean, na.rm = TRUE)\napply(donnees_rbase[, notes], 2, mean, na.rm = TRUE)\n# Si l'on souhaite renommer les colonnes\nmoyennes <- sapply(donnees_rbase[, notes], mean, na.rm = TRUE)\nnames(moyennes) <- paste(\"Moyenne\", names(moyennes), sep = \"_\")\nmoyennes\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %>%\n  summarise_at(notes, mean, na.rm = TRUE)\n# Autres solutions\ndonnees_tidyverse %>%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE)))\n# Obsolète\ndonnees_tidyverse %>%  \n  select(starts_with(\"Note\") & !ends_with(\"_100\")) %>% \n  summarise_all(.funs = ~ mean(., na.rm = TRUE), .vars = notes)\n# Si l'on souhaite renommer les colonnes\nmoyennes <- donnees_tidyverse %>%\n  summarise_at(notes, mean, na.rm = TRUE) %>% \n  rename_with(~ paste(\"Moyenne\", ., sep = \"_\"))\nmoyennes <- donnees_tidyverse %>%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne_{.col}\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nmoyennes <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = notes]\n# Si l'on souhaite renommer les colonnes\nsetnames(moyennes, notes, paste(\"Moyenne\", notes, sep = \"_\"))\nmoyennes\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Moyenne pondérée de plusieurs variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nwith(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %>%\n  summarise(across(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE)))\n# Autre solution\ndonnees_tidyverse %>%\n  summarise_at(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nmoyennes <- donnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), .SDcols = notes]\nmoyennes\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Nombreuses statistiques (somme, moyenne, médiane, mode, etc.) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes */\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n),\n   nombre de données manquantes (nmiss), intervalle, mode */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode;\n  var &notes.;\nrun;\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données (manquantes et non manquantes),\n# Nombre de valeurs manquantes, Intervalle\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = sum(x, na.rm = TRUE),\n                                             \"Moyenne\"    = mean(x, na.rm = TRUE),\n                                             \"Médiane\"    = median(x, na.rm = TRUE),\n                                             \"Min\"        = min(x, na.rm = TRUE),\n                                             \"Max\"        = max(x, na.rm = TRUE),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = var(x, na.rm = TRUE),\n                                             \"Ecart-type\" = sd(x, na.rm = TRUE),\n                                             \"N\"          = length(x),\n                                             \"NMiss\"      = sum(is.na(x)),\n                                             \"Intervalle\" = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                             \"Mode\"       = collapse::fmode(x)\n))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDesc_tidyverse <- function(x) {\n  c(\n    Somme      = sum(x, na.rm = TRUE),\n    Moyenne    = mean(x, na.rm = TRUE),\n    Mediane    = median(x, na.rm = TRUE),\n    Min        = min(x, na.rm = TRUE),\n    Max        = max(x, na.rm = TRUE),\n    Variance   = var(x, na.rm = TRUE),\n    Ecart_type = sd(x, na.rm = TRUE),\n    N          = length(x),\n    NMiss      = sum(is.na(x)),\n    Intervalle = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n    Mode       = collapse::fmode(x)\n    )\n}\n# 1ère solution avec les notes en ligne et les statistiques en colonnes\ndonnees_tidyverse %>% \n  select(all_of(notes)) %>% \n  map(~ StatsDesc_tidyverse(.x)) %>% \n  bind_rows() %>% \n  bind_cols(tibble(Note = c(notes))) %>% \n  relocate(Note)\n# 2e solution avec les notes en colonne\ndonnees_tidyverse %>%\n  reframe(across(notes, ~ StatsDesc_tidyverse(.x))) %>% \n  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %>% \n  relocate(Indicateur)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nmoyennes <- donnees_datatable[, lapply(.SD, function(x) c(sum(x, na.rm = TRUE),\n                                                          mean(x, na.rm = TRUE),\n                                                          median(x, na.rm = TRUE),\n                                                          min(x, na.rm = TRUE),\n                                                          max(x, na.rm = TRUE),\n                                                          var(x, na.rm = TRUE),\n                                                          sd(x, na.rm = TRUE),\n                                                          .N,\n                                                          sum(is.na(x)),\n                                                          max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                                          collapse::fmode(x)\n                                                          )),\n                              .SDcols = notes]\ncbind(data.table(Nom = c(\"Somme\", \"Moyenne\", \"Médiane\", \"Min\", \"Max\", \"Variance\", \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\")), moyennes)\n# Autre solution\nStatsDesc <- function(x) {\n  list(\n    Variable   = names(x),\n    Somme      = lapply(x, sum, na.rm = TRUE),\n    Moyenne    = lapply(x, mean, na.rm = TRUE),\n    Mediane    = lapply(x, median, na.rm = TRUE),\n    Min        = lapply(x, min, na.rm = TRUE),\n    Max        = lapply(x, max, na.rm = TRUE),\n    Variance   = lapply(x, var, na.rm = TRUE),\n    Ecart_type = lapply(x, sd, na.rm = TRUE),\n    N          = lapply(x, function(x) length(x)),\n    NMiss      = lapply(x, function(x) sum(is.na(x))),\n    Intervalle = lapply(x, function(x) max(x, na.rm = TRUE) - min(x, na.rm = TRUE)),\n    Mode       = lapply(x, collapse::fmode)\n    )\n}\ndonnees_datatable[, StatsDesc(.SD), .SDcols = notes]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Nombreuses statistiques pondérées (somme, moyenne, médiane, mode, etc.) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n),\n   nombre de données manquantes (nmiss), intervalle, mode */\n/* Par la proc means, en un seul tableau */\n/* L'option vardef = wgt permet de diviser la variable par la somme des poids et non le nombre de données, pour être cohérent\n   avec R */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode vardef = wgt;\n  var &notes.;\n  weight poids_sondage;\nrun;\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = collapse::fsum(x, w = donnees_rbase$poids_sondage),\n                                             \"Moyenne\"    = collapse::fmean(x, w = donnees_rbase$poids_sondage),\n                                             \"Médiane\"    = collapse::fmedian(x, w = donnees_rbase$poids_sondage),\n                                             \"Min\"        = collapse::fmin(x),\n                                             \"Max\"        = collapse::fmax(x),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = collapse::fvar(x, w = donnees_rbase$poids_sondage),\n                                             \"Ecart-type\" = collapse::fsd(x, w = donnees_rbase$poids_sondage),\n                                             \"N\"          = collapse::fnobs(x),\n                                             \"NMiss\"      = collapse::fnobs(is.na(x)),\n                                             \"Intervalle\" = collapse::fmax(x) - collapse::fmin(x),\n                                             \"Mode\"       = collapse::fmode(x, w = donnees_rbase$poids_sondage)\n))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDescPond_tidyverse <- function(x, w) {\n  c(\n    Somme      = collapse::fsum(x, w),\n    Moyenne    = collapse::fmean(x, w),\n    Mediane    = collapse::fmedian(x, w),\n    Min        = collapse::fmin(x),\n    Max        = collapse::fmax(x),\n    Variance   = collapse::fvar(x, w),\n    Ecart_type = collapse::fsd(x, w),\n    N          = collapse::fnobs(x),\n    NMiss      = collapse::fnobs(is.na(x)),\n    Intervalle = collapse::fmax(x) - collapse::fmin(x),\n    Mode       = collapse::fmode(x, w)\n  )\n}\n# À FAIRE : Comment faire cela ???\n# Tous les codes suivants ne fonctionnent pas !\n#donnees_tidyverse %>%\n#  reframe(across(notes, ~ StatsDescPond_tidyverse(.x, 10))) %>% \n#  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n#                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %>% \n#  relocate(Indicateur)\n#donnees_tidyverse %>% \n#  select(all_of(notes), poids_sondage) %>% \n#  map(all_of(notes), ~ StatsDescPond_tidyverse(.x, poids_sondage)) %>% \n#  bind_rows() %>% \n#  bind_cols(tibble(Note = c(notes))) %>% \n#  relocate(Note)\n#donnees_tidyverse %>% \n#  select(all_of(notes), poids_sondage) %>% \n#  map(~StatsDescPond_tidyverse(.x, donnees_tidyverse$poids_sondage) )\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\n# À FAIRE : y-a-t-il plus simple ???\n# Est-on obligés d'utiliser systématiquement donnees_datatable$poids_sondage ?\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDescPond <- function(x) {\n  list(\n    Variables  = names(x),\n    Somme      = lapply(x, collapse::fsum, w = donnees_datatable$poids_sondage),\n    Moyenne    = lapply(x, collapse::fmean, w = donnees_datatable$poids_sondage),\n    Mediane    = lapply(x, collapse::fmedian, w = donnees_datatable$poids_sondage),\n    Min        = lapply(x, collapse::fmin),\n    Max        = lapply(x, collapse::fmax),\n    Variance   = lapply(x, collapse::fvar, w = donnees_datatable$poids_sondage),\n    Ecart_type = lapply(x, collapse::fsd, w = donnees_datatable$poids_sondage),\n    N          = lapply(x, collapse::fnobs),\n    NMiss      = lapply(x, function(x) collapse::fnobs(is.na(x))),\n    Intervalle = lapply(x, function(x) collapse::fmax(x) - collapse::fmin(x)),\n    Mode       = lapply(x, collapse::fmode, w = donnees_datatable$poids_sondage)\n  )\n}\ndonnees_datatable[, StatsDescPond(.SD), .SDcols = notes]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Calcul d'une variance pondérée \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc means data = donnees_sas var vardef = wgt;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(collapse)\nwith(donnees_rbase, collapse::fvar(note_contenu, w = poids_sondage))\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 <- with(donnees_rbase,\n            sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_m <- with(donnees_rbase,\n            sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\np <- with(donnees_rbase,\n          sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_2 / p - (x_m / p) ** 2\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(collapse)\ndonnees_tidyverse %>% \n  summarise(var = collapse::fvar(note_contenu, w = poids_sondage))\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 <- with(donnees_tidyverse,\n            sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_m <- with(donnees_tidyverse,\n            sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\np <- with(donnees_tidyverse,\n          sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_2 / p - (x_m / p) ** 2\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(collapse)\ndonnees_datatable[, collapse::fvar(note_contenu, w = poids_sondage)]\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 <- donnees_datatable[, sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\nx_m <- donnees_datatable[, sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\np <- donnees_datatable[, sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)]\nx_2 / p - (x_m / p) ** 2\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Déciles et quartiles \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n\t                          %let j = %scan(&notes., &i.);\n\t\t\t\t\t\t      &j.\n\t\t\t\t\t\t    %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n\n/* Déciles et quartiles de la note moyenne */\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\nrun;\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_; \nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# on calcule déjà la moyenne des notes par individu\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne <- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n# Et les quantiles\nquantile(donnees_rbase$note_moyenne, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n# Intervalle inter-quartile\nIQR(donnees_rbase$note_moyenne, na.rm = TRUE)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# on calcule déjà la moyenne des notes par individu\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Et les quantiles\ndonnees_tidyverse %>%\n  pull(note_moyenne) %>% \n  quantile(probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n# Intervalle inter-quartile\ndonnees_tidyverse %>%\n  pull(note_moyenne) %>% \n  IQR(na.rm = TRUE)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# on calcule déjà la moyenne des notes par individu\nnotes <- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\ndonnees_datatable[, quantile(.SD, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE), .SDcols = \"note_moyenne\"]\n# Intervalle inter-quartile\ndonnees_datatable[, IQR(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, lapply(.SD, function(x) IQR(x, na.rm = TRUE)), .SDcols = \"note_moyenne\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Déciles et quartiles pondérés \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  Note_moyenne = mean(of &notes.);\nrun;\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\n  weight poids_sondage;\nrun;\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\nlibrary(collapse)\n# on calcule déjà la moyenne des notes par individu\nnotes <- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne <- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n# Et les quantiles\n# L'option na.rm est par défaut à TRUE dans le package\ncollapse::fquantile(donnees_rbase$note_moyenne, w = donnees_rbase$poids_sondage,\n                    probs = c(seq(0, 1, 0.1)))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\nlibrary(collapse)\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Et les quantiles\n# L'option na.rm est par défaut à TRUE dans le package\ndonnees_tidyverse %>%\n  pull(note_moyenne) %>% \n  collapse::fquantile(probs = c(seq(0, 1, 0.1)), w = donnees_tidyverse$poids_sondage)\ndonnees_tidyverse %>%\n  pull(note_moyenne) %>% \n  collapse::fquantile(probs = c(0, 0.25, 0.5, 0.75, 1), w = donnees_tidyverse$poids_sondage)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\nlibrary(collapse)\n# on calcule déjà la moyenne des notes par individu\nnotes <- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\n# L'option na.rm est par défaut à TRUE dans le package\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\ndonnees_datatable[, lapply(.SD, function(x) collapse::fquantile(x, w = poids_sondage,\n                                                                probs = c(seq(0, 1, 0.1))\n                                                                )),\n                           .SDcols = \"note_moyenne\"]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Rang de la note \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Ajouter dans la base le rang de la note par ordre décroissant */\nproc rank data = donnees_sas out = donnees_sas descending;\n  var note_moyenne;\n  ranks rang_note_moyenne;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ajouter dans la base le rang de la note par ordre décroissant\ndonnees_rbase$rang_note_moyenne <- rank(-donnees_rbase$note_moyenne)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ajouter dans la base le rang de la note par ordre décroissant\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse <- donnees_tidyverse %>%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE)) %>% \n  mutate(rang_note_moyenne = rank(-note_moyenne))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ajouter dans la base le rang de la note par ordre décroissant\n# Attention, en R, rank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS\n# On exprime le rang par ordre décroissant, avec le - devant\ndonnees_datatable[, rang_note_moyenne := rank(-note_moyenne)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Corrélation linéaire entre deux notes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Covariance et corrélation linéaire (Kendall, Pearson, Spearman) */\nproc corr data = donnees_sas kendall pearson spearman cov;\n  var note_contenu note_formateur;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Covariance (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cov(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cor(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Covariance (Kendall, Pearson, Spearman)\n# À FAIRE : peut-on faire mieux ???\nmethodes <- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %>% \n  purrr::map(~ \n    donnees_tidyverse %>% \n      summarise(cov = cov(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %>% \n  setNames(methodes) %>% \n  as_tibble()\n\n# Corrélation linéaire (Kendall, Pearson, Spearman)\n# À FAIRE : peut-on faire mieux ???\nmethodes <- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %>% \n  purrr::map(~ donnees_tidyverse %>% \n               summarise(cor = cor(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %>% \n  setNames(methodes) %>% \n  as_tibble()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Covariance (Kendall, Pearson, Spearman)\nmethodes <- c(\"pearson\", \"spearman\", \"kendall\")\nsetNames(donnees_datatable[, lapply(methodes,\n                           function(x) cov(note_contenu, note_formateur,\n                                           method = x,\n                                           use = \"complete.obs\"))],\n         methodes)\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nsetNames(donnees_datatable[, lapply(methodes,\n                                    function(x) cor(note_contenu, note_formateur,\n                                                    method = x,\n                                                    use = \"complete.obs\"))],\n         methodes)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Tableaux de fréquence \n\n\n\n## Tableaux de fréquence (proc freq) pour 1 variable \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe CSP;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableaux de fréquence (proc freq) (sans les valeurs manquantes)\ntable(donnees_rbase$cspf)\ntable(donnees_rbase$sexef)\n# Autre syntaxe, donnant une mise en forme différente\nftable(donnees_rbase$cspf)\n# Pour enlever les \"donnees_rbase$\", on peut utiliser with pour se placer dans l'environnement de donnees_rbase\nwith(donnees_rbase, table(cspf))\n# Pour les proportions\nprop.table(table(donnees_rbase$cspf)) * 100\n# Devient plus difficile si l'on souhaite plus (sommes et proportions cumulées par exemple)\nfreq <- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq <- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq <- transform(freq,\n                  Freq_cum = cumsum(Freq),\n                  Prop_cum = cumsum(Prop))\nfreq\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  count(cspf) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\ndonnees_tidyverse %>% \n  count(sexef) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n# Ou alors\ndonnees_tidyverse %>% \n  group_by(cspf) %>% \n  summarise(n = n()) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop)\n  )\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ndonnees_datatable[, table(cspf) ]\ndonnees_datatable[, table(sexef) ]\n# Pour les proportions\ndonnees_datatable[, prop.table(table(cspf)) ] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]\n# Autre façon d'utiliser les méthodes de data.table, avec les fréquences et proportions cumulés\ntab <- data.table::dcast(donnees_datatable, cspf ~ ., fun = length)\ncolnames(tab)[colnames(tab) == \".\"] <- \"Nombre\"\ntab[, Prop := lapply(.SD, function(col) col / sum(col) * 100), .SDcols = is.numeric]\ntab[, c(\"Freq_cum\", \"Prop_cum\") := list(cumsum(Nombre), cumsum(Prop))]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux de fréquence avec les valeurs manquantes \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ntable(donnees_rbase$cspf, useNA = \"always\")\nprop.table(table(donnees_rbase$cspf, useNA = \"always\")) * 100\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ntable(donnees_rbase$cspf, useNA = \"always\")\nprop.table(table(donnees_rbase$cspf, useNA = \"always\")) * 100\ndonnees_tidyverse %>% \n  count(cspf) %>% \n  mutate(prop = n / sum(n) * 100)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, table(cspf, useNA = \"always\") ]\ndonnees_datatable[, prop.table(table(cspf, useNA = \"always\"))] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux de fréquence trié par modalité la plus courante \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas order = freq;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nfreq <- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq <- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq[order(-freq$Freq), ]\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  count(cspf) %>% \n  arrange(desc(n)) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\ndonnees_tidyverse %>% \n  count(cspf, sort = TRUE) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf][order(-Nombre)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux de fréquence avec la pondération \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nxtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE)\nprop.table(xtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  count(cspf, wt = poids_sondage) %>% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE) ]\ndonnees_datatable[, prop.table(xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE)) ]\ndonnees_datatable[, .(prop = sum(poids_sondage, na.rm = TRUE) / sum(donnees_datatable[, poids_sondage]) * 100), keyby = cspf]\ndonnees_datatable[, {tot = sum(poids_sondage, na.rm = TRUE); .SD[, .(prop = sum(poids_sondage, na.rm = TRUE) / tot * 100), by = cspf]} ]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux de contingence (proc freq) pour 2 variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n/* Tableau de contingence (tableau croisé) sans les proportions lignes, colonnes et totales */\nproc freq data = donnees_sas;\n  tables CSP * Sexe  / missing nofreq norow nocol;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableau simple\ntable(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Tableau avec les sommes\naddmargins(table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\"))\n# Proportions\ntab <- table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n# Solution alternative, sans pondération\ntab <- xtabs(~ cspf + sexef, data = donnees_rbase)\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : ajouter une une ligne avec les sommes !\n# Tableau de fréquence\ndonnees_tidyverse %>% \n  group_by(cspf, sexef) %>% \n  summarise(prop = n(), .groups = \"drop_last\") %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>%\n  spread(sexef, prop) %>% \n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n\n# Proportions par ligne\ndonnees_tidyverse %>% \n  group_by(cspf, sexef) %>% \n  summarise(prop = n()) %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  spread(sexef, prop)\n\n# Proportions par colonne\ndonnees_tidyverse %>% \n  group_by(sexef, cspf) %>% \n  summarise(prop = n()) %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  spread(sexef, prop)\n\n\ntab <- donnees_tidyverse %>% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  # À FAIRE : pourrait-on sommer directement avec pivot_wider ? Argument values_fn?\n  # Ne semble pas fonctionner, pourqoi ???\n  pivot_wider(names_from = sexef, values_from = prop) %>% \n  # Somme par lignes\n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n# Autre solution avec rowwise : bien penser à c_across et non across !\n#rowwise() %>% \n#mutate(Total = sum(c_across(where(is.numeric)), na.rm = T)) %>% \n#ungroup()\n# Somme par colonnes\ntab <- bind_rows(tab, tab %>% \n                   summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)),\n                             across(where(is.character), ~\"Total\"))\n)\ntab\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableau simple\ndonnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Tableau avec les sommes\ndonnees_datatable[, addmargins(table(cspf, sexef, useNA = \"always\")) ]\n# Proportions\ntab <- donnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n# Solution alternative, sans pondération\ntab <- donnees_datatable[, xtabs(~ cspf + sexef, data = donnees_datatable) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n# Autre solution, avec les Grouping sets\ntab <- data.table::cube(donnees_datatable, .(Nb = .N), by = c(\"cspf\", \"sexef\"))\ntab <- data.table::dcast(tab, cspf ~ sexef, value.var = \"Nb\")\n# On harmonise le tableau\ntab <- rbind(tab[2:nrow(tab)], tab[1,])\nsetcolorder(tab, c(setdiff(names(tab), \"NA\"), \"NA\"))\n# On renomme la ligne et la colonne des totaux\ntab[nrow(tab), 1] <- \"Total\"\nnames(tab)[which(names(tab) == \"NA\")] <- \"Total\"\ntab\n\n# Autre façon d'utiliser les méthodes de data.table\ntab_prop <- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n# Proportion par ligne\ntab_prop[, .SD / Reduce(`+`, .SD), cspf]\n# Proportion par colonne\ncols <- unique(donnees_datatable[, (sexef)])\ntab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = cols]\n\n# Pour avoir les sommes lignes\n# À FAIRE : ne marche pas, à revoir !\n#tab_prop <- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n#tab_prop[, Total := rowSums(.SD), .SDcols = is.numeric]\n#tab_prop <- rbind(tab_prop, tab_prop[, c(cspf = \"Total\", lapply(.SD, sum, na.rm = TRUE)),\n#                                     .SDcols = is.numeric],\n#                  fill = TRUE)\n#tab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n## Pour avoir les sommes colonnes\n#tab[, sum(.SD), by = 1:nrow(tab), .SDcols = is.numeric]\n#tab[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n#\n## Autre solution plus pratique avec data.table\n## Manipuler des formules sur R\n#variable <- c(\"cspf\", \"sexef\")\n#formule <- as.formula(paste(paste(variable, collapse = \" + \"), \".\", sep = \" ~ \"))\n#tab_prop <- data.table::dcast(donnees_datatable, formule, fun.aggregate = length)\n#colnames(tab_prop)[colnames(tab_prop) == \".\"] <- \"total\"\n#tab_prop[, prop := total / sum(total)]\n## Le tableau est remis sous forme croisée\n#tab_prop <- dcast(tab_prop, cspf ~ sexef, value.var = c(\"prop\"), fill = 0)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableau de contingence avec pondération \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntab <- xtabs(poids_sondage ~ cspf + sexef, data = donnees_rbase, addNA = TRUE)\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Avec la fonction count\ndonnees_tidyverse %>% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  spread(sexef, prop)\n# Avec la fonction summarise\ndonnees_tidyverse %>% \n  group_by(cspf, sexef) %>% \n  summarise(prop = sum(poids_sondage, na.rm = TRUE)) %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  spread(sexef, prop)\n# Avec ajout des sommes par ligne et colonne\ntab <- donnees_tidyverse %>% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  # À FAIRE : pourrait-on sommer directement avec pivot_wider ? Argument values_fn?\n  # Ne semble pas fonctionner, pourqoi ???\n  pivot_wider(names_from = sexef, values_from = prop) %>% \n  # Somme par lignes\n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n  # Autre solution avec rowwise : bien penser à c_across et non across !\n  #rowwise() %>% \n  #mutate(Total = sum(c_across(where(is.numeric)), na.rm = T)) %>% \n  #ungroup()\n# Somme par colonnes\ntab <- bind_rows(tab, tab %>% \n                   summarise(across(where(is.numeric), sum, na.rm = TRUE),\n                             across(where(is.character), ~\"Total\"))\n            )\ntab\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ntab <- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Copier-coller le tableau dans un tableur (Excel, etc.) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Copier-coller le résultat sur la fenêtre html \"Results Viewer\" */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab <- xtabs(~ cspf + sexef, data = donnees_rbase)\ntab <- addmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab <- donnees_tidyverse %>% \n  group_by(cspf, sexef) %>% \n  summarise(prop = n(), .groups = \"drop_last\") %>% \n  ungroup() %>% \n  mutate(prop = prop / sum(prop) * 100) %>% \n  spread(sexef, prop)\n\n# Afficher de façon plus jolie un tableau\ntab %>% knitr::kable()\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\ntab %>% \n  knitr::kable() %>% \n  kableExtra::kable_paper(\"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab <- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab <- \naddmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tests d'associaton (Chi-Deux, etc.) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Test du Khi-Deux\nwith(donnees_rbase, chisq.test(cspf, sexef))\nsummary(table(donnees_rbase$cspf, donnees_rbase$sexef))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Test du Khi-Deux\n#donnees_tidyverse %>%\n#  summarise(a = chisq.test(sexef, cspf))\n# À FAIRE : fonctionne, mais pas vraiment Tidyverse\nwith(donnees_tidyverse, chisq.test(cspf, sexef))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Test du Khi-Deux\ndonnees_datatable[, chisq.test(cspf, sexef)]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Solutions avec package R permettant de pondérer \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Package descr \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(descr)\n# Non pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : est-il possible d'appliquer le pipe ???\nlibrary(descr)\n# Non pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(descr)\n# Non pondéré\nwith(donnees_datatable, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_datatable, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_datatable, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Package flextable \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : est-il possible d'appliquer le pipe ???\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Package questionr \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab <- with(donnees_rbase, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab <- with(donnees_rbase, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab <- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab <- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab <- with(donnees_datatable, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab <- with(donnees_datatable, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Package survey \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : ne fonctionne pas\nlibrary(survey)\ntab <- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_rbase)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# La syntaxe avec pipe n'est pas compatible avec le package survey\nlibrary(survey)\ntab <- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_tidyverse)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : ne fonctionne pas\nlibrary(survey)\ntab <- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_datatable)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Package procs \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(procs)\nprocs::proc_freq(donnees_rbase, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_rbase, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(procs)\nprocs::proc_freq(donnees_tidyverse, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_tidyverse, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(procs)\n# Il semble nécessaire de convertire l'objet en data.frame\nprocs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n# On reconvertit en data.table\nsetDT(donnees_datatable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Solutions avec package R ne permettant apparemment pas de pondérer \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab <- janitor::tabyl(donnees_rbase, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable\nlibrary(crosstable)\ncrosstable::crosstable(donnees_rbase, cspf, by = sexef, showNA = \"always\", percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels\nlibrary(gmodels)\ngmodels::CrossTable(donnees_rbase$cspf, donnees_rbase$sexef)\n\n# Package gtsummary\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab <- donnees_tidyverse %>% \n  janitor::tabyl(cspf, sexef) %>% \n  janitor::adorn_totals(c(\"row\", \"col\"))\ntab\n# Pourcentages\ntab %>% janitor::adorn_percentages(denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\ntab %>% janitor::adorn_percentages(denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\ntab %>% janitor::adorn_percentages(denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable\nlibrary(crosstable)\ncrosstable::crosstable(donnees_tidyverse, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels\nlibrary(gmodels)\ndonnees_tidyverse %>% \n  summarise(gmodels::CrossTable(cspf, sexef))\n\n# Package gtsummary\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab <- janitor::tabyl(donnees_datatable, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable : lui non plus ne permet pas de pondérer, apparemment ...\nlibrary(crosstable)\ncrosstable::crosstable(donnees_datatable, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels : ne permet pas de pondérer, apparemment\nlibrary(gmodels)\ngmodels::CrossTable(donnees_datatable$cspf, donnees_datatable$sexef)\n\n# Package gtsummary : ne permet pas de pondérer, apparemment\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"cell\"),  \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"column\"),\n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"row\"),   \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Statistiques agrégées par groupe \n\n\n\n## Une seule variable de groupement, une seule variable \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Moyenne de note_contenu et nombre de personnes */\n/* 1ère solution */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;var note_contenu;class cspf;run;\n/* 2e solution */\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n/* 3e solution */\nproc sql;\n  select cspf, mean(note_contenu) as note_contenu_moyenne, count(*) as N\n  from donnees_sas\n  group by cspf\n  order by cspf;\nquit;\n/* Avec la pondération */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;\n  var note_contenu;class cspf;\n  weight poids_sondage;\nrun;\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  weight poids_sondage;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Moyenne de note_contenu et nombre de personnes\naggregate(note_contenu ~ cspf, donnees_rbase, function(x) c(Moyenne = mean(x, na.rm = TRUE), Nombre = length(x)))\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\naggregate(note_contenu ~ cspf, donnees_rbase, mean, na.rm = TRUE)\n# rowsum, à ne pas confondre avec rowSums, calcule des sommes, et uniquement des sommes\nrowsum(donnees_rbase$note_contenu, donnees_rbase$cspf, recorder = TRUE, na.rm = TRUE)\n# Fonctions tapply et by\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nwith(donnees_rbase, tapply(note_contenu, cspf, mean, na.rm = TRUE))\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nby(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\n\n# Avec la pondération : tapply ne fonctionne pas, il faut découper la base en facteurs avec split\nsapply(split(donnees_rbase, donnees_rbase$cspf), function(x) weighted.mean(x$note_contenu, x$poids_sondage, na.rm = TRUE))\n# À FAIRE : autre solution ?\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Moyenne de note_contenu et nombre de personnes\ndonnees_tidyverse %>% \n  group_by(cspf) %>% \n  summarise(Nombre = n(), Moyenne = mean(note_contenu, na.rm = TRUE))\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\ndonnees_tidyverse %>% \n  group_by(cspf) %>% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE))\n\n# Avec la pondération\ndonnees_tidyverse %>% \n  group_by(cspf) %>% \n  summarise(Moyenne = weighted.mean(note_contenu, poids_sondage, na.rm = TRUE))\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Moyenne de note_contenu et nombre de personnes\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), by = cspf]\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = \"cspf\"]\n# Variables définies à part\nvarNotes <- \"note_contenu\"\nvar_groupe <- \"cspf\"\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))), keyby = var_groupe,\n                  .SDcols = varNotes]\n# Avec la pondération\ndonnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), keyby = var_groupe,\n                  .SDcols = varNotes]\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Plusieurs variables \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%let var_notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\n%let var_groupe = cspf sexef;\nproc sort data = donnees_sas;by &var_groupe.;run;\nproc means data = donnees_sas mean n;\n  class &var_groupe.;\n  var &var_notes.;\n  output out = Resultat;\nrun;\n/* Autre solution */\n%macro sel;\n  %global select;\n  %local i j;\n  %let select = ;\n  %do i = 1 %to %sysfunc(countw(&var_notes.));\n    %let j = %scan(&var_notes., &i., %str( ));\n\t%let select = &select. mean(&j) as &j._moyenne,;\n  %end;\n%mend sel;\n%sel;\n%let group = %sysfunc(tranwrd(&var_groupe., %str( ), %str(, )));\nproc sql;\n  select &group., &select. count(*) as N\n  from donnees_sas\n  group by &group.\n  order by &group.;\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Plusieurs solutions avec aggregate (plutôt lent)\naggregate(note_contenu ~ cspf + sexef, donnees_rbase, function(x) c(mean = mean(x), n = length(x)))\naggregate(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n# Via les formules\nvariable <- c(\"note_contenu\")\nvarGroupement <- c(\"cspf\", \"sexef\")\nformule <- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\naggregate(formule, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n# Avec by\nby(donnees_rbase[, variable], donnees_rbase[, varGroupement], function(x) c(mean = mean(x, na.rm = TRUE), n = length(x)))\n# Avec rowum : on ne peut calculer que la somme\nrowsum(donnees_rbase[, variable], interaction(donnees_rbase[, varGroupement], sep = \"_\", lex.order = TRUE))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_tidyverse %>% \n  group_by(cspf, sexef) %>% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE), n = n())\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = c(\"cspf\", \"sexef\")]\n# Autre solution\ndata.table::dcast(donnees_datatable, cspf + sexef ~ ., value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n# Variables définies à part\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe <- c(\"cspf\", \"sexef\")\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))),\n                  keyby = var_groupe,\n                  .SDcols = varNotes]\n\n# Nombre de femmes par CSP\n# Il y a un recycling de gender = \"M\", utile de le mentionner\ndonnees_datatable[, .(Femmes = sum(sexef == \"Femme\", na.rm = TRUE), Hommes = sum(sexef == \"Homme\", na.rm = TRUE)), by = .(cspf)]\n\n# À FAIRE :\n# Exemple avec les variables dans .SDcols\n# data.table::setDT(DF)[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c(\"x\", \"y\"), by = list(g, h)]\n# D'autres variations (par exemple, c(x, y) ou list(\"x\", \"y\") ne fonctionnent pas !)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux croisés à 2 variables de groupement \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var note_contenu;\n  table (cspf all = \"Ensemble\"), sexef * (note_contenu) * mean;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableau croisé Cspf par Sexef\nvarGroupement <- c(\"cspf\", \"sexef\")\nvariable <- c(\"note_contenu\")\n# Solution avec tapply\ntapply(donnees_rbase[, variable], donnees_rbase[varGroupement], function(x) moyenne = mean(x, na.rm = TRUE))\n# Solution avec xtabs\nxtabs(note_contenu ~ cspf + sexef, aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Ou, sous forme de formule\nformule <- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\nxtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Autre solution, en calculant un tableau \"long\", et en le transformant en \"wide\"\ntableau <- aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE)\nreshape(tableau, \n        timevar = varGroupement[2],\n        idvar = varGroupement[1],\n        direction = \"wide\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableau croisé Cspf par Sexef\nvarGroupement <- c(\"cspf\", \"sexef\")\nvariable <- c(\"note_contenu\")\ndonnees_tidyverse %>% \n  group_by(across(all_of(varGroupement))) %>% \n  summarise(across(all_of(variable), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne\")) %>% \n  spread(varGroupement[2], Moyenne)\n# Autre solution\ndonnees_tidyverse %>% \n  group_by(!!!syms(varGroupement)) %>% \n  summarise(Moyenne = mean(.data[[variable]], na.rm = TRUE)) %>% \n  spread(varGroupement[2], Moyenne)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Tableau croisé Cspf par Sexef\nvarGroupement <- c(\"cspf\", \"sexef\")\nvariable <- \"note_contenu\"\ndata.table::dcast(donnees_datatable, cspf ~ sexef, value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n# Avec références seulement\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable,\n                  fun.aggregate = mean, na.rm = TRUE)\n# Autre solution, plus indirecte\n# À FAIRE : attention, toujours utiliser lapply, même avec une seule variable ! LE DIRE !!!\ntab <- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = varGroupement, .SDcols = \"note_contenu\"]\ndata.table::dcast(tab, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Tableaux croisés à 3 variables de groupement ou plus : 1 variable en ligne, 2 en colonne \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Notes par croisement de CSP (en ligne) et de Sexe x Niveau */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var &notes.;\n  table (cspf all = \"Ensemble\"), sexef * (&notes.) * mean;\nrun;\n\n/* Note_contenu par croisement de CSP (en ligne) et de Sexe x Niveau */\nproc tabulate data = donnees_sas;\n  class cspf sexef Niveau;\n  var note_moyenne;\n  table (cspf all = \"Ensemble\"), (sexef * Niveau) * (note_moyenne) * mean;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe <- c(\"cspf\", \"sexef\")\ntableau <- aggregate(donnees_rbase[, varNotes], donnees_rbase[var_groupe], function(x) moyenne = mean(x, na.rm = TRUE))\nreshape(tableau, \n        timevar = var_groupe[2],\n        idvar = var_groupe[1],\n        direction = \"wide\")\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\n# À FAIRE : proposer une fonction ?\nformule <- as.formula(\"note_contenu ~ cspf + sexef + niveau\")\ntab <- xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\nnomsCol <- do.call(paste, c(expand.grid(dimnames(tab)[-1L]), sep = \"_\"))\nnomsLig <- dimnames(tab)[[1L]]\n# Transformation du tableau de résultats (en format array) vers un format matrix, puis dataframe\n# Permet d'exprimer le array (matrice multidimensionnelle) en un tableau à deux dimensions\n# On transforme le tableau en matrice ayant en nombre de lignes dim(tab)[1], c'est-à-dire le nombre de lignes du array\n# et en nombre de colonnes le reste des variables\ntab <- data.frame(matrix(tab, nrow = dim(tab)[1L]))\n# Renommage des noms des colonnes de la base\ncolnames(tab) <- nomsCol\n# Renommage des noms des lignes de la base\nrow.names(tab) <- nomsLig\n# On annule les valeurs manquantes\ntab[is.na(tab)] <- 0\ntab\n# À FAIRE : développer autour de cet exemple\n# Avec 3 variables\nxtabs(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe <- c(\"cspf\", \"sexef\")\ndonnees_tidyverse %>% \n  group_by(across(all_of(var_groupe))) %>% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %>% \n  pivot_wider(names_from = sexef,\n              values_from = all_of(varNotes))\n\n\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\nvarNotes <- c(\"note_contenu\")\nvar_groupe <- c(\"cspf\", \"sexef\", \"niveau\")\ndonnees_tidyverse %>% \n  group_by(across(all_of(var_groupe))) %>% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %>% \n  pivot_wider(names_from = c(sexef, niveau),\n              values_from = all_of(varNotes),\n              values_fill = 0)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes <- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe <- c(\"cspf\", \"sexef\")\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = varNotes,\n                  fun.aggregate = mean, na.rm = TRUE)\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\ndata.table::dcast(donnees_datatable, cspf ~ sexef + niveau, value.var = \"note_contenu\",\n                  fun.aggregate = mean, na.rm = TRUE)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Boucles \n\n\n\n## Boucles imbriquées \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\ndata _null_;call symput('annee', strip(year(today())));run;\n/* Ensemble des premiers jours de chaque mois entre 2020 et le 31 décembre de l'année courante */\n%macro Boucles_Imbriquees(an_debut, an_fin);\n  %local i j;\n  %global liste_mois;\n  %let liste_mois = ;\n  %do i = &an_debut. %to &an_fin.;\n    %do j = 1 %to 12;\n\t  %let liste_mois = &liste_mois. %sysfunc(putn(%sysfunc(mdy(&j., 1, &i.)), ddmmyy10.));\n\t%end;\n  %end;\n%mend Boucles_Imbriquees;\n%let annee = %sysfunc(year(%sysfunc(today())));\n%Boucles_Imbriquees(an_debut = 2020, an_fin = &annee.);\n%put &liste_mois.;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee <- lubridate::year(Sys.Date())\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois <- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois <- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois <- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n# 3e solution : expand.grid\nlisteMois <- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n# 4e solution, la plus simple !\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee <- lubridate::year(Sys.Date())\n# 1ère solution : 2 fonctions map imbriquées\nlisteMois <- purrr::map(seq(2020, annee), \n                        function(x) purrr::map(1:12,\n                                               function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y)))) %>% \n  unlist() %>% \n  as.Date(, origin = \"1970-01-01\")\n\n# 2e solution : expand_grid\nlisteMois <- tidyr::expand_grid(annee = seq(2020, annee), mois = 1:12) %>% \n  apply(1, function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))) %>% \n  as.Date(, origin = \"1970-01-01\") %>% \n  sort()\n\n# 3e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee <- lubridate::year(Sys.Date())\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois <- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois <- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois <- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n# 3e solution : expand.grid\nlisteMois <- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n# 4e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Boucles imbriquées (second exemple) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Itérer sur toutes les années et les trimestres d'une certaine plage */\n/* on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 */\n%macro iteration(debut, fin);\n  %global liste_an;\n  %let liste_an = ;\n  %do i = &debut. %to &fin.;\n    %let liste_an = &liste_an.&i.-;\n  %end;\n%mend iteration;\n%iteration(debut = 2020, fin = %sysfunc(year(%sysfunc(today()))));\n%put &liste_an.;\n%let liste_trim = 1 2 3 4;\n%let liste_niv = max min;\n/* Supposons que nous ayons des noms de fichier suffixés par AXXXX_TY_NZ, avec X l'année, Y le trimestre et\n   Z max ou min. Par exemple, A2010_T2_NMax */\n/* Pour obtenir l'ensemble de ces noms de 2010 à cette année */\n%macro noms_fichiers(base = temp);\n  %global res;\n  %let res = ;\n  %do j = 1 %to %sysfunc(countw(&liste_an., \"-\"));\n    %let y = %scan(&liste_an., &j., \"-\"); /* année */\n    %do i = 1 %to 4;\n      %let t = %scan(&liste_trim, &i.); /* trimestre */\n      %do g = 1 %to 2;\n        %let n = %scan(&liste_niv., &g.); /* niveau */\n\t\t%let res = &res. &base._&y._t&t._n&n.;\n\t  %end;\n\t%end;\n  %end;\n%mend noms_fichiers;\n%noms_fichiers(base = base);\n%put &res.;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut <- 2020\nfin <- lubridate::year(Sys.Date())\nres <- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut <- 2020\nfin <- lubridate::year(Sys.Date())\nlisteMois <- purrr::map(debut:fin, \n                        function(x) purrr::map(c(\"max\", \"min\"),\n                                               function(y) sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))) %>% \n                          unlist()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut <- 2020\nfin <- lubridate::year(Sys.Date())\nres <- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Boucles for \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On va créer une base par année d'entrée */\nproc sql noprint;\n  select year(min(date_entree)), year(max(date_entree)) into :an_min, :an_max\n  from donnees_sas;\nquit;\n%macro Base_par_mois(debut, fin);\n  /* %local impose que an n'est pas de signification hors de la macro */\n  %local an;\n  /* %global impose que nom_bases peut être utilisé en dehors de la macro */\n  %global nom_bases;\n  /* On initalise la création de la macri-variable nom_bases */\n  %let nom_bases = ;\n  /* On itère entre &debut. et &fin. */\n  %do an = &debut. %to &fin.;\n    data Entree_&an.;\n\t  set donnees_sas;\n\t  if year(date_entree) = &an.;\n\trun;\n\t/* On ajoute à la macro-variable le nom de la base */\n\t%let nom_bases = &nom_bases. Entree_&an.;\n  %end;\n%mend Base_par_mois;\n%Base_par_mois(debut = &an_min., fin = &an_max.);\n%put &nom_bases.;\n\n/* On va désormais empiler toutes les bases (concaténation par colonne) */\n/* L'instruction set utilisée de cette façon permet cet empilement */\ndata concatene;\n  set &nom_bases.;\nrun;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va créer une base par année d'entrée\nanMin <- min(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\nanMax <- max(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == i), ])\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene <- do.call(rbind, lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : problème pour les entrées où la date est manquante\n# On va créer une base par année d'entrée\nanMin <- donnees_tidyverse %>% pull(date_entree) %>% lubridate::year() %>% min(na.rm = TRUE)\nanMax <- donnees_tidyverse %>% pull(date_entree) %>% lubridate::year() %>% max(na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"),\n         donnees_tidyverse %>% filter(lubridate::year(date_entree) == as.name(i)))\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# purrr::reduce applique la fonction bind_rows à l'ensemble des bases issues du purrr::map\n# get permet de faire le chemin inverse de assign\nconcatene <- purrr::map(paste(\"entree\", anMin:anMax, sep = \"_\"), get) %>% \n  purrr::reduce(bind_rows)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# On va créer une base par année d'entrée\nanMin <- min(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\nanMax <- max(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_datatable[lubridate::year(donnees_datatable$date_entree) == i, ])\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene <- rbindlist(lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Boucles for (second exemple) \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* On recherche toutes les valeurs de CSP différentes et on les met dans une variable.\n   On appelle la proc SQL :\n   - utilisation du quit et non run à la fin\n   - on récupère toutes les valeurs différentes de CSP, séparés par un espace (separated by)\n   - s'il y a un espace dans les noms, on le remplace par _ \n   - on les met dans la macro-variable liste_csp\n   - on trier la liste par valeur de CSP */\n/* On crée une variable de CSP formaté sans les accents et les espaces */\ndata donnees_sas;\n  set donnees_sas;\n  /* SAS ne pourra pas créer des bases de données avec des noms accentués */\n  /* On supprime dans le nom les lettres accentués. On le fait avec la fonction Translate */\n  CSPF2 = tranwrd(strip(CSPF), \" \", \"_\");\n  CSPF2 = translate(CSPF2, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\n\n/* Boucles et macros en SAS */\n/* Les boucles ne peuvent être utilisées que dans le cadre de macros */\n/* Ouverture de la macro */\n%macro Boucles(base = donnees_sas, var = CSPF2);\n  /* Les modalités de la variable */\n  proc sql noprint;select distinct &var. into :liste separated by \" \" from &base. order by &var.;quit;\n  /* On affiche la liste de ces modalités */\n  %put &liste.;\n  /* %let permet à SAS d'affecter une valeur à une variable en dehors d'une manipulation de base de données */\n  /* %sysfunc indique à SAS qu'il doit utiliser la fonction countw dans le cadre d'une macro (pas important) */\n  /* countw est une fonction qui compte le nombre de mots (séparés par un espace) d'une chaîne de caractères */\n  /* => on compte le nombre de CSP différentes */\n  %let nb = %sysfunc(countw(&liste.));\n  %put Nombre de modalités différentes : &nb.;\n  /* On itère pour chaque CSP différente ... */\n  %do i = 1 %to &nb.;\n    /* %scan : donne le i-ème mot de &liste. (les mots sont séparés par un espace) */\n    /* => on récupère donc la CSP numéro i */\n    %let j = %scan(&liste., &i.);\n\t%put Variable : &j.;\n\t/* On crée une base avec seulement les individus de la CSP correspondante */\n\tdata &var.;set donnees_sas;if &var. = \"&j.\";run;\n  %end;\n/* Fermeture de la macro */\n%mend Boucles;\n/* Lancement de la macro */\n%Boucles(base = donnees_sas, var = CSPF2);\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Base par CSP\nfor (i in unique(donnees_rbase$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase <- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_rbase[which(donnees_rbase$cspf == i), ])\n}\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Base par CSP\nfor (i in donnees_tidyverse %>% distinct(cspf) %>% pull()) {\n  # Met en minuscule et enlève les accents\n  nomBase <- chartr(\"éèêëàâçîô\", \"eeeeaacio\", i) %>% tolower()\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_tidyverse %>% \n           filter(cspf == as.name(i)))\n}\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Créer une base pour chaque individu d'une certaine CSP\nfor (i in unique(donnees_datatable$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase <- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_datatable[donnees_datatable$cspf == i, ])\n}\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Autres transcriptions de fonctions SAS vers R \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* À FAIRE */\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Mesurer la durée d'exécution d'un programme\nsystem.time(donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ])\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Mesurer la durée d'exécution d'un programme\nsystem.time(donnees_tidyverse <- donnees_tidyverse %>% \n              arrange(identifiant, date_entree))\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Mesurer la durée d'exécution d'un programme\nsystem.time(setorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE))\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Débogage \n\n\n\n## Outils d'aide au débogage \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\noptions symbolgen mprint mlogic;\n%macro Debogage;\n  %local phrase i j;\n  %let phrase = Voici une phrase;\n  %do i = 1 %to %sysfunc(countw(&phrase.));\n    %let j = %scan(&phrase., &i.);\n\t%put Mot n°&i. = &j.;\n  %end;\n%mend Debogage;\n%Debogage;\noptions nosymbolgen nomprint nomlogic;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n#phrase <- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# À FAIRE : creuser\n#phrase <- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n#phrase <- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Points de vigilance en SAS \n\n\n\n## Emploi des guillemets et double guillemets \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Quelques points de vigilance en SAS (à ne connaître que si on est amené à modifier le programme SAS, pas utiles sinon) */\n/* Double guillemets pour les macro-variables */\n%let a = Bonjour;\n%put '&a.'; /* Incorrect */\n%put \"&a.\"; /* Correct */\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Macro-variable définie avec un statut global avant son appel dans le cadre d'un statut local \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n%macro test;\n  %let reponse = oui;\n%mend test;\n%test;\n/* 1. Erreur car &reponse. n'est défini que dans le cas d'un environnement local */ \n%put &reponse.;\n/* 2. Défini auparavant dans un environnement global, elle change de valeur à l'appel de la fonction */\n%let reponse = non;\n%put Reponse : &reponse.;\n%test;\n%put Reponse après la macro : &reponse.;\n/* 3. Problème corrigé, en imposant la variable à local dans la macro */\n%macro test2;\n  %local reponse;\n  %let reponse = oui;\n%mend test2;\n%let reponse = non;\n%put Reponse : &reponse.;\n%test2;\n%put Année après la macro : &reponse.;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Sans objet en R\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n# Fin du programme \n\n\n\n## Taille des objets en mémoire \n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Taille d'une base de données */\nproc sql;\n  select libname, memname, filesize format = sizekmg., filesize format = sizek.\n  from Dictionary.Tables\n  where libname = \"WORK\" and memname = upcase(\"donnees_sas\") and memtype = \"DATA\";\nquit;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_rbase), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Taille, en mémoire, d'une base (en Mb)\ndonnees_tidyverse %>% \n  object.size() %>% \n  format(nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_datatable), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n## Supprimer des bases\n::: {.panel-tabset group=\"language\"}\n\n## `SAS` {.unnumbered .unlisted}\n``` sas\n/* Supprimer une base */\nproc datasets lib = work nolist;delete donnees_sas;run;\n\n/* Supprimer toutes les bases dans la work */\nproc datasets lib = work nolist kill;run;\n```\n\n## `R base` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Supprimer une base\n#rm(donnees_rbase)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n```\n:::\n\n## `tidyverse` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Supprimer une base\n#rm(donnees_tidyverse)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n```\n:::\n\n## `data.table` {.unnumbered .unlisted}\n::: {.cell}\n\n```{.r .cell-code}\n# Supprimer une base\n#rm(donnees_datatable)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n```\n:::\n\n## `arrow/duckdb` {.unnumbered .unlisted}\n::: {.cell}\n\n:::\n\n\n:::\n\n",
    "supporting": [
      "01-aide_memoire_r_sas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}