---
title: "Aide-mémoire SAS - `R`"
lang : fr
author:
  - Nassab ABDALLAH^[Dares/SCS, nassab.abdallah@travail.gouv.fr]
  - Damien EUZENAT^[Dares/DIP, damien.euzenat@travail.gouv.fr]
  - Sébastien LI-THIAO-TE^[Dares/DFA, sebastien.li-thiao-te@travail.gouv.fr]
format:
  html:
    toc: true
    toc-expand: 2
    toc-location: left
    number-sections: true
    code-copy: true
    filters: 
      - fix_meta_notes.lua
# format : native    

editor: visual

# Summary for listings and search engines
description: |
  Un aide-mémoire pour les statisticiens qui connaissent SAS et souhaitent travailler avec `R`.

# Date published
date: "`r Sys.Date()`"
output:
  rmdformats::robobook:
    highlight: tango
    number_sections: true
  
categories:
  - R
  - SAS 
---

L'aide-mémoire a pour but de fournir des codes écrits en SAS et d'en donner la traduction en R de différentes manières possibles :

-   base R

-   tidyverse

-   data.table

-   arrow/duckdb

Les éléments utilisés sont des codes typiques qui sont appliqués dans la production statistique ou dans la réalisation d'études descriptives.

Ce document s'adresse notamment aux utilisateurs de SAS qui veulent connaître la traduction du code SAS en R, aux utilisateurs de R qui ont besoin de comprendre le code SAS, ainsi qu'aux utilisateurs d'un environnement R qui sont intéressés par la traduction dans un autre environnement R.

Il se veut complémentaire de la documentation en ligne en français Utilit'R, née à l'Insee (<https://www.book.utilitr.org/>). Le lecteur est invité à s'y référer pour obtenir des informations importantes sur l'utilisation de R et qui ne sont pas discutées dans ce document, comme l'importation de données en R (<https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats>). 


## Importation des packages

##  {.unnumbered .unlisted}

::: {.panel-tabset group="language"}
## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
library(lubridate)
```

## `Tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
library(lubridate)
library(janitor)
library(magrittr)
library(tidyverse)
```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
library(data.table)
```

## `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
#library(duckdb)
#library(arrow)
```

:::

## Chemin vers le bureau et affichage de la date et de l'année

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Chemin du bureau de l'utilisateur */

/* On vide la log */
dm "log; clear; ";

/* On récupère déjà l'identifiant de l'utilisateur */
%let user = &sysuserid;

/* Chemin proprement dit */
%let bureau = C:\Users\&user.\Desktop;
libname bur "&bureau.";

/* Affichage de l'année */
%let an = %sysfunc(year(%sysfunc(today())));

/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */
%put Année : &an.;

/* Autre possibilité */
data _null_;call symput('annee', strip(year(today())));run;
%put Année (autre méthode) : &annee.;

/* Année passée */
%put Année passée : %eval(&an. - 1);
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On récupère déjà l'identifiant de l'utilisateur
user <- Sys.getenv("USERNAME")
# Chemin d'accès au bureau de l'utilisateur
chemin <- file.path("C:/Users", user, "Desktop")

# Affichage de l'année
annee <- lubridate::year(Sys.Date())
sprintf("Année : %04d", annee)
print(paste0("Année : ", annee))
annee_1 <- annee - 1
paste0("Année passée: ", annee_1)


if (annee >= 2023) {
  print("Nous sommes en 2023 ou après")
} else {
  print("Nous sommes en 2022 ou avant")
}
```

Afficher le répertoire de travail et le définir si besoin 

```{r, warning=FALSE, message=FALSE, results='hide'}
#Afficher 

getwd()
```

```{r, warning=FALSE, message=FALSE, results='hide'}
#Le définir si besoin 

#setwd(dir="nom du répertoire")
```
:::

## Création d'une base de données

Données fictives sur des formations

::: {.panel-tabset group="language"}
## `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees;
  infile cards dsd dlm='|';
  format Identifiant $3. Sexe_red 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel poids_sondage;
  input Identifiant $ Sexe_red CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel poids_sondage;
  cards;
  173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1
  173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3
  173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6
  173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7
  174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9
  175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2
  198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6
  198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3
  198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3
  168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2
  211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4
  278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2
  347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6
  112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1
  112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4
  112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6
  087|1|3|Non qualifie|||365||||||87.3
  087|1|3|Non qualifie||31/10/2020|365||||||87.3
  099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3
  099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3
  099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3
  187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3
  187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1
  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9
  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9
;
run;
```

## `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- data.frame(
  Identifiant = c("173", "173", "173", "173", "174", "175", "198", "198", "198", "168", "211", "278", "347", "112", "112", "112", "087", "087", "099", "099", "099", "187", "187", "689", "765", "765", "765"),
  Sexe_red = c("2", "2", "2", "2", "1", "1", "2", "2", "2", "1", "2", "1", "2", "1", "1", "1", "1", "1", "1", "1", "1", "2", "2", "1", "1", "1", "1"),
  CSP = c("1", "1", "1", "1", "1", "1", "4", "4", "4", "2", "3", "5", "5", "3", "3", "3", "3", "3", "3", "3", "3", "2", "2", "1", "4", "4", "4"),
  Niveau = c("Qualifie", "qualifie", "qualifie", "Non Qualifie", "qualifie", "qualifie", "Non qualifie", "Qualifie", "Qualifie", "Qualifie", "Non qualifie", "Qualifie", "Qualifie", "Non qualifie", 
             "Non qualifie", "qualifie", "Non qualifie", "Non qualifie", "qualifie", "qualifie", "qualifie", "qualifie", "qualifie", NA, "Non qualifie", "Non qualifie", "Non qualifie"),
  Date_naissance = c("17/06/1998", "17/06/1998", "17/06/1998", "17/06/1998", "08/12/1984", "16/09/1989", "17/03/1987", "17/03/1987", "17/03/1987", "30/07/2002", NA, "10/08/1948", 
                     "13/09/1955", "13/09/2001", "13/09/2001", "13/09/2001", NA, NA, "06/06/1998", "06/06/1998", "06/06/1998", "05/12/1986", "05/12/1986", "01/12/2000", "26/12/1995", "26/12/1995", "26/12/1995"),
  Date_entree = c("01/01/2021", "01/01/2022", "06/01/2022", "02/01/2023", "17/08/2021", "21/12/2022", "28/07/2022", "17/11/2022", "21/02/2023", "04/09/2019", "17/12/2021", "07/06/2018", NA, "02/03/2022", "01/03/2021", "01/12/2023", NA, 
                  "31/10/2020", "01/03/2021", "01/03/2022", "01/03/2023", "01/01/2022", "01/01/2023", "06/11/2017", "17/04/2020", "17/04/2020", "17/04/2020"),
  Duree = c("308", "365", "185", "365", "183", "730", "30", "164", "365", "365", "135", "365", "180", "212", "365", "365", "365", "365", "364", "364", "364", "364", "364", "123", "160", "160", "160"),
  Note_Contenu = c("12", "6", "8", "14", "17", "5", "10", "11", "9", "18", "16", "14", "12", "3", "7", NA, NA, NA, "12", "12", "12", "10", "10", "9", "13", "13", "13"),
  Note_Formateur = c("6", NA, "10", "15", "18", "5", "10", "7", "20", "11", "16", "10", "5", "10", "13", NA, NA, NA, "11", "11", "11", "10", "10", "7", "10", "10", "10"),
  Note_Moyens = c("17", "12", "11", "15", "20", "8", "10", "6", "3", "20", "15", "6", "7", "11", "8", NA, NA, NA, "10", "10", "10", "10", "10", "8", "12", "12", "12"),
  Note_Accompagnement = c("4", "7", "1", "10", "15", "4", "16", "14", "4", "13", "12", "8", "11", "9", "19", NA, NA, NA, "12", "12", "12", "10", "10", "13", "18", "18", "18"),
  Note_Materiel = c("19", "14", "9", "8", "12", "9", "8", "13", "17", "15", "9", "12", "12", "8", "2", NA, NA, NA, "13", "13", "13", "10", "10", "16", "10", "10", "10"),
  poids_sondage = c("117.1", "98.3", "214.6", "84.7", "65.9", "148.2", "89.6", "100.3", "49.3", "148.2", "86.4", "99.2", "105.6", "123.1", "137.4", "187.6", "87.3", "87.3", "169.3", "169.3", "169.3", "169.3", "234.1", "189.3", "45.9", "45.9", "45.9")
)

```

## `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
a <- "Identifiant|Sexe_red|CSP|Niveau|Date_naissance|Date_entree|Duree|Note_Contenu|Note_Formateur|Note_Moyens|Note_Accompagnement|Note_Materiel|poids_sondage
173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1
173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3
173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6
173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7
174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9
175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2
198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6
198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3
198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3
168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2
211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4
278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2
347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6
112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1
112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4
112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6
087|1|3|Non qualifie|||365||||||87.3
087|1|3|Non qualifie||31/10/2020|365||||||87.3
099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3
099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3
099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3
187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3
187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1
689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3
765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9
765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9
765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9"
```

```{r, warning=FALSE, message=FALSE, results='hide'}
#readLines va permettre de créer un objet pour chaque ligne
#strsplit va permettre de séparer les textes qui sont entre des "|" 
a <-  readLines(textConnection(a)) %>% 
  strsplit(split='|',fixed=TRUE) 

donnees_tidyverse <- data.frame(matrix(unlist(a), nrow=length(a), byrow=TRUE))

#La première ligne donne le nom des colonnes
donnees_tidyverse <- donnees_tidyverse %>% janitor::row_to_names(row_number = 1)

#On remplace les valeurs qui sont des espaces par des "NA" dans toute 
#la base de données 
donnees_tidyverse <- donnees_tidyverse %>% mutate_all(na_if,"")
```

## `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
donnees_datatable <- data.frame(
  Identifiant = c("173", "173", "173", "173", "174", "175", "198", "198", "198", "168", "211", "278", "347", "112", "112", "112", "087", "087", "099", "099", "099", "187", "187", "689", "765", "765", "765"),
  Sexe_red = c("2", "2", "2", "2", "1", "1", "2", "2", "2", "1", "2", "1", "2", "1", "1", "1", "1", "1", "1", "1", "1", "2", "2", "1", "1", "1", "1"),
  CSP = c("1", "1", "1", "1", "1", "1", "4", "4", "4", "2", "3", "5", "5", "3", "3", "3", "3", "3", "3", "3", "3", "2", "2", "1", "4", "4", "4"),
  Niveau = c("Qualifie", "qualifie", "qualifie", "Non Qualifie", "qualifie", "qualifie", "Non qualifie", "Qualifie", "Qualifie", "Qualifie", "Non qualifie", "Qualifie", "Qualifie", "Non qualifie", 
             "Non qualifie", "qualifie", "Non qualifie", "Non qualifie", "qualifie", "qualifie", "qualifie", "qualifie", "qualifie", NA, "Non qualifie", "Non qualifie", "Non qualifie"),
  Date_naissance = c("17/06/1998", "17/06/1998", "17/06/1998", "17/06/1998", "08/12/1984", "16/09/1989", "17/03/1987", "17/03/1987", "17/03/1987", "30/07/2002", NA, "10/08/1948", 
                     "13/09/1955", "13/09/2001", "13/09/2001", "13/09/2001", NA, NA, "06/06/1998", "06/06/1998", "06/06/1998", "05/12/1986", "05/12/1986", "01/12/2000", "26/12/1995", "26/12/1995", "26/12/1995"),
  Date_entree = c("01/01/2021", "01/01/2022", "06/01/2022", "02/01/2023", "17/08/2021", "21/12/2022", "28/07/2022", "17/11/2022", "21/02/2023", "04/09/2019", "17/12/2021", "07/06/2018", NA, "02/03/2022", "01/03/2021", "01/12/2023", NA, 
                  "31/10/2020", "01/03/2021", "01/03/2022", "01/03/2023", "01/01/2022", "01/01/2023", "06/11/2017", "17/04/2020", "17/04/2020", "17/04/2020"),
  Duree = c("308", "365", "185", "365", "183", "730", "30", "164", "365", "365", "135", "365", "180", "212", "365", "365", "365", "365", "364", "364", "364", "364", "364", "123", "160", "160", "160"),
  Note_Contenu = c("12", "6", "8", "14", "17", "5", "10", "11", "9", "18", "16", "14", "12", "3", "7", NA, NA, NA, "12", "12", "12", "10", "10", "9", "13", "13", "13"),
  Note_Formateur = c("6", NA, "10", "15", "18", "5", "10", "7", "20", "11", "16", "10", "5", "10", "13", NA, NA, NA, "11", "11", "11", "10", "10", "7", "10", "10", "10"),
  Note_Moyens = c("17", "12", "11", "15", "20", "8", "10", "6", "3", "20", "15", "6", "7", "11", "8", NA, NA, NA, "10", "10", "10", "10", "10", "8", "12", "12", "12"),
  Note_Accompagnement = c("4", "7", "1", "10", "15", "4", "16", "14", "4", "13", "12", "8", "11", "9", "19", NA, NA, NA, "12", "12", "12", "10", "10", "13", "18", "18", "18"),
  Note_Materiel = c("19", "14", "9", "8", "12", "9", "8", "13", "17", "15", "9", "12", "12", "8", "2", NA, NA, NA, "13", "13", "13", "10", "10", "16", "10", "10", "10"),
  poids_sondage = c("117.1", "98.3", "214.6", "84.7", "65.9", "148.2", "89.6", "100.3", "49.3", "148.2", "86.4", "99.2", "105.6", "123.1", "137.4", "187.6", "87.3", "87.3", "169.3", "169.3", "169.3", "169.3", "234.1", "189.3", "45.9", "45.9", "45.9")
)
```

## `arrow/duckdb` {.unnumbered .unlisted}

Duckdb fonctionne comme un serveur SQL. Il faut transférer les données vers le serveur SQL.

```{r, warning=FALSE, message=FALSE}
# Ouvrir une connexion au serveur duckdb
con <- DBI::dbConnect(duckdb::duckdb()); 

# On "copie" les données dans une table du nom table_duckdb
con %>% duckdb::duckdb_register(name = "table_duckdb", df = donnees_tidyverse)

con %>% tbl("table_duckdb")

# Fermer la connexion au serveur duckdb
DBI::dbDisconnect(con, shutdown = TRUE)
```

Pour la suite, on suppose que la connexion est ouverte sous le nom `con`, et que les données sont accessibles par la requête `requete_duckdb`. Le code modifiera la requete, mais pas la table dans le serveur SQL.

```{r}
con <- DBI::dbConnect(duckdb::duckdb()); 
con %>% duckdb::duckdb_register(name = "table_duckdb", df = donnees_tidyverse)
requete_duckdb <- con %>% tbl("table_duckdb")
```

N.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier `.parquet` sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n'affectent pas les fichiers source.
:::

## Préparer les données importées

### Casse des noms des variables

[**R étant sensible à la casse, ce qui n'est pas le cas de SAS, cette section est donc pertinente pour les codes sous R.**]{style="color:red"}

1.  Extraire les noms des variables de la base
2.  Mettre le nom de la colonne en minuscules

::: {.panel-tabset group="language"}
### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On vérifie déjà que la base importée est bien un data.frame
is.data.frame(donnees_rbase)
```

On convertit les colonnes en minuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
# Renommer les colonnes de la base
colnames(donnees_rbase) <- tolower(colnames(donnees_rbase))
# Autre possibilité
setNames(donnees_rbase, tolower(names(donnees_rbase)))
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))
```

### `data.table` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On convertit la base en format data.table
# Expliquer les différences
donnees_datatable <- as.data.table(donnees_datatable)
setDT(donnees_datatable)

# On vérifie que la base est bien un data.table
is.data.table(donnees_datatable)
```

On convertit les colonnes en minuscule

```{r, warning=FALSE, message=FALSE}
# Renommer les colonnes de la base
colnames(donnees_datatable) <- tolower(colnames(donnees_datatable))
# Autre possibilité
setNames(donnees_datatable, tolower(names(donnees_datatable)))
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% colnames()
```

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% rename_with(tolower) %>% colnames()
```
:::

### Harmoniser le format des variables

Convertir certaines variables en format 'date', 'integer' et 'numeric'

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees_sas;
  set Donnees_sas;
  duree_int = input(duree, 1.);
  note_contenu_int = input(note_contenu, 1.);
  note_formateur_int = input(note_formateur, 1.);
  note_moyens_int = input(note_moyens, 1.);
  note_accompagnement_int = input(note_accompagnement, 1.);
  note_materiel_int = input(note_materiel, 1.);
  date_naissance_date = input(date_naissance, DDMMYY10.);
  date_entree = input(date_entree, DDMMYY10.);
run;
```

### `R base` {.unnumbered .unlisted}

On a importé toutes les variables en caractère. On convertit certaines variables en format 'numeric' et 'date'

```{r, warning=FALSE, message=FALSE, results='hide'}
enNumerique <- c("duree", "note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
enDate <- c('date_naissance', 'date_entree')
```

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[, enNumerique] <- lapply(donnees_rbase[, enNumerique], as.integer)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[, enDate] <- lapply(donnees_rbase[, enDate], lubridate::dmy)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
#Pour une seule variable 

donnees_rbase$poids_sondage <- as.numeric(donnees_rbase$poids_sondage)
```

On convertit les dates.

```{r, warning=FALSE, message=FALSE, results='hide'}
# On récupère les variables dont le nom débute par le mot "date"
varDates <- names(donnees_rbase)[grepl("date", tolower(names(donnees_rbase)))]
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# On remplace / par - dans les dates
# donnees_rbase[, varDates] <- lapply(donnees_rbase[, varDates], function(x) gsub("/", "-", x))
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# On exprime les dates en format Date
# donnees_rbase[, varDates] <- lapply(donnees_rbase[, varDates], lubridate::dmy)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
enNumerique <- c("duree", "note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
enDate <- c('date_naissance', 'date_entree')
```

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%  
  mutate_at(enNumerique, as.integer) %>% 
  mutate(poids_sondage=as.numeric(poids_sondage)) %>% 
  mutate_at(enDate, lubridate::dmy)
```

### `data.table` {.unnumbered .unlisted}

On a importé toutes les variables en caractère. On convertit certaines variables en format 'numeric' et 'date'

```{r, warning=FALSE, message=FALSE, results='hide'}
enNumerique <- c("duree", "note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
enDate <- c('date_naissance', 'date_entree')
```

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]
# Autre solution
for (j in enNumerique) {
  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))
}
donnees_datatable[, poids_sondage := as.numeric(poids_sondage)]
```

On convertit les dates.

```{r, warning=FALSE, message=FALSE, results='hide'}
# On récupère les variables dont le nom débute par le mot "date"
varDates <- names(donnees_datatable)[grepl("date", tolower(names(donnees_datatable)))]
# On remplace / par - dans les dates
donnees_datatable[, (varDates) := lapply(.SD, function(x) gsub("/", "-", x)), .SDcols = varDates]
# On exprime les dates en format Date
donnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
enNumerique <- c("Duree", "Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel")
enDate <- c('Date_naissance', 'Date_entree')
```

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>%  
  mutate_at(enNumerique, as.integer) %>% 
  mutate(poids_sondage=as.numeric(poids_sondage)) %>%
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  select(enDate, Duree, Note_Contenu)
```

Note : `duckdb` fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.
:::

## Information sur la base de données

### Extraire les 10 première lignes de la base

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Extraire les x premières lignes de la base (10 par défaut) */
%let x = 10;
proc print data = Donnees_sas (firstobs = 1 obs = &x.);run;

/* Ou alors */
data Lignes&x.;set Donnees_sas (firstobs = 1 obs = &x.);proc print;run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Extraire les 10 premières lignes de la base
donnees_rbase[1:10, ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  slice(1:10)
```

### `arrow/duckdb` {.unnumbered .unlisted}

En duckdb, les dix premières lignes sont affichées par défaut. Si on veut les récupérer, par exemple dans une autre variable, il faut faire `collect()`. Attention, comme il n'y a pas d'ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C'est une opération qui peut être couteuse en temps CPU.

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% head(10) %>% collect()
```
:::

### Renommer les variables

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On renomme la variable sexe_red en sexe */
data Donnees_sas;
  set Donnees_sas (rename = (sexe_red = sexe));
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On renomme la variable sexe_red en sexe
donnees_rbase$sexe <- donnees_rbase$sexe_red

#Attention, lorsqu'on utilise ce code pour renommer la variable, l'ancienne variable reste dans la base de données 

#Supprime sexe_red
donnees_rbase <- donnees_rbase[, -which(names(donnees_rbase) %in% c("sexe_red"))]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On renomme la variable sexe_red en sexe
# La fonction rename() va écraser l'ancien nom de la variable contrairement au code utilisé dans la section R base
donnees_tidyverse <- donnees_tidyverse %>% 
  rename(sexe=sexe_red)
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# On renomme la variable sexe_red en sexe
# La fonction rename() va écraser l'ancien nom de la variable contrairement au code utilisé dans la section R base
requete_duckdb %>% rename(sexe=Sexe_red)
```
:::

### Nombre de lignes et de colonnes dans la base

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Nombre de lignes */
proc sql;select count(*) as Nb_Lignes from Donnees_sas;quit;

/* Nombre de colonnes */
proc sql;select count(*) as Nb_Colonnes from Var;quit;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Nombre de lignes et de colonnes dans la base
sprintf("Nombre de lignes : %d | Nombre de colonnes : %d", dim(donnees_rbase)[1], dim(donnees_rbase)[2])
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
#Nombre de lignes
donnees_tidyverse %>% nrow()

#Nombre de colonnes
donnees_tidyverse %>%  ncol()
```

### `arrow/duckdb` {.unnumbered .unlisted}

Duckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire `count()`.

```{r, warning=FALSE, message=FALSE}
#Nombre de lignes
requete_duckdb %>% nrow() # retourne NA
requete_duckdb %>% count() # retourne 27

#Nombre de colonnes
requete_duckdb %>%  ncol()
```
:::

### Afficher les noms des variables de la base

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc contents data=donnees_sas; run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
ls(donnees_rbase)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% colnames()
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% colnames()
```
:::

### Création de colonnes et de lignes

::: {.panel-tabset group="language"}
1.  Création de la colonne note2
2.  Création de la colonne age
3.  *Création de ligne : à faire*

### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees_sas;
  set Donnees_sas;
  note2 = note_contenu / 20 * 5;
  Age = intck('year', date_naissance, date_entree);
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Création de la colonne note2
donnees_rbase$note2 <- donnees_rbase$note_contenu / 20 * 5
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Création de la colonne age 
donnees_rbase$age <- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), "years"))
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Création de la colonne note2
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(note2= note_contenu / 20 * 5)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Création de la colonne age 
donnees_tidyverse <- donnees_tidyverse %>% 
   mutate(age=as.period(interval(start = date_naissance, end = date_entree))$year)
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Création de la colonne note2
requete_duckdb %>% 
  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %>% 
  select(note2)
```

```{r, warning=FALSE, message=FALSE}
# Création de la colonne age 
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  mutate(age = year(age(Date_entree,Date_naissance))) %>% 
  select(age)
```
:::

### Supression de colonnes et de lignes

*Suppression de lignes à faire*

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees_sas;
  set Donnees_sas;
  drop note2;
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$note2 <- NULL
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  select(-note2)
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(- CSP, -contains("Date"), -starts_with("Note"))
```
:::

## Formater les modalités des valeurs

### Valeur discrète

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc format;
  value sexef
  1 = "Homme"
  2 = "Femme";
  
  value $ cspf
  '1' = "Cadre"
  '2' = "Profession intermédiaire"
  '3' = "Employé"
  '4' = "Ouvrier"
  '5' = "Retraité";
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
sexef <- c("1" = "Homme", "2" = "Femme")
cspf <- c("1" = "Cadre", "2" = "Profession intermédiaire", "3" = "Employé", "4" = "Ouvrier", "5" = "Retraité")
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# On exprime CSP et sexe en formaté
donnees_rbase$cspf <- cspf[donnees_rbase$csp]
donnees_rbase$sexef <- sexef[donnees_rbase$sexe]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(sexef = case_when(
    sexe=="1" ~ "Homme",
    sexe=="2" ~ "Femme",
    TRUE ~ sexe),
         cspf = case_when(
    csp=="1" ~ "Cadre",
    csp=="2" ~ "Profession intermédiaire",
    csp=="3" ~ "Employé",
    csp=="4" ~ "Ouvrier",
    csp=="5" ~ "Retraité",
    TRUE ~ csp))
```

### `arrow/duckdb` {.unnumbered .unlisted}

Préférer `case_match` quand il s'agit de valeurs déterminées.

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% 
  mutate(sexef = case_when(
    Sexe_red=="1" ~ "Homme",
    Sexe_red=="2" ~ "Femme",
    .default = Sexe_red),
         cspf = case_match(CSP,
    "1" ~ "Cadre",
    "2" ~ "Profession intermédiaire",
    "3" ~ "Employé",
    "4" ~ "Ouvrier",
    "5" ~ "Retraité",
    .default = CSP)) %>% 
  select(Sexe_red, sexef, CSP, cspf)
```
:::

### Valeur continue

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc format;
  value agef
  low-<26 = "1. De 15 à 25 ans"
  26<-<50 = "2. De 26 à 49 ans"
  50-high = "3. 50 ans ou plus";
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$agef[donnees_rbase$age < 26] <- "1. De 15 à 25 ans"
# 26 <= donnees_rbase$age < 50 ne fonctionne pas, il faut passer en 2 étapes*

donnees_rbase$agef[26 <= donnees_rbase$age & donnees_rbase$age < 50] <- "2. De 26 à 49 ans"

donnees_rbase$agef[donnees_rbase$age >= 50] <- "3. 50 ans ou plus"
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Autre solution
agef <- cut(donnees_rbase$age, 
            breaks = c(0, 25, 49, Inf),
            right = TRUE,
            labels = c("1. De 15 à 25 ans", "2. De 26 à 49 ans", "3. 50 ans ou plus"), 
            ordered_result = TRUE)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%
  mutate(agef = case_when(
    age < 26 ~ "1. De 15 à 25 ans",
    age >= 26 | age < 50 ~  "2. De 26 à 49 ans",
    age >= 50 ~ "3. 50 ans ou plus"))
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>%
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  mutate(age = year(age(Date_entree,Date_naissance))) %>% 
  mutate(agef = case_when(
    age < 26 ~ "1. De 15 à 25 ans",
    age >= 26 | age < 50 ~  "2. De 26 à 49 ans",
    age >= 50 ~ "3. 50 ans ou plus")) %>% 
  select(age, agef)
```
:::

## Manipuler des lignes et des colonnes

*A rajouter : la selection basée sur des conditions*

### Sélection de colonnes

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sql;
  create table work.donnees_col_select_sas as
  select    identifiant, csp, niveau
  from work.donnees_sas;
quit; 
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_col_select_rbase <- donnees_rbase[, c("identifiant", "csp", "niveau")]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_col_select_tidyverse <- donnees_tidyverse %>% 
  select(identifiant, csp, niveau)
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(Identifiant, CSP, starts_with("NI"))
```
:::

### Selection de lignes

::: {.panel-tabset group="language"}

Selectionner les lignes qui ont sexef="Femme"

### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data donnees_sas; 
  set donnees_sas; 
  where sexef="Femme";
 run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_femme_rbase <- donnees_rbase[donnees_rbase$sexef=="Femme", ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_femme_tidyverse <- donnees_tidyverse %>% 
  filter(sexef=="Femme")
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% filter(Sexe_red==2)
```
:::

## Manipuler des lignes et des colonnes

### Mettre un 0 devant un nombre

1.  Créer la variable **mois**
2.  Mettre un 0 devant si le mois est inférieur à 9

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Mettre un 0 devant un nombre */
data Zero_devant;set Donnees_sas (keep = date_entree);
  /* Obtenir le mois et la date */
  Mois = month(date_entree);
  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois <= 9) : format prédéfini z2. */
  Mois_a = put(Mois, z2.);
  drop Mois;
  rename Mois_a = Mois;
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Obtenir le mois et la date
donnees_rbase$mois <- lubridate::month(donnees_rbase$date_entree)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois <= 9)
donnees_rbase$mois <- sprintf("%02d", donnees_rbase$mois)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(mois=lubridate::month(date_entree),
         mois=ifelse(str_length(mois)<2, paste0("0", mois), mois))
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  mutate(mois=lubridate::month(Date_entree),
         mois=ifelse(str_length(mois)<2, paste0("0", mois), mois)) %>% 
  select(mois, Date_entree)
```
:::

### Réexprimer en masse des valeurs

On souhaite rééxprimer les notes sur 100 et non sur 20

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;
/* On supprime les doubles blancs entre les variables */
%let notes = %sysfunc(compbl(&notes.));
%put &notes;Mois_a = Mois;
```

```{r}
#| eval: false
/* 1ère solution : avec les array */
data Sur100_1;
  set Donnees_sas;
  array variables (*) &notes.;
  do increment = 1 to dim(variables);
    variables[increment] = variables[increment] / 20 * 100;
  end; 
  drop increment;
run; 
```

```{r}
#| eval: false
/* 2e solution : avec une macro */
data Sur100_2;
  set Donnees;
  %macro Sur100;
    %do i = 1 %to %sysfunc(countw(&notes.));
      %let note = %scan(&notes., &i.);
      &note. = &note. / 20 * 100;
    %end;
  %mend Sur100;
  %Sur5;
run;
```

```{r}
#| eval: false
/* 3e solution : l'équivalent des list-comprehension de Python en SAS */
data Sur100_3;
  set Donnees_sas;
  %macro List_comprehension;
     %do i = 1 %to %sysfunc(countw(&notes.));
       %let j = %scan(&notes., &i.);
       &j. = &j. / 20 * 100
     %end;);;
  %mend List_comprehension;
  %List_comprehension;
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
notes <- c("note_contenu", "note_formateur", "note_moyens", "note_accompagnement", "note_materiel")
donnees_rbase[, notes] <- donnees_rbase[, notes] / 20 * 100
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(across(starts_with("note"), ~ .x/20*100))
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% 
  mutate(across(starts_with("Note"), ~ as.numeric(.x)/20*100)) %>% 
  select(starts_with("Note"))
```
:::

### Arrondir une valeur numérique

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Arrondir une valeur numérique */
data Arrondis;set donnees_sas (keep = poids_sondage);
  /* Arrondi à l'entier le plus proche */
  poids_arrondi_0 = round(poids_sondage, 0.0);
  /* Arrondi à 1 chiffre après la virgule */
  poids_arrondi_1 = round(poids_sondage, 0.1);
  /* Arrondi à 2 chiffre après la virgule */
  poids_arrondi_2 = round(poids_sondage, 0.2);
  /* Arrondi à l'entier inférieur */
  poids_inf = floor(poids_sondage);
  /* Arrondi à l'entier supérieur */
  poids_inf = ceil(poids_sondage);  
run;
```

### R {.tabset .tabset-fade .tabset-pills}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Arrondi à l'entier le plus proche
poids_arrondi_0 <- round(donnees_rbase$poids, 0)
# Arrondi à 1 chiffre après la virgule
poids_arrondi_1 <- round(donnees_rbase$poids, 1)
# Arrondi à 2 chiffre après la virgule
poids_arrondi_2 <- round(donnees_rbase$poids, 2)
# Arrondi à l'entier inférieur
poids_inf <- floor(donnees_rbase$poids)
# Arrondi à l'entier inférieur
poids_inf <- ceiling(donnees_rbase$poids)
```

### tidyverse {.tabset .tabset-fade .tabset-pills}

```{r, warning=FALSE, message=FALSE}
donnees_tidyverse %>% 
  mutate(
    poids_arrondi_0 = round(poids_sondage,0), # Arrondi à l'entier le plus proche
    poids_arrondi_1 = round(poids_sondage,1), # Arrondi à 1 chiffre après la virgule
    poids_arrondi_2 = round(poids_sondage,2), # Arrondi à 2 chiffre après la virgule
    poids_floor = floor(poids_sondage), # Arrondi à l'entier inférieur
    poids_ceiling = ceiling(poids_sondage), # Arrondi à l'entier inférieur
    ) %>% 
  select(starts_with("poids"))
```


### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% 
  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne
    poids_arrondi_0 = round(as.numeric(poids_sondage),0),
    poids_arrondi_1 = round(as.numeric(poids_sondage),1),
    poids_arrondi_2 = round(as.numeric(poids_sondage),-1),
    poids_floor = floor(as.numeric(poids_sondage)),
    poids_ceiling = ceiling(as.numeric(poids_sondage)),
    ) %>% 
  select(starts_with("poids"))
```
:::

## Les tris

### Trier par colonne

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* On met identifiant date_entree et date_sortie au début de la base */
%let colTri = identifiant date_entree;
data Donnees_sas;
  retain &colTri.;
  set Donnees_sas;
run;
```

```{r}
#| eval: false
/* Autre solution */
proc sql;
  create table Donnees_sas as 
  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */
  /* Dans la proc SQL, les variables doivent être séparées par des virgules */
  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from Donnees_sas;
quit;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On met identifiant date_entree et date_sortie au début
colTri <- c("identifiant", "date_entree")
donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On met identifiant date_entree au début
donnees_tidyverse %>% 
  select(identifiant, date_entree, everything())
donnees_tidyverse %>% 
  relocate(identifiant, date_entree)
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# On met identifiant date_entree au début
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  select(Identifiant, Date_entree, everything())
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  relocate(Identifiant, Date_entree)
```
:::

### Trier les lignes par ordre croissant ou décroissant

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Trier la base par ligne (individu et date de début de la formation) par ordre décroissant : 2 possibilités */
proc sort data = Donnees_sas;by Identifiant Date_entree;run;
proc sql;create table Donnes as select * from Donnees_sas order by Identifiant, Date_entree;quit;
```

```{r}
#| eval: false
/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée*/
proc sort data = Donnees_sas;by Identifiant Date_entree descending;run;
proc sql;create table Donnes as select * from Donnees_sas order by Identifiant, desc Date_entree;quit;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Trier la base par ligne (individu et date de début de la formation) par ordre croissant
# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri
# soit croissant ou décroissant
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]

# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)

#donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$date_entree, na.last = FALSE), ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Trier la base par ligne (individu et date de début de la formation) par ordre croissant
donnees_tidyverse <- donnees_tidyverse %>% 
  arrange(identifiant, date_entree)
```

```{r, warning=FALSE, message=FALSE}
# Tri par ordre croissant de identifiant et décroissant de date_entree 
donnees_tidyverse <- donnees_tidyverse %>% 
  arrange(identifiant, desc(date_entree))
```

### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Trier la base par ligne (individu et date de début de la formation) par ordre croissant
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  arrange(Identifiant, Date_entree) %>% select(Identifiant, Date_entree, Note_Contenu)

# Tri par ordre croissant de identifiant et décroissant de date_entree 
requete_duckdb %>% 
  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %>% # strptime est une fonction duckdb
  arrange(Identifiant, desc(Date_entree)) %>% select(Identifiant, Date_entree, Note_Contenu)
```
:::

### Incidence des valeurs manquantes dans les tris, différence entre SAS et R

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
proc sort data = Donnees_sas;by identifiant date_entree;run;
proc print;run;
```

```{r}
#| eval: false
/* ... et en dernier selon un tri par ordre décroissant*/
proc sort data = Donnees_sas;
  by identifiant descending date_entree;
run;
proc print;run;
```

En effet, les valeurs manquantes sont considérées comme des valeurs négatives

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]

# Pour mimer le tri SAS, il faut écrire :
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...
donnees_tidyverse <- donnees_tidyverse %>% 
  arrange(identifiant, date_entree)

# Pour mimer le tri SAS, il faut écrire :
donnees_tidyverse <- donnees_tidyverse %>% 
  arrange(identifiant, !is.na(date_entree), date_entree)
```



### `arrow/duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...
requete_duckdb %>% arrange(Identifiant, Note_Contenu) %>% select(Identifiant, Note_Contenu)
  
# Pour mimer le tri SAS, il faut écrire :
# Note : il faut faire select d'abord, sinon il y a une erreur quand "! is.na()" est dans la liste des colonnes
requete_duckdb %>% select(Identifiant, Note_Contenu) %>% arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu) 
```
:::

## Manipuler des dates

### Créer une date

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees;
  set Donnees;
  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */
  format date_sortie ddmmyy10.;
  date_sortie = intnx('day', date_entree, duree);
run;
```

### `R base` {.unnumbered .unlisted}

```{r}
# Date de sortie du dispositif
donnees_rbase$date_sortie <- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)
```

### `tidyverse` {.unnumbered .unlisted}

```{r}
# Date de sortie du dispositif
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(date_sortie = date_entree + lubridate::days(duree))
```
:::

### Calculer des durées

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

### `tidyverse` {.unnumbered .unlisted}
:::

### Ajouter une durée à une date

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

### `tidyverse` {.unnumbered .unlisted}
:::

## Manipuler des chaînes de caractères

### Majuscule, minuscule

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/*Première lettre en majuscule*/
data Donnees_sas;
  set Donnees_sas;
  Niveau = propcase(Niveau);
run;
```

```{r}
#| eval: false
/*Majuscule*/
data Donnees_sas;
  set Donnees_sas;
  CSP_majuscule = upcase(CSPF);
run;
```

```{r}
#| eval: false
/*Minuscule*/
data Donnees_sas;
  set Donnees_sas;
  CSP_minuscule = lowcase(CSPF);
run;
```

### `R base` {.unnumbered .unlisted}

-   Première lettre en majuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$niveau <- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))
```

-   Majuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$csp_maj <- toupper(donnees_rbase$cspf)
```

-   Minuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$csp_maj <- tolower(donnees_rbase$cspf)
```

### `tidyverse` {.unnumbered .unlisted}

-   Première lettre en majuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%  
  mutate(niveau=str_to_title(niveau))
```

-   Majuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(csp_maj=toupper(cspf))
```

-   Minuscule

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(csp_maj=tolower(cspf))
```
:::

### Remplacer une chaîne de catactère par une autre

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/*Minuscule*/
data Donnees_sas;
  set Donnees_sas;
  Niveau = tranwrd(Niveau, "Qualifie", "Qualifié");
run;
```

### `R base` {.unnumbered .unlisted}

```{r}
# Le mot qualifie n'a pas d'accent : on le corrige
donnees_rbase$niveau <- gsub("Qualifie", "Qualifié", donnees_rbase$niveau)
```
:::

### Supprimer des blancs

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Manipuler des chaînes de caractères => R = gsub, grepl etc. */
data Exemple_chaines;
Texte = "              Ce   Texte   mériterait   d être   corrigé                  ";
Texte1 = "Je m'appelle";
Texte2 = "SAS";
run;
data Exemple_chaines;set Exemple_chaines;
/* Enlever les blancs au début et à la fin de la chaîne de caractère */
Enlever_Blancs_Initiaux = strip(Texte);
/* Enlever les doubles blancs dans la chaîne de caractères */
Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
texte_rbsase <- "              Ce   Texte   mériterait   d être   corrigé                  "
texte_rbase_1 <- "Je m'appelle"
texte_rbase_2 <- "R"

# trimws enlève les espaces au début et à la fin d'une chaîne de caractère
texte_rbase <- gsub("\\s+", " ", trimws(texte_rbsase))
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
texte_tidyverse <- "              Ce   Texte   mériterait   d être   corrigé                  "
texte_tidyverse_1 <- "Je m'appelle"
texte_tidyverse_2 <- "R"

# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace
texte_tidyverse <- str_squish(texte_tidyverse)
```
:::

### Concaténer des chaînes de caractères

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Trois méthodes pour concaténer des chaînes de caractères */
Concatener  = Texte1||" "||Texte2;
Concatener2 = Texte1!!" "!!Texte2;
Concatener3 = catx(" ", Texte1, Texte2);
/* Extraire les 2e, 3e et 4e caractères de Concatener */
/* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */
extrait = substr(Concatener, 2, 3);
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Concaténer des chaînes de caractères
paste(texte_rbase_1, texte_rbase_2, sep = " ")
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
# Concaténer des chaînes de caractères

str_c(texte_tidyverse_1, texte_tidyverse_2, sep = " ")
```
:::

### Nombre de caractères dans une chaîne de caractères

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
data Donnees;
set Donnees;
/* Nombre de caractères dans une chaîne de caractères*/
taille_id = length(identifiant);
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Nombre de caractères dans une chaîne de caractères
donnees_rbase$taille_id <- nchar(donnees_rbase$identifiant)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Nombre de caractères dans une chaîne de caractères
donnees_tidyverse <- donnees_tidyverse %>% 
   mutate(taille_id = str_split(identifiant, '') %>% 
              lengths)
```
:::

### Transformer plusieurs caractères différents

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
/* Transformer plusieurs caractères différents */
chaine = "éèêëàâçîô";
/* On transforme le é en e, le â en a, le î en i, ... */
chaine_sans_accent = translate(chaine, "eeeeaacio", "éèêëàâçîô");
run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Transformer plusieurs caractères différents
chaine <- "éèêëàâçîô"
chartr("éèêëàâçîô", "eeeeaacio", chaine)
```

:::

## Gestion ligne par ligne

### Numéro de l'observation

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

    
```{r}
#| eval: false
/* Numéro de l'observation */
data Donnees;set Donnees;
Num_observation = _n_;
run;

/* Autre solution */
proc sql noprint;select count(*) into :nbLignes from Donnees;quit;
data numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes

donnees_rbase$num_observation <- row.names(donnees_rbase)
donnees_rbase$num_observation <- seq(1 : nrow(donnees_rbase))
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(num_observation= row_number())
```
:::

### Trier des colonnes

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}
    
```{r}
#| eval: false

/* Numéro du contrat de chaque individu, contrat trié par date de survenue */
proc sort data = Donnees;by identifiant date_entree;run;
data Donnees;set Donnees;
by identifiant date_entree;
retain numero_contrat 0;
if first.identifiant then numero_contrat = 1;
else numero_contrat = numero_contrat + 1;
run;

```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro du contrat de chaque individu, contrat trié par date de survenue
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
donnees_rbase$a <- 1
donnees_rbase$numero_contrat <- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Pour trier les colonnes
tri <- c("identifiant", "date_entree", "numero_contrat", "num_observation")
donnees_rbase_tri <- donnees_rbase[, c(tri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% tri])]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro du contrat de chaque individu, contrat trié par date de survenue 

donnees_tidyverse <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  arrange(identifiant, date_entree) %>% 
  mutate(numero_contrat=row_number())
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Pour trier les colonnes

donnees_tidyverse_tri <- donnees_tidyverse %>% 
  select(identifiant, date_entree, numero_contrat, num_observation, everything())
```
:::

### Identifier le 1er, le 2e, le dernier contrat d'un individu

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

    
```{r}
#| eval: false

  /* 2e contrat de l'individu (et rien si l'individu a fait 1 seul contrat */
  data Deuxieme_Contrat;set Donnees;if numero_contrat = 2;run;
  data Deuxieme_Contrat;set Donnees (where = (numero_contrat = 2));run;

```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Filtre sur le deuxième contrat 

deuxieme_contrat_rbase <- donnees_rbase[donnees_rbase$numero_contrat == 2, ]
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
premier_contrat_rbase <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]
dernier_contrat_rbase <- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]
ni_prem_ni_der_rbase  <- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Filtre sur le deuxième contrat 

deuxieme_contrat_tidyverse <- donnees_tidyverse %>% 
  filter(numero_contrat == 2)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats

premier_contrat_tidyverse <- donnees_tidyverse %>% 
  filter(numero_contrat==1)

dernier_contrat_tidyverse <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  filter(numero_contrat==max(numero_contrat)) %>% 
  ungroup()

ni_prem_ni_der_tidyverse  <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  filter(numero_contrat!=1 & numero_contrat != max(numero_contrat)) %>% 
  ungroup()
```
:::

### Date de fin du contrat précédent

::: {.panel-tabset group="language"}

### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false

/* La date de fin du contrat précédent */
proc sort data = Donnees;by identifiant date_entree;run;
data DonneesBon;set Donnees;
by identifiant date_entree;
format Date_fin_1 ddmmyy10.;
Date_fin_1 = lag(Date_sortie);
if first.identifiant then Date_fin_1 = .;
run;

```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Il faut soit utiliser un package, soit utiliser cette astuce car il n'existe pas de fonction lag dans le R de base (à notre connaissance)
donnees_rbase$date_sortie_1 <- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])
donnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] <- as.Date(NA)
```

:::

### Valeur retardée (lag)

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false

/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */
proc sort data = Donnees;by identifiant date_entree;run;
data Lag_Bon;set Donnees (keep = identifiant date_entree date_sortie);
format date_sortie_1 lag_faux lag_bon ddmmyy10.;
/* Erreur */
if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;
/* Bonne écriture */
date_sortie_1 = lag(date_sortie);
if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;
run;

```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)
# Il faut soit utiliser un package, soit utiliser cette astuce
donnees_rbase$date_sortie_1 <- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])
donnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] <- as.Date(NA)

```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(date_sortie_1 = lag(date_sortie))
```
:::

### Transposer une base

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false

/* Transposer une base */
proc freq data = Donnees;table Sexef * cspf / out = Nb;run;
proc sort data = Nb;by cspf Sexef;run;
proc print data = Nb;run;
proc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;
data transpose;set transpose (drop = _name_ _label_);run;
proc print data = transpose;run;

```


### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array
nb_rbase <- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))
nb_transpose_rbase <- as.data.frame(t(nb_rbase))
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
nb_tidyverse <- donnees_tidyverse %>% janitor::tabyl(cspf, sexef) %>% 
                # colonne cspf comme nom de ligne
                  column_to_rownames(var="cspf")

nb_transpose_tridyverse <- nb_tidyverse %>% sjmisc::rotate_df()
```
:::

## Les valeurs manquantes

### Repérer les valeurs manquantes

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false

/* Repérer les valeurs manquantes */
data Missing;set Donnees;
/* 1ère solution */
if missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;
if age = . or Niveau = '' then missing2 = 1;else missing2 = 0;
keep Age Niveau Missing1 Missing2;
run;

```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase$missing <- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)
ageManquant_rbase_faux <- donnees_rbase[is.na(donnees_rbase$age),  ] # Faux : crée une basse de données avec que des NA
ageManquant_rbase_correct <- donnees_rbase[is.na(donnees_rbase$age), ] # Correct
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  mutate(missing = ifelse(is.na(age) | is.na(niveau), 1, 0))

ageManquant_tidyverse <- donnees_tidyverse %>% 
  filter(is.na(age))
```
:::

### Incidence des valeurs manquantes, différent entre SAS et R

::: {.panel-tabset group="language"}
Incidence des valeurs manquantes :

1.  Dans des opérations (*exemple de la moyenne*)
2.  Dans les tris *renvoyer à la partie tri ou mettre la partie sur les NA de tri ici ?* 

### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

#### Opérations

Il suffit de rajouter l'argument *na.rm=TRUE*

```{r, warning=FALSE, message=FALSE, results='hide'}
mean(donnees_rbase$note_formateur) # s'il existe un seul NA et que l'on ne précise rien, la fonction retournera NA
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Il faut donc rajouter l'argument na.rm=TRUE (remove NA) afin de calculer la moyenne sans prendre en compte les NA

mean(donnees_rbase$note_formateur, na.rm = TRUE)
```

#### Tris

:::

## Les doublons

### Repérage des doublons

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */
    proc contents data = Donnees out = Var noprint;run;
    proc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;

    /* 1ère méthode */
    proc sort data = Donnees;by &nom_col.;run;
    data Doublons;set Donnees;by &nom_col.;
    if first.&derniere_var. = 0 or last.&derniere_var. = 0;
    run;

    /* 2e méthode */

    /* On remplace les blancs entre les mots par des virgules pour la proc sql */

    /* Dans la proc SQL, les variables doivent être séparées par des virgules */
    %let nom_col_sql = %sysfunc(tranwrd(&nom_col., %str( ), %str(, )));

    /* On groupe par toutes les colonnes, et si on aboutit à strictement plus qu'une ligne, c'est un doublon */
    proc sql;create table Doublons as select * from Donnees group by &nom_col_sql. having count(*) > 1;quit;

    /* Suppression des doublons */

    /* 1ère méthode */
    proc sort data = Donnees nodupkey;by &nom_col.;run;

    /* 2e méthode, avec first. et last. (cf. infra) */

    /* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */
    proc contents data = Donnees out = Var noprint;run;
    proc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;
    proc sql noprint;select name into :nom_col separated by " " from Var order by varnum;quit;
    %put Dernière variable de la base : &derniere_var.;
    %put &nom_col.;
    proc sort data = Donnees;by &nom_col.;run;
    data Donnees;set Donnees;by &nom_col.;if first.&derniere_var.;run;


```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Repérage
doublons_rbase <- donnees_rbase[duplicated(donnees_rbase), ]

#doublons ici : toute la ligne est identique avec une autre ligne 
#avec cette commande, s'il y existe des doublons i.e. deux observations qui ont les mêmes observations pour toutes les variables, la base doublons_rbase stockera uniquement un des doublons mais pas toutes les lignes qui sont identiques 
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Repérage
doublons_tidyverse <- donnees_tidyverse %>%  
  group_by(identifiant, sexe) %>% 
  filter(n()>1)

#doublons ici : les observations qui ont le même identifiant et le même sexe 
#avec cette commande, la base doublons_tidyverse va stocker toutes les observations qui sont en doubles i.e. qui ont le même identifiant et le même sexe 
```
:::

### Suppression des doublons

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[! duplicated(donnees_rbase), ]
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# Autre solution (solution first. de SAS)
donnees_rbase <- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]
donnees_rbase <- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% 
  distinct()
```
:::

## Les jointures de base

### Inner Join : identifiants communs aux bases

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false

    /* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */
    data Diplome;
    infile cards dsd dlm='|';
    format Identifiant $3. Diplome $50.;
    input Identifiant $ Diplome $;
    cards;
    173|Bac
    168|Bep-Cap
    112|Bep-Cap
    087|Bac+2
    689|Bac+2
    765|Pas de diplôme
    112|Bac
    999|Bac
    554|Bep-Cap
    ;
    run;
    data Jointure;set Donnees (keep = Identifiant Sexe Age);run;

    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
    proc sort data = Diplome;by identifiant;run;
    proc sort data = Jointure;by identifiant;run;
    data Inner_Join1;
    merge Jointure (in = a) Diplome (in = b);
    by identifiant;
    if a and b;
    run;

    /* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */
    proc sql;
    create table Inner_Join2 as
    select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant
    order by a.identifiant;
    quit;
    proc print data = Inner_Join1;run;
    proc sql;select count(*) from Inner_Join1;quit;

```


### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes
diplome_rbase <- data.frame(identifiant_i = c("173", "168", "112", "087", "689", "765", "112", "999", "554"),
diplome= c("Bac", "Bep-Cap", "Bep-Cap", "Bac+2", "Bac+2", "Pas de diplôme", "Bac", "Bac", "Bep-Cap"),
age_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)
)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1. Inner join : les seuls identifiants communs aux deux bases
jointure_rbase <- donnees_rbase[, c("identifiant", "sexe", "age")]
innerJoin_rbase <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant_i")
dim(innerJoin_rbase)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes
diplome_tidyverse <- data.frame(identifiant= c("173", "168", "112", "087", "689", "765", "112", "999", "554"),
diplome= c("Bac", "Bep-Cap", "Bep-Cap", "Bac+2", "Bac+2", "Pas de diplôme", "Bac", "Bac", "Bep-Cap"),
age_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)
)
```

```{r, warning=FALSE, message=FALSE, results='hide'}
# 1. Inner join : les seuls identifiants communs aux deux bases
jointure_tidyverse<- donnees_tidyverse %>% 
  select(identifiant, sexe, age)

innerJoin_tidyverse <- jointure_tidyverse %>% 
  inner_join(diplome_tidyverse, by="identifiant")
```
:::

### Left et Right Join : identifiants de l'une des bases

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}
```{r}
#| eval: false
    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
    proc sort data = Diplome;by identifiant;run;
    proc sort data = Jointure;by identifiant;run;
    data Left_Join1;
    merge Jointure (in = a) Diplome (in = b);
    by identifiant;
    if a;
    run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 2. Left join : les identifiants de la base de gauche
leftJoin_rbase <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant_i", all.x = TRUE)
dim(leftJoin_rbase)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 2. Left join : les identifiants de la base de gauche
leftJoin_tidyverse <- jointure_tidyverse %>% 
  left_join(diplome_tidyverse, by="identifiant")
```
:::

### Full Join : identifiants de l'une ou l'autre des bases

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */
    proc sort data = Diplome;by identifiant;run;
    proc sort data = Jointure;by identifiant;run;
    data Full_Join1;
    merge Jointure (in = a) Diplome (in = b);
    by identifiant;
    if a or b;
    run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 3. Full join : les identifiants des deux bases
fullJoin_rbase <- merge(jointure_rbase, diplome_rbase, by.x = "identifiant", by.y = "identifiant_i", all = TRUE)
dim(fullJoin_rbase)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 3. Full join : les identifiants des deux bases
fullJoin_tidyverse <- jointure_tidyverse %>% 
  full_join(diplome_tidyverse)
```
:::

### Cross Join : toutes les combinaisons possibles

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome */
    proc sql;
    select *
    from (select distinct CSPF from Donnees) cross join (select distinct Sexef from Donnees) cross join (select distinct Diplome from Diplome)
    order by CSPF, Sexef, Diplome;
    quit;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome
crossJoin_rbase <- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))
colnames(crossJoin_rbase) <- c("cspf", "sexef", "diplome")
crossJoin_rbase
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# 4. Cross join 
crossJoin_tidyverse <- cross_join(jointure_tidyverse, diplome_tidyverse) #à refaire
```
:::

### Empiler les bases

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff
empilement_rbase <- rbind(
data.frame(c(donnees_rbase, sapply(setdiff(names(diplome_rbase), names(donnees_rbase)), function(x) NA))),
data.frame(c(diplome_rbase, sapply(setdiff(names(donnees_rbase), names(diplome_rbase)), function(x) NA)))
)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
# bind_rows permet d'empiler les deux bases de données quel que soit l'ordre et le nombre respectif de colonnes alors que rbind ne fonctionnera pas si les bases de données n'ont pas les mêmes colonnes dans le même ordre. 

empilement_tidyverse <- bind_rows(donnees_tidyverse, diplome_tidyverse)
```
:::

## Statistiques descriptives

### Somme, moyenne, médiane, minimum, maximum, nombre de valeurs

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* Moyenne de chaque note */
    %let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;
    proc means data = Donnees mean;var &notes.;run;

    /* Somme, moyenne, médiane, minimum, maximum, nombre de données */
    proc means data = Donnees sum mean median min max n;var &notes.;run;

    /* Notes pondérées (poids de sondage) */
    proc means data = Donnees sum mean median min max n;var &notes.;weight poids_sondage;run;
```

### `R base` {.unnumbered .unlisted}

-   Moyenne

```{r, warning=FALSE, message=FALSE, results='hide'}
# Moyenne de chaque note
notes_rbase <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
lapply(donnees_rbase[, notes_rbase], mean, na.rm = TRUE)
```

-   Moyenne, médiane, maximum, minimum

```{r, warning=FALSE, message=FALSE, results='hide'}
sapply(donnees_rbase[, notes], function(x) c("Somme" = sum(x, na.rm = TRUE), "Moyenne" = mean(x, na.rm = TRUE),
"Médiane" = median(x, na.rm = TRUE), "Max" = max(x, na.rm = TRUE),
"Min" = min(x, na.rm = TRUE)))
```

-   Moyenne avec pondération

```{r, warning=FALSE, message=FALSE, results='hide'}
# Avec la pondération
with(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))
```

-   Résumé statistique

```{r, warning=FALSE, message=FALSE, results='hide'}
summary(donnees_rbase[, notes])
```

### `tidyverse` {.unnumbered .unlisted}

-   Moyenne par identifiant

```{r, warning=FALSE, message=FALSE, results='hide'}
notes_tidyverse <- donnees_tidyverse %>%  
  select(starts_with("Note")) %>% 
  summarise_all(.funs = c(mean="mean"))
```

-   Moyenne par identifiant par pondération

```{r, warning=FALSE, message=FALSE, results='hide'}
notes_tidyverse <- donnees_tidyverse %>%  
  select(starts_with("Note"), poids_sondage) %>% 
  summarise(across(note_contenu:note_materiel, ~weighted.mean(., w = poids_sondage)))
```
:::

### Quantiles

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### R base

```{r, warning=FALSE, message=FALSE, results='hide'}
# Déciles et quartiles de la note moyenne
quantile(donnees_rbase$note_moyens, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>%  
  summarise(quantile = scales::percent(c(0.25, 0.5, 0.75)),
            note_moyens = quantile(note_moyens, c(0.25, 0.5, 0.75), na.rm = TRUE))
```
:::

### Tableaux de fréquence / contingence : proc freq

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* Tableaux de fréquence : proc freq */
    proc freq data = Donnees;
    tables Sexe CSP / missing;
    format Sexe sexef. CSP $cspf.;
    /*weight poids_sondage;*/
    run;
```

### `R base` {.unnumbered .unlisted}

L'équivalent de *proc freq* sur SAS :

```{r, warning=FALSE, message=FALSE, results='hide'}
table(donnees_rbase$sexef, useNA = "always")
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
tableau_contingence <- donnees_tidyverse %>% 
  group_by(sexef) %>% 
  summarise(n=n())

tableau_contingence
```
:::

### Proportion

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
prop.table(table(donnees_rbase$sexef, useNA = "always")) * 100
```

### `tidyverse` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
proportion <- donnees_tidyverse %>% 
  group_by(sexef) %>% 
  summarise(n=n(),
            pourcentage=round(n/length(donnees_tidyverse$sexef)*100,2))

proportion
```
:::

## Fonction, macros SAS

### Boucles, itérations

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

### `tidyverse` {.unnumbered .unlisted}
:::

### Créations automatiques de bases, empilements de bases

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

### `R base` {.unnumbered .unlisted}

### `tidyverse` {.unnumbered .unlisted}
:::

## Fin du programme

### Supprimer toutes les bases de la mémoire vive (work RAM)

::: {.panel-tabset group="language"}
### `SAS` {.unnumbered .unlisted}

```{r}
#| eval: false
    /* Supprimer toutes les bases de la mémoire vive (la work) => rm(list = ls()) */
    proc datasets lib = work nolist kill;run;
```

### `R base` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
#rm(list = ls()) #conflit avec cellule d'après sinon 
```

### `Duckdb` {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE, results='hide'}
DBI::dbDisconnect(con, shutdown = TRUE)
```
:::

## Points de vigilance en SAS